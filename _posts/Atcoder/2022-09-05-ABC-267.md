---
title: "[AC #1] AtCoder Beginner Contest 267"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Coding Contest
use_math: true
comments: true

---

`Tags` 

## Result & Review

올해 초에 아이디만 만들어두고 코드포스만 했었는데, 코드포스가 자주 열리긴 해도 주기적으로 열리는 형태는 아니라서 앳코더를 시작하게 되었다.

주말 저녁 9시에 열리기 때문에 꾸준하게 참가하기도 좋아보였다.

이번 대회는 비기너여서 그런지 문제들이 쉬운 편이었고, 그 대신 시간이 100분으로 조금 짧았다.

F번을 풀다가 시간이 다 되었는데, 앞의 쉬운 문제들에서 조금 버벅거린게 아쉬웠다.

앳코더도 코드포스처럼 일정 횟수 이상 대회를 참여해야 정확한 레이팅이 나오는 것 같은데, 910등 정도로 마무리해서 레이팅이 351점이 되었다.

<br/>

## A. Saturday

[A번 문제 링크](https://atcoder.jp/contests/abc267/tasks/abc267_a)

요일을 입력 받은 후, 해당 요일 이후의 첫 번째 토요일까지의 기간을 구하는 문제이다.

---

### [SOLUTION] Implementation

거의 코딩 기초를 배울 때 푸는 문제가 나와서, 처음에는 문제를 잘 못 읽은 줄 알았다.

Map으로 인덱스를 부여할까 생각도 했지만, 월화수목금만 처리해주면 되서 직접 하나하나 케이스를 나누어서 구현하였다.

```cpp
#include <iostream>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    string s; cin >> s;
    if (s[0] == 'M') cout << "5";
    else if (s[0] == 'W') cout << "3";
    else if (s[0] == 'F') cout << "1";
    else if (s[1] == 'u') cout << "4";
    else cout << "2";
}
```

<br/>

## B. Split

[B번 문제 링크](https://atcoder.jp/contests/abc267/tasks/abc267_b)

볼링핀들이 아래 조건을 만족하면 **split**이라고 부른다.

- 1번 핀이 쓰러져 있다.
- 하나 이상의 핀이 서 있는 서로 다른 두 열이 있고, 두 열 사이에는 모든 핀이 쓰러진 열이 하나 이상 있다.

볼링핀들의 상태가 주어질 때, split이면 "Yes", 아니면 "No"를 출력하여라.

---

### [SOLUTION] Implementation

두 번째 문제도 단순 구현 문제였다.

1번 핀이 쓰러졌는지 확인하고, 하나 이상의 볼링핀이 남아 있는 열들을 찾아줌으로써 해결할 수 있다.

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    vector<int> col = { 3, 2, 4, 1, 3, 5, 0, 2, 4, 6 };
    string s; cin >> s;
    
    if (s[0] == '1') cout << "No";
    else {
        vector<bool> chk(7, 0);
        for (int i = 1; i < 10; i++) if (s[i] == '1') chk[col[i]] = 1;
        
        vector<int> v;
        for (int i = 0; i < 7; i++) if (chk[i]) v.push_back(i);

        bool flg = 0;
        for (int i = 0; i + 1 < v.size(); i++) if (v[i + 1] - v[i] > 1) flg = 1;
        cout << (flg ? "Yes" : "No");
    }
}
```

<br/>

## C. Index * A (Continuous ver.)

[C번 문제 링크](https://atcoder.jp/contests/abc267/tasks/abc267_c)

길이가 $N$($1 \leq N \leq 2 \cdot 10^5$)인 정수 수열 $A_1, A_2, \dots, A_N$ 이 주어진다.

길이가 $M$($1 \leq M \leq N$)인 $A$의 연속한 부분수열 $B_1, B_2, \dots, B_M$ 에 대하여, 아래 값의 최댓값을 구하여라.

\begin{aligned}
\sum_{i=1}^M (i \times B_i)
\end{aligned}

---

### [SOLUTION] Math




```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
typedef long long ll;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int n, m; cin >> n >> m;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];

    ll x = 0, ans = 0, sum = 0;
    for (int i = 0; i < m; i++) {
        x += 1ll * (i + 1) * a[i];
        sum += a[i];
    }
    ans = x;
    for (int i = 1; i + m - 1 < n; i++) {
        x = x - sum + 1ll * m * a[i + m - 1];
        ans = max(ans, x);
        sum += a[i + m - 1] - a[i - 1];
    }
    cout << ans;
}
```





