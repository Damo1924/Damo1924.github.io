---
title: "[AC #1] AtCoder Beginner Contest 267"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Coding Contest
use_math: true
comments: true

---

`Tags` 

## Result & Review

올해 초에 아이디만 만들어두고 코드포스만 했었는데, 코드포스가 자주 열리긴 해도 주기적으로 열리는 형태는 아니라서 앳코더를 시작하게 되었다.

주말 저녁 9시에 열리기 때문에 꾸준하게 참가하기도 좋아보였다.

이번 대회는 비기너여서 그런지 문제들이 쉬운 편이었고, 그 대신 시간이 100분으로 조금 짧았다.

F번을 풀다가 시간이 다 되었는데, 앞의 쉬운 문제들에서 조금 버벅거린게 아쉬웠다.

앳코더도 코드포스처럼 일정 횟수 이상 대회를 참여해야 정확한 레이팅이 나오는 것 같은데, 910등 정도로 마무리해서 레이팅이 351점이 되었다.

<br/>

## A. Saturday

[A번 문제 링크](https://atcoder.jp/contests/abc267/tasks/abc267_a)

요일을 입력 받은 후, 해당 요일 이후의 첫 번째 토요일까지의 기간을 구하는 문제이다.

---

### [SOLUTION] Implementation

거의 코딩 기초를 배울 때 푸는 문제가 나와서, 처음에는 문제를 잘 못 읽은 줄 알았다.

Map으로 인덱스를 부여할까 생각도 했지만, 월화수목금만 처리해주면 되서 직접 하나하나 케이스를 나누어서 구현하였다.

```cpp
#include <iostream>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    string s; cin >> s;
    if (s[0] == 'M') cout << "5";
    else if (s[0] == 'W') cout << "3";
    else if (s[0] == 'F') cout << "1";
    else if (s[1] == 'u') cout << "4";
    else cout << "2";
}
```

<br/>

## B. Split

[B번 문제 링크](https://atcoder.jp/contests/abc267/tasks/abc267_b)

볼링핀들이 아래 조건을 만족하면 **split**이라고 부른다.

- 1번 핀이 쓰러져 있다.
- 하나 이상의 핀이 서 있는 서로 다른 두 열이 있고, 두 열 사이에는 모든 핀이 쓰러진 열이 하나 이상 있다.

볼링핀들의 상태가 주어질 때, split이면 "Yes", 아니면 "No"를 출력하여라.

---

### [SOLUTION] Implementation

두 번째 문제도 단순 구현 문제였다.

1번 핀이 쓰러졌는지 확인하고, 하나 이상의 볼링핀이 남아 있는 열들을 찾아줌으로써 해결할 수 있다.

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    vector<int> col = { 3, 2, 4, 1, 3, 5, 0, 2, 4, 6 };
    string s; cin >> s;
    
    if (s[0] == '1') cout << "No";
    else {
        vector<bool> chk(7, 0);
        for (int i = 1; i < 10; i++) if (s[i] == '1') chk[col[i]] = 1;
        
        vector<int> v;
        for (int i = 0; i < 7; i++) if (chk[i]) v.push_back(i);

        bool flg = 0;
        for (int i = 0; i + 1 < v.size(); i++) if (v[i + 1] - v[i] > 1) flg = 1;
        cout << (flg ? "Yes" : "No");
    }
}
```

<br/>

## C. Index * A (Continuous ver.)

[C번 문제 링크](https://atcoder.jp/contests/abc267/tasks/abc267_c)

길이가 $N$($1 \leq N \leq 2 \cdot 10^5$)인 정수 수열 $A_1, A_2, \dots, A_N$ 이 주어진다.

길이가 $M$($1 \leq M \leq N$)인 $A$의 연속한 부분수열 $B_1, B_2, \dots, B_M$ 에 대하여, 아래 값의 최댓값을 구하여라.

\begin{aligned}
\sum_{i=1}^M (i \times B_i)
\end{aligned}

---

### [SOLUTION] Math

모든 $j$($0 \leq j \leq N - M$)에 대하여

\begin{aligned}
S_j = \sum_{i=1}^M (i \times A_{i + j})
\end{aligned}

의 값을 구한 후, 최댓값을 찾아주자. 이때

\begin{aligned}
S_{j+1} - S_j = M \cdot A_{M + j + 1} - \sum_{i=1}^M A_{i + j}
\end{aligned}

가 성립하는 것을 이용하면 $O(N)$으로 최댓값을 구할 수 있다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
typedef long long ll;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int n, m; cin >> n >> m;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];

    ll x = 0, sum = 0;
    for (int i = 0; i < m; i++) {
        x += 1ll * (i + 1) * a[i];
        sum += a[i];
    }
    ll ans = x;
    for (int i = 1; i + m - 1 < n; i++) {
        x = x - sum + 1ll * m * a[i + m - 1];
        ans = max(ans, x);
        sum += a[i + m - 1] - a[i - 1];
    }
    cout << ans;
}
```

<br/>

## D. Index * A (Not Continuous ver.)

[D번 문제 링크](https://atcoder.jp/contests/abc267/tasks/abc267_d)

길이가 $N$($1 \leq N \leq 2000$)인 정수 수열 $A_1, A_2, \dots, A_N$ 이 주어진다.

길이가 $M$($1 \leq M \leq N$)인 $A$의 부분수열 $B_1, B_2, \dots, B_M$ 에 대하여, 아래 값의 최댓값을 구하여라.

\begin{aligned}
\sum_{i=1}^M (i \times B_i)
\end{aligned}

이때 부분수열이란 기존 수열에서 $0$개 이상의 원소를 제거함으로써 얻을 수 있는 수열을 의미한다. (원소들 간의 순서가 달라지면 안된다.)

---

### [SOLUTION] DP

길이가 $M$인 부분수열의 개수는 $\_N C_M$ 이고, 각 부분수열에 대해 주어진 수식의 값을 구하는데 $O(M)$이므로 브루트포스로 해결할 수 없다.

다이나믹 프로그래밍으로 접근하기 위해 아래와 같은 배열을 정의하자.

- $dp(i, j)$ : $A_j$를 마지막 원소로 하는 길이가 $i$인 부분수열들 중 수식의 최댓값

어떤 $i, j$에 대하여 $dp(i, j)$는 다음과 같이 구할 수 있다.

\begin{aligned}
dp(i, j) = i \cdot A_j + \max_{1 \leq k < j} dp(i-1, k)
\end{aligned}

이때 고정된 $i$에 대하여 $j$를 증가시켜가며 구한다면 $\max_{1 \leq k < j} dp(i-1, k)$ 을 $O(1)$에 구할 수 있다.

즉, 어떤 $i, j$에 대하여 $dp(i, j)$를 구하는데 $O(1)$이 걸린다.

우리가 구하고자 하는 값은 $\max_{1 \leq j \leq N} dp(M, j)$ 이고, 전체 시간복잡도는 $O(NM)$이다.

```cpp
#include <iostream>
using namespace std;
typedef long long ll;

ll a[2001], dp[2001][2001];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int n, m; cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];

    for (int i = 1; i <= n; i++) dp[1][i] = a[i];
    for (int i = 2; i <= m; i++) {
        ll mx = dp[i - 1][i - 1];
        for (int j = i; j <= n; j++) {
            dp[i][j] = mx + a[j] * i;
            mx = max(mx, dp[i - 1][j]);
        }
    }

    ll ans = -1e18;
    for (int i = m; i <= n; i++) ans = max(ans, dp[m][i]);
    cout << ans;
}
```

<br/>

## E. Erasing Vertices 2

[E번 문제 링크](https://atcoder.jp/contests/abc267/tasks/abc267_e)

$N$($1 \leq N \leq 2 \cdot 10^5$)개의 정점과 $M$($0 \leq M \leq 2 \cdot 10^5$)개의 간선으로 이루어진 simple undirected graph가 주어진다.

각 정점들에는 $1$부터 $N$까지의 번호가 매겨져 있고, $i$번째 정점에는 양의 정수 $A_i$가 적혀 있다.

주어진 그래프에 대하여 다음 연산을 $N$번 진행한다.

- 아직 제거되지 않은 정점 $x$를 선택한 후, $x$와 $x$에 연결된 모든 간선들을 제거한다.
- 각 연산의 비용은 제거한 간선들로 연결된 정점들에 적힌 정수들의 합이다.

이때 $N$번의 연산의 비용의 합의 최솟값을 구하여라.

---

### [MY SOLUTION] Greedy + Segment tree

매번 연산 비용이 가장 작은 정점을 선택하는 방법이 최솟값이다.

최솟값과 해당하는 인덱스를 반환하는 세그먼트 트리를 구현하여 해결하였다.

전체 시간복잡도는 $O((N + M) \log N)$ 이다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
typedef long long ll;

struct Segtree {
    int n;
    vector<pair<ll, int>> node;
    Segtree() {}
    Segtree(int _n) : n(_n) {
        node.resize(2 * n);
        for (int i = n; i < 2 * n; i++) node[i] = { 0, i - n };
    }
    void build() {
        for (int i = n - 1; i; i--) node[i] = min(node[2 * i], node[2 * i + 1]);
    }
    void upd(int i, ll diff) {
        node[n + i].first += diff;
        for (int j = (n + i) / 2; j; j /= 2) node[j] = min(node[2 * j], node[2 * j + 1]);
    }
};

vector<int> g[200001];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int n, m; cin >> n >> m;
    vector<int> a(n + 1);
    Segtree tree(n);
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 0; i < m; i++) {
        int u, v; cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
        tree.node[n + u - 1].first += a[v];
        tree.node[n + v - 1].first += a[u];
    }
    tree.build();
    
    ll ans = -1e18;
    for (int i = 0; i < n; i++) {
        ans = max(ans, tree.node[1].first);
        int j = tree.node[1].second;
        tree.upd(j, 1e18);
        for (int k : g[j + 1]) tree.upd(k - 1, -a[j + 1]);
    }
    cout << ans;
}
```

---

### [OFFICIAL SOLUTION] Binary search





