---
title: "[AC #2] AtCoder Regular Contest 147"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Coding Contest
use_math: true
comments: true

---

`Tags` 

## Result & Review

최근에 추석 연휴도 있고 해서 좀 늘어져 있어서 이제야 2주 전에 참여한 대회 업솔빙을 하게 되었다.

A, B번은 어렵지 않게 풀었지만 C번은 나름 시행착오를 겪었다.

대회가 끝나고 생각보다 등수가 높아서 놀랐었는데, ARC에 참여하는게 레이팅이 더 많이 오를 것 같다.

<br/>

## A. Max Mod Min

[A번 문제 링크](https://atcoder.jp/contests/arc147/tasks/arc147_a)

양의 정수로 이루어진 길이가 $N$($2 \leq N \leq 2 \cdot 10^5$)인 수열 $A = (A_1, A_2, \dots, A_N)$ 가 주어진다.

$A$의 길이가 $1$이 될 때까지 아래 연산을 반복해서 수행한다.

- 현재 수열 $A$의 길이를 $k$라고 하자.
- $\max(A_1, A_2, \dots, A_k) = A_i$, $\min(A_1, A_2, \dots, A_k) = A_j$ 를 만족하는 서로 다른 두 정수 $i, j$를 선택한다.
- $A_i$를 $A_i \,\bmod\, A_j$ 로 바꾸고, 만약 이 값이 $0$이면 $A_i$를 제거한다.

수열 $A$가 주어질 때, 수행하게 될 연산의 횟수를 구하여라.

이때, $i, j$를 어떻게 선택하는지에 따라서 전체 연산의 횟수가 변하지 않는다는 것을 증명할 수 있다.

---

### [SOLUTION] Deque

$A_i \,\bmod\, A_j$ 는 항상 최솟값인 $A_j$보다 작으므로, 우리는 다음 최솟값이 $A_i$임을 바로 알 수 있다.

또, 수열 $A$를 정렬해두면 다음 최댓값도 바로 알 수 있다.

즉, 연산을 한 번 수행하는 시간복잡도는 $O(1)$이다.

문제의 답을 $X$라고 하면 전체 시간복잡도는 $O(N \log N + X)$ 이다.

이때, 임의의 두 정수 $a, b$($a \geq b$)에 대해 아래 부등식이 성립한다.

\begin{aligned}
\frac{a}{2} \geq a \,\bmod\, b
\end{aligned}

수열의 각 원소들은 $A_j$로써 최대 $O(\log \max A)$번 선택되므로, $O(X) = O(N \log \max A)$ 라고 할 수 있다.

아래는 위 부등식의 간단한 증명 과정이다.

> **Proof.** 귀류법을 이용하기 위해 $\frac{a}{2} < a \,\bmod\, b$ 인 정수 $a, b$($a \geq b$)가 존재한다고 가정하자.
> 
> $c = a \,\bmod\, b$ 라고 하면, $a < 2c$ 이다.
> 
> 어떤 양의 정수 $k$에 대하여 $c = a - kb$ 로 표현할 수 있고, $2kb < a$ 를 얻을 수 있다.
> 
> 이로부터 $c = a - kb > kb \geq b$ 를 얻을 수 있는데, 이는 $c$가 $b$보다 작아야 한다는 것에 모순이다.

수열 $A$를 덱(deque)으로 구현함으로써 해결하였다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <deque>
using namespace std;

int main() {
    int n; cin >> n;
    deque<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    sort(a.begin(), a.end());
    
    int ans = 0;
    while (a.size() > 1) {
        int mx = a.back(), mn = a.front();
        a.pop_back();
        if (mx % mn) a.push_front(mx % mn);
        ans++;
    }
    cout << ans;
}
```

<br/>

## B. Swap to Sort

[B번 문제 링크](https://atcoder.jp/contests/arc147/tasks/arc147_b)

$1$부터 $N$($2 \leq N \leq 400$)까지의 정수들의 순열 $P= (P_1, P_2, \dots, P_N)$이 주어진다.

아래 두 가지 연산을 자유롭게 사용해서 $P$를 오름차순으로 정렬하려고 한다.

- Operation A: 정수 $i$($1 \leq i \leq N - 1$)을 선택한 후, $P_i$와 $P_{i+1}$을 교환한다.
- Operation B: 정수 $i$($1 \leq i \leq N - 2$)을 선택한 후, $P_i$와 $P_{i+2}$을 교환한다.

이때 아래 조건을 만족하면서 $P$를 정렬하는 연산들을 순서대로 출력하여라.

- 연산 A를 최대한 적게 사용해야한다.
- 전체 연산 횟수는 $10^5$을 넘지 않는다.

---

### [SOLUTION] Constructive algorithm

순열의 한 원소 $P_i$는 네 가지 상태를 가질 수 있다.

1. $i$가 짝수, $P_i$가 짝수
2. $i$가 짝수, $P_i$가 홀수
3. $i$가 홀수, $P_i$가 짝수
4. $i$가 홀수, $P_i$가 홀수

먼저, $i$와 $P_i$의 홀짝성이 동일한 1번과 4번 케이스들은 연산 B만 이용해서 각자의 알맞은 자리로 옮겨줄 수 있다.

반대로, 2번과 3번 케이스들 같은 경우에는 연산 A를 적어도 한 번씩은 반드시 사용해주어야 한다.

문제에서 요구하는 조건은 연산 A를 최대한 적게 수행하는 것이므로, **2번과 3번 케이스들을 짝지어서 이웃하게 만들어준 후 연산 A를 수행**해주어야 한다.

이때, $i$와 $P_i$는 모두 $1$부터 $N$까지의 정수 값을 하나씩 갖는다는 점을 떠올려보자.

$i$들 중 짝수의 개수와 $P_i$들 중 짝수의 개수가 같다는 사실로부터 우리는 2번 케이스들과 3번 케이스들의 개수가 동일하다는 것을 알 수 있다.

즉, 임의의 순열 $P$에서 $2$번과 $3$번 케이스들을 일대일 대응 시켜줄 수 있다.

나는 아래와 같은 방법으로 순열을 정렬하였다.

1. 주어진 순열에서 2번과 3번 케이스들을 찾는다.
2. 각 케이스에서 하나씩 선택한 후, 연산 B를 이용해서 이웃한 상태로 만들고 연산 A를 한 번 수행해준다.
3. 연산 B를 이용해서 각 숫자를 알맞은 자리로 옮긴다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int p[400];
int find(int x) {
    for (int i = 0; i < 400; i++) if (p[i] == x) return i;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int n; cin >> n;
    vector<int> odd, even;
    for (int i = 0; i < n; i++) {
        cin >> p[i];
        if (p[i] % 2 != 0 && i % 2 != 0) odd.push_back(p[i]);
        if (p[i] % 2 == 0 && i % 2 == 0) even.push_back(p[i]);
    }

    vector<pair<bool, int>> ans;
    for (int j = 0; j < odd.size(); j++) {
        int a = odd[j], b = even[j];
        int ai = find(a), bi = find(b);
        if (ai > bi) {
            swap(a, b);
            swap(ai, bi);
        }

        while (ai < bi - 1) {
            ans.push_back({ 1, ai });
            swap(p[ai], p[ai + 2]);
            ai += 2;
        }
        ans.push_back({ 0, ai });
        swap(p[ai], p[ai + 1]);
    }

    for (int i = 1; i <= n; i++) {
        int j = find(i);
        while (j != i - 1) {
            ans.push_back({ 1, j - 2 });
            swap(p[j - 2], p[j]);
            j -= 2;
        }
    }

    cout << ans.size() << "\n";
    for (int i = 0; i < ans.size(); i++)
        cout << (ans[i].first ? 'B' : 'A') << ' ' << ans[i].second + 1 << "\n";
}
```

<br/>

## C. Min Diff Sum

[C번 문제 링크](https://atcoder.jp/contests/arc147/tasks/arc147_c)

$N$($2 \leq N \leq 3 \cdot 10^5$)명의 사람들이 있고, 각 사람들은 $1$부터 $N$의 번호가 매겨져 있다.

이 사람들을 수평선 위에 배치하는데, $i$번 사람의 위치를 $x_i$라고 하면 주어진 $L_i, R_i$에 대하여 $L_i \leq x_i \leq R_i$ 를 만족해야한다.

($1 \leq L_i \leq R_i \leq 10^7$)

어떤 배치의 불만족 정도를 아래와 같이 정의할 때, 불만족 정도의 최솟값을 구하여라.

\begin{aligned}
\sum_{i=1}^{N - 1} \sum_{j = i + 1}^N \left\vert x_j - x_i \right\vert
\end{aligned}

---

### [SOLUTION] 



```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <set>
#include <queue>
#include <deque>
#include <math.h>
#include <iterator>
using namespace std;
typedef long long ll;
const int MX = 1e9;
#define l first
#define r second

pair<int, int> x[300000];
pair<int, ll> solve(int M, int n) {
    vector<int> y;
    int left = 0, right = 0;
    for (int i = 0; i < n; i++) {
        if (x[i].l <= M && M <= x[i].r) y.push_back(M);
        else if (M < x[i].l) {
            y.push_back(x[i].l);
            right++;
        }
        else if (x[i].r < M) {
            y.push_back(x[i].r);
            left++;
        }
    }
    sort(y.begin(), y.end());

    ll sum = 0, ans = 0;
    for (int i = 1; i < (n + 1) / 2; i++) {
        sum += y[n - i] - y[i - 1];
        ans += sum * 2;
    }
    if (n % 2 == 0) ans += sum + y[n / 2] - y[n / 2 - 1];
    return { right - left, ans };
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int n, L = 1e7, R = 0; cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> x[i].l >> x[i].r;
        L = min(L, x[i].r);
        R = max(R, x[i].l);
    }
    if (L >= R) {
        cout << "0";
        return 0;
    }

    ll ans = 1e18;
    while (L < R) {
        int M = (L + R) / 2;
        auto res = solve(M, n);
        ans = min(ans, res.second);
        if (res.first < 0) R = M - 1;
        else L = M + 1;
    }
    cout << ans;
}
```







