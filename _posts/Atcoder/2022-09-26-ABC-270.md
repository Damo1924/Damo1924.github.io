---
title: "[AC #3] AtCoder Beginner Contest 270"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Coding Contest
use_math: true
comments: true

---

`Tags` DFS, DP, 

## Result & Review

이번 주에 ARC가 없어서 대신 ABC라도 참여했다.

지난 번에 어렵지 않게 5문제를 풀어서 6문제까지 노려볼만 하다고 생각했지만, 이번에도 5문제에 그쳤다.

E번을 60분 이전에 풀었는데 남은 40분 동안 한 문제도 풀지 못한게 너무 아쉬웠다.

레이팅은 200점 가량 오른 1120점이다.

<br/>

## A. 1-2-4 Test

[A번 문제 링크](https://atcoder.jp/contests/abc270/tasks/abc270_a)

세 문제로 이루어진 시험이 있고, 각각의 문제는 $1$점, $2$점, $4$점의 배점을 갖는다.

세 학생이 시험에 응시했고, 첫 번째 학생은 $A$점, 두 번째 학생은 $B$점을 받았다.

세 번째 학생은 두 학생 중 한 명이라도 푼 문제는 모두 풀었고, 두 학생이 모두 풀지 못한 문제는 모두 풀지 못했다.

이때 세 번째 학생의 점수를 구하여라.

---

### [SOLUTION] Math

두 학생의 점수들에 대하여 bitwise OR 연산을 해주면 답을 구할 수 있다.

```cpp
#include <iostream>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int a, b; cin >> a >> b;
    cout << (a | b);
}
```

<br/>

## B. Hammer

[B번 문제 링크](https://atcoder.jp/contests/abc270/tasks/abc270_b)

철수는 수평선의 원점에 위치해 있고, 목적지인 $X$로 움직이려고 한다.

위치 $Y$에는 벽이 있어서 망치가 있어야만 벽을 지나갈 수 있다.

망치의 위치는 $Z$로 주어진다.

이때 철수가 목적지에 도달할 수 있는지 구하고, 도달할 수 있다면 이동해야하는 최단 거리를 구하여라.

만약 목적지에 도달하는 것이 불가능하다면 $-1$을 출력한다.

---

### [SOLUTION] Math

가능한 경우의 수는 아무리 많아야 8가지이므로 각각에 대하여 답을 구해주면 된다는 것을 알 수 있다.

먼저, 목적지로 바로 갈 수 있기 위해서는

- $X$와 $Y$의 부호가 다르거나,
- $X$의 절댓값이 $Y$의 절댓값보다 작아야한다.

이제, 망치로 벽을 깨서 도달할 수 있는 경우를 처리해주자.

- $Y > 0$ 이면 $Z < Y$ 인 경우에만 망치를 얻을 수 있다.
- $Y < 0$ 이면 $Z > Y$ 인 경우에만 망치를 얻을 수 있다.

남은 경우들은 목적지로 가는 길이 벽으로 막혀 있고, 망치를 가지러 갈 수 없으므로 $-1$을 출력해준다.

```cpp
#include <iostream>
#include <math.h>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int x, y, z; cin >> x >> y >> z;
    if (x * y < 0 || abs(x) < abs(y)) cout << abs(x);
    else if (y > 0 && z < y) cout << abs(z) + x - z;
    else if (y < 0 && y < z) cout << abs(z) + z - x;
    else cout << "-1";
}
```

<br/>

## C. Simple path

[C번 문제 링크](https://atcoder.jp/contests/abc270/tasks/abc270_c)

$N$($1 \leq N \leq 2 \cdot 10^5$)개의 정점으로 이루어진 트리 $T$가 주어진다.

서로 다른 두 정점 $X, Y$가 주어질 때, $X$에서 $Y$로의 simple path에 있는 정점들을 순서대로 출력하여라.

---

### [SOLUTION] DFS

정점 $Y$에서 시작하여 DFS로 트리를 탐색하자.

탐색하면서 각 정점의 부모를 기억해둔 후 정점 $X$부터 부모를 따라가면 정점 $Y$에 도달하게 된다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

vector<int> g[200001];
int par[200001];
void dfs(int u) {
    for (int v : g[u]) if (!par[v]) {
        par[v] = u;
        dfs(v);
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int n, x, y; cin >> n >> x >> y;
    for (int i = 1; i < n; i++) {
        int u, v; cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    
    par[y] = -1;
    dfs(y);
    for (int i = x; i != -1; i = par[i]) cout << i << " ";
}
```

<br/>

## D. Stones

[D번 문제 링크](https://atcoder.jp/contests/abc270/tasks/abc270_d)

초기에 $N$($1 \leq N \leq 10^4$)개의 돌로 이루어진 돌 무더기가 있다.

Takahashi와 Aoki는 돌 무더기에서 번갈아가며 돌들을 가져가는 게임을 하려고 한다.

주어진 수열 $(A_1, A_2, \dots, A_K)$($1 \leq K \leq 100$)에 대하여, 두 사람은 자신의 차례에 수열에 포함되는 개수만큼의 돌들을 가져갈 수 있다.

이때 수열은 $1 = A_1 < A_2 < \dots < A_K \leq N$ 을 만족한다.

Takahashi부터 돌을 가져가며, 남아 있는 돌보다 많은 돌을 가져갈 수는 없다.

더 이상 남은 돌이 없으면 게임은 종료된다.

두 사람이 모두 최대한 많은 돌을 가져가는 쪽으로 게임을 플레이할 때, Takahashi가 가져가는 돌의 개수를 구하여라.

---

### [SOLUTION] DP

남은 돌의 개수가 $i$일 때 현재 차례인 사람이 가져가는 돌의 개수를 $dp_i$라고 정의하자.

이때 현재 차례인 사람이 $A_j$개만큼 가져간다면, 이후 추가로 가져가게 되는 돌의 개수는 $i - A_j - dp_{i - A_j}$ 이다.

따라서 아래와 같은 식이 성립함을 알 수 있다.

\begin{aligned}
dp_i = i - \max_{1 \leq j \leq K, A_j \leq i} dp_{i - A_j}
\end{aligned}

우리가 구하고자 하는 값은 $dp_N$이므로, $dp_1$부터 구해나가면 $O(NK)$가 걸린다.

$N$과 $K$의 제한 조건을 고려하면 충분히 시간 내에 해결이 가능하다는 것을 알 수 있다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int a[101], dp[10001];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int n, k; cin >> n >> k;
    for (int i = 1; i <= k; i++) cin >> a[i];

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= k; j++) {
            if (i < a[j]) break;
            dp[i] = max(dp[i], i - dp[i - a[j]]);
        }
    }
    cout << dp[n];
}
```

<br/>

## E. Apple Baskets on Circle

[E번 문제 링크](https://atcoder.jp/contests/abc270/tasks/abc270_e)

$1$부터 $N$($1 \leq N \leq 10^5$)까지의 번호가 매겨진 바구니들이 원을 따라 나열되어 있다.

모든 $1 \leq i \leq N - 1$ 에 대하여 $i+1$번 바구니는 $i$번 바구니의 바로 오른쪽에 위치하며, $1$번 바구니는 $N$번 바구니의 바로 오른쪽에 있다.

$i$번 바구니에는 $A_i$($0 \leq A_i \leq 10^{12}$)개의 사과가 들어 있다.

처음에 Takahashi는 1번 바구니의 앞에 서있고, 아래와 같은 작업을 수행한다.

- 앞에 있는 바구니에 사과가 있으면 하나를 먹는다.
- 사과를 먹었는지 여부과 관계없이 오른쪽 바구니로 이동한다.

Takahashi가 $K$($1 \leq K \leq 10^{12}$)개의 사과를 먹었을 때 몇 번 바구니 앞에 서있는지 구하여라.

이때 $K$는 모든 바구니에 있는 사과의 개수보다 작거나 같다.

---

### [SOLUTION] Math

한 바퀴를 순회할 때 먹게 되는 사과의 개수를 $K$에서 반복해서 빼주도록 하자.

현재까지 한 바구니에서 먹은 사과의 최대 개수를 $cnt$,

$A_i \geq cnt$ 를 만족하는 바구니의 개수를 $left$라고 정의하자.

이때 $cnt < A_i$ 를 만족하는 $A_i$의 최솟값을 $B$라고 하면,

$cnt$가 $B$가 될 때까지 바구니들을 순회하는 동안 먹는 사과의 개수는 $(B - cnt) \cdot left$ 개 이다.

만약 $K$가 위 값보다 크다면, $K$에서 위 값을 빼고 $cnt, left$를 업데이트해준다.

이 과정을 반복해주다 보면, $K$가 먹게 되는 사과의 개수보다 작거나 같아지게 된다.

사과가 남아있는 바구니가 $left$개이므로, 온전한 한 바퀴를 $\frac{K}{left}$번 돌 수 있다.

이제 $A_i > cnt$ 를 만족하는 $i$들을 $K\,\bmod\,left$ 개만큼 순서대로 방문해주며 $A_i$에서 $1$을 빼주면 된다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
typedef long long ll;

ll a[100000], b[100000];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int n; cin >> n;
    ll k; cin >> k;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
        b[i] = a[i];
    }
    sort(b, b + n);
    
    ll cnt = 0; // cnt: 한 바구니에서 먹은 사과의 최대 개수
    ll left = n; // left: 사과가 들어있는 바구니의 개수 (초기에 cnt개 이상의 사과가 들어있던 바구니의 개수)
    for (int i = 0; i < n; i++) {
        if ((b[i] - cnt) * left < k) {
            k -= (b[i] - cnt) * left;
            left--;
            cnt = b[i];
            while (i + 1 < n && b[i] == b[i + 1]) i++, left--;
        }
        else {
            cnt += k / left; // 온전한 한 바퀴를 돌 수 있는 횟수
            k %= left;
            for (int j = 0; j < n && k > 0; j++) if (a[j] > cnt) { // K가 0이 될 때까지 사과가 남아있는 바구니에서 사과를 먹는다.
                a[j]--;
                k--;
            }
            break;
        }
    }
    for (int i = 0; i < n; i++) cout << (a[i] > cnt ? a[i] - cnt : 0) << ' '; // 남은 사과의 개수를 출력
}
```

<br/>

## F. Transportation

[F번 문제 링크](https://atcoder.jp/contests/abc270/tasks/abc270_f)



---

### [SOLUTION] 


