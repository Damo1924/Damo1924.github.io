---
title: "Suffix Array & Longest Common Prefix(LCP)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Algorithm
use_math: true
comments: true

---

`Tags` Manber-Myers Algorithm, Counting sort, 

## 1. Suffix Array

LCP에 대해 알아보기 전에 **접미사 배열(suffix array)**가 무엇인지 살펴보도록 하자.

접미사 배열은 **문자열의 모든 접미사를 사전순으로 정렬한 배열**을 의미한다.

이때 부분문자열 자체를 저장하는 대신 각 접미사의 **시작 문자의 인덱스**를 배열에 저장한다.

예를 들어, 문자열 $s =$ABCBABDB의 모든 접미사를 순서대로 나타낸 후, 사전순으로 정렬하면 다음과 같다.

<center><img src="https://user-images.githubusercontent.com/88201512/152630099-3eef143e-adfd-4eec-8ba6-01eb6194489b.jpg" width="60%" height="60%"></center>

따라서 문자열 $s$의 접미사 배열은 `sa[8] = {0, 4, 7, 3, 1, 5, 2, 6}`가 된다.

<br/>

## 2. Manber-Myers Algorithm

길이가 $n$인 문자열의 접미사 배열을 구해보자.

접미사 배열을 단순히 정렬하면 접미사들끼리 비교하는데 $O(n)$의 시간복잡도가 걸린다.

$n$개의 접미사들을 정렬하는데 $O(n \log n)$이므로 전체 시간복잡도는 $O(n^2 \log n)$이다.

Manber-Myers 알고리즘은 **접미사 간의 대소 비교를** $O(1)$만에 하여 $O(n \log^2 n)$의 시간복잡도로 접미사 배열을 구하는 알고리즘이다.

---

### 2-1. Algorithm

Manber-Myers 알고리즘은 접미사들을 앞에서부터 $2^k$개의 문자들을 기준으로 정렬하는 과정을 반복한다.

그렇다면 앞에서부터 $2^k$개의 문자들을 기준으로 정렬하는 방법에 대해 알아보자.

앞에서부터 $2^k$개의 문자들은 두 개의 연속한 $2^{k-1}$개의 문자들로 나누어서 생각할 수 있다.

이전 단계에서 앞의 $2^{k-1}$개의 문자들에 대해서 정렬한 결과를 가지고 있다고 가정하자.

이제 뒤의 $2^{k-1}$개의 문자들에 대해서 정렬을 해주면 된다.

다음과 같은 사실을 이용하자.

> 뒤쪽의 $2^{k-1}$개의 문자들의 순서는 **해당 문자들로 시작하는 접미사의 순서**와 동일하다.

<center><img src="https://user-images.githubusercontent.com/88201512/152514269-8473ad08-63ee-46db-8c61-d142c19162ce.jpg" width="60%" height="60%"></center>

접미사들을 문자 하나하나 비교하는 것이 아니라 이미 알고있는 정보를 바탕으로 비교하는 것이기 때문에 $O(1)$에 문자열 비교가 가능한 것이다.

---

### 2-2. Implementation: $O(n \log^2 n)$

접미사들의 앞쪽 $2^k$개의 문자를 기준으로 정렬하는데 $O(n \log n)$, 이 과정을 총 $O(\log n)$번 반복하므로 전체 알고리즘의 시간복잡도는 $O(n \log^2 n)$이다.

문자열이 주어지면 접미사 배열을 반환하는 함수를 구현하기 위해 다음의 배열을 사용하였다.

- `sa[i]`(suffix array) : 접미사의 번호(= 시작 문자의 인덱스)를 저장
- `r[i]` (rank) : 접미사 i의 rank를 저장
- `nr[i]` (next rank) : 정렬 후 rank를 갱신

이때 `r`의 크기를 문자열의 길이의 2배로 정한 것은 `i + d`가 문자열의 길이보다 커질 수 있기 때문이다.

```cpp
vector<int> suffixArray(string& s)
{
    int n = s.size();
    vector<int> sa(n), r(2 * n, 0), nr(n, 0);
    for(int i = 0; i < n; i++)
    {
        sa[i] = i;
        r[i] = s[i]; // 첫 번째 단계에서는 ASCII값으로 rank를 지정
    }

    for(int d = 1; d < n; d *= 2) // d = 2^{k-1}
    {
        auto cmp = [&](int i, int j) { // lambda로 구현한 비교함수
            if (r[i] == r[j]) return r[i + d] < r[j + d]; // 앞쪽 d개의 문자가 동일하면 뒤쪽 문자열의 rank로 비교
            return r[i] < r[j];
        };
        
        sort(sa.begin(), sa.end(), cmp);
        
        nr[sa[0]] = 1; // 맨 앞 문자열의 rank를 1로 둔다.(빈 문자열이 0)
        for(int i = 0; i < n; i++) nr[sa[i]] = nr[sa[i - 1]] + cmp(sa[i - 1], sa[i]);
        for(int i = 0; i < n; i++) r[i] = nr[i];
    }
    return sa;
}
```

---

### 2-3. Implementation: $O(n \log n)$

**Counting sort**를 사용하면 정렬을 $O(n)$에 처리할 수 있기 때문에 전체 알고리즘의 시간복잡도를 $O(n \log n)$으로 줄일 수 있다.

> Counting sort에 대한 설명은 [이 포스트](https://damo1924.github.io/algorithm/Countingsort/)를 참고

```cpp
void countingSort(vector<int>& sa, vector<int>& r, int d)
{
    int n = sa.size(), m = max(256, n) + 1;
    vector<int> cnt(m), idx(n);
    
    for(int i = 0; i < m; i++) cnt[i] = 0;
    for(int i = 0; i < n; i++) cnt[r[i + d]]++;
    for(int i = 1; i < m; i++) cnt[i] += cnt[i - 1];
    for(int i = n - 1; i >= 0; i--) idx[--cnt[r[i + d]]] = i;
    
    for(int i = 0; i < m; i++) cnt[i] = 0;
    for(int i = 0; i < n; i++) cnt[r[i]]++;
    for(int i = 1; i < m; i++) cnt[i] += cnt[i - 1];
    for(int i = n - 1; i >= 0; i--) sa[--cnt[r[idx[i]]]] = idx[i];
}
```

- `idx[]` : i(0 ~ (n - 1))를 `r[i + d]`의 값에 대한 오름차순으로 정렬한 결과

`idx[]`를 통해 `r[i]`(rank)가 동일한 접미사들 중 `r[i + d]`가 더 큰 것이 마지막 반복문에서 먼저 처리된다.

이제 2-2에서 구현한 `suffixArray()` 함수의 `sort()`를 `countingSort()`으로 바꾸어준다.

```cpp
vector<int> suffixArray(string& s)
{
    int n = s.size();
    vector<int> sa(n), r(2 * n, 0), nr(n, 0);
    for(int i = 0; i < n; i++)
    {
        sa[i] = i;
        r[i] = s[i]; // 첫 번째 단계에서는 ASCII값으로 rank를 지정
    }

    for(int d = 1; d < n; d *= 2)
    {
        auto cmp = [&](int i, int j) {
            if (r[i] == r[j]) return r[i + d] < r[j + d];
            return r[i] < r[j];
        };
        
        countingSort(sa, r, d);
        
        nr[sa[0]] = 1;
        for(int i = 0; i < n; i++) nr[sa[i]] = nr[sa[i - 1]] + cmp(sa[i - 1], sa[i]);
        for(int i = 0; i < n; i++) r[i] = nr[i];
    }
    return sa;
}
```

<br/>

## 3. Longest Common Prefix












