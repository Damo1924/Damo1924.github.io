---
title: "Longest Common Prefix(LCP)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Algorithm
use_math: true
comments: true

---

`Tags` Suffix array, Manber-Myers Algorithm

## 1. Suffix Array

LCP에 대해 알아보기 전에 **접미사 배열(suffix array)**가 무엇인지 살펴보도록 하자.

접미사 배열은 **문자열의 모든 접미사를 사전순으로 정렬한 배열**을 의미한다.

이때 부분문자열 자체를 저장하는 대신 각 접미사의 **시작 문자의 인덱스**를 배열에 저장한다.

예를 들어, 문자열 $s =$ABCBABDB의 모든 접미사를 순서대로 나타내면 다음과 같다.

|i|suffix|
|:---:|---:|
|0|ABCBABDB|
|1|BCBABDB|
|2|CBABDB|
|3|BABDB|
|4|ABDB|
|5|BDB|
|6|DB|
|7|B|

이를 사전순으로 정렬하면 다음과 같다.

|i|suffix|
|:---:|---:|
|0|ABCBABDB|
|4|ABDB|
|7|B|
|3|BABDB|
|1|BCBABDB|
|5|BDB|
|2|CBABDB|
|6|DB|

따라서 문자열 $s$의 접미사 배열은 `sa[8] = {0, 4, 7, 3, 1, 5, 2, 6}`이다.

<br/>

## 2. Manber-Myers Algorithm

길이가 $n$인 문자열의 접미사 배열을 구해보자.

접미사 배열을 단순히 정렬하면 접미사들끼리 비교하는데 $O(n)$의 시간복잡도가 걸린다.

$n$개의 접미사들을 정렬하는데 $O(n \log n)$이므로 전체 시간복잡도는 $O(n^2 \log n)$이다.

Manber-Myers 알고리즘은 **접미사 간의 대소 비교를** $O(1)$만에 하여 $O(n \log^2 n)$의 시간복잡도로 접미사 배열을 구하는 알고리즘이다.

### 2-1. Algorithm

Manber-Myers 알고리즘은 접미사들을 앞에서부터 $2^k$개의 문자들을 기준으로 정렬하는 과정을 반복한다.

그렇다면 앞에서부터 $2^k$개의 문자들을 기준으로 정렬하는 방법에 대해 알아보자.

앞에서부터 $2^k$개의 문자들은 두 개의 연속한 $2^{k-1}$개의 문자들로 나누어서 생각할 수 있다.

이전 단계에서 앞의 $2^{k-1}$개의 문자들에 대해서 정렬한 결과를 가지고 있다고 가정하자.

이제 뒤의 $2^{k-1}$개의 문자들에 대해서 정렬을 해주면 된다.

다음과 같은 사실을 이용하자.

> 뒤쪽의 $2^{k-1}$개의 문자들의 순서는 **해당 문자들로 시작하는 접미사의 순서**와 동일하다.

<center><img src="https://user-images.githubusercontent.com/88201512/152514269-8473ad08-63ee-46db-8c61-d142c19162ce.jpg" width="70%" height="70%"></center>

위 그림과 같이 현재까지 정렬된 순서를 `r`(rank), 정렬된 부분을 제외한 문자열의 순서를 `nr`(next rank)라고 하면 `(r, nr)` 순서쌍을 정렬하면 된다.

접미사들을 문자 하나하나 비교하는 것이 아니라 이미 알고있는 정보를 바탕으로 비교하는 것이기 때문에 $O(1)$에 문자열 비교가 가능한 것이다.

---

### 2-2. Implementation: $O(n \log^2 n)$

접미사들의 앞쪽 $2^k$개의 문자를 기준으로 정렬하는데 $O(n \log n)$, 이 과정을 총 $O(\log n)$번 반복하므로 전체 알고리즘의 시간복잡도는 $O(n \log^2 n)$이다.

```cpp

```

---

### 2-3. Implementation: $O(n \log n)$














