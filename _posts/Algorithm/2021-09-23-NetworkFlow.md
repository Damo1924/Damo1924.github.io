---
title: "최대 유량(Maximum Flow) 문제"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Algorithm
use_math: true
comments: true

---

## 1. Maximum Flow Problem

최대 유량(Maximum Flow) 문제는 그래프의 두 지점 사이를 지날 수 있는 최대 유량을 구하는 문제이다.

총 세 개의 노드 A, B, C로 이루어진 그래프가 있다.

이때 A와 B 사이의 간선은 최대 10만큼의 유량이 통과할 수 있고, B와 C 사이의 간선은 최대 5만큼의 유량이 통과할 수 있으며, A와 C는 연결되어 있지 않다.

그렇다면 A에서 C로 흐를 수 있는 최대 유량을 얼마일까?

어렵지 않게 5라고 답할 수 있다.

이처럼 그래프의 각 간선이 통과할 수 있는 최대 유량을 가질 때, 어떤 시작 지점부터 도착 지점까지 흐를 수 있는 최대 유량을 구하는 문제를 최대 유량 문제라고 한다.

다음은 최대 유량 문제에서 사용하는 용어들이다.

- **유량 네트워크(Flow network)**: 각 간선에 용량이 주어진 그래프
- **소스(source)**: 시작 지점
- **싱크(sink)**: 도착 지점
- **용량(capacity)**: 각 간선에 대해서 흐를 수 있는 최대 유량

이때 **유량(flow)**이란, 다음 조건을 만족하는 값을 의미한다.

- **용량의 제한(capacity constraint)**: 유량은 그 간선의 용량을 초과할 수 없다.
- **유량의 보존(conservation of flows)**: 소스와 싱크를 제외한 정점에는 들어오는 유량와 나가는 유량이 동일하다.

그렇다면, 이를 해결할 수 있는 알고리즘에 대해 알아보자.


<br/>
## 2. Ford-Fulkerson Algorithm

포드-풀커슨 알고리즘은 다음과 같다.

1) 소스에서 싱크까지 모든 간선의 용량이 0보다 큰 경로를 구한다.

> 이러한 경로를 **증가 경로**라고 부른다.

2) 위에서 찾은 경로를 지날 수 있는 최대 용량(f)을 구한다.

3) 해당 간선들을 지나는 유량에 f를 더한다.

4) 해당 간선들의 반대 방향 간선들을 지나는 유량에 f를 뺀다.

5) 위 과정(1 ~ 4)를 더 이상 증가 경로가 존재하지 않을 때까지 반복한다.

문제는, 이 알고리즘은 증가 경로를 찾는 방법에 대해 제시하지 않았다는 점이다.

그러므로 대표적인 그래프 탐색 방법인 DFS 또는 BFS를 통해 증가 경로를 찾으면 되는데, 어느 방법이든 $O(f \cdot E)$의 시간 복잡도를 갖는다.

이때 $f$는 유량의 총 크기이다.

그런데 증가 경로를 BFS로 찾는 경우, 시간 복잡도가 $O(VE^2)$임이 증명되었고, 따라서 최대 유량 문제를 풀 때는 BFS를 사용하면 된다.

BFS를 사용하는 알고리즘을 Edmonds-Karp Algorithm이라고 부른다.


<br/>
## 3. Edmonds-Karp Algorithm & Implementation

에드몬드-카프 알고리즘은 포드-풀커슨 알고리즘에서 증가 경로를 찾는 방법만을 제시한 것이므로 알고리즘 자체는 동일하다.

다만, 이번에는 코드를 구현하는 관점에서 알고리즘을 정리해보았다.

1) BFS를 통해 시작 지점에서 도착 지점까지 이어지는 경로를 하나 찾고, 배열을 하나 선언하여 경로를 저장한다.

2) 위에서 찾은 경로를 따라가면서 해당 경로로 지나갈 수 있는 최대 유량을 구한다.

3) 경로를 따라가면서 각 간선을 통과하는 유량에 앞에서 구한 값을 더해준다. 이때, 각 간선의 반대 방향으로 음의 유량이 지난다고 생각할 수 있으므로 각 간선의 반대 방향 유량에 앞에서 구한 값을 빼준다.

> 예를 들어 A에서 B로 가는 간선에 10만큼의 유량이 흐른다면 B에서 A로 가는 유량은 -10이라고 할 수 있다.
>
> 이를 고려해주어야 하는 이유는 B에서 A로 가는 경로가 존재할 수 있기 때문이다.
>
> B에서 A 방향으로 가는 경로를 발견했을 때, 해당 간선을 통과할 수 있는 최대 유량은 10 - 0 = 10이 아니라 10 - (-10) = 20이다.
>
> 즉, A에서 B로 가는 유량 10, B에서 A로 가는 유량 20을 더하면 B에서 A로 10만큼의 유량이 흐르는 것이므로 용량을 초과하지 않으면서 두 경로를 최대한으로 이용할 수 있게 된다.

4) 결과값에 위에서 구한 유량을 더해준다.

5) 위 과정(1 ~ 4)를 더 이상 시작 지점에서 끝 지점으로 가는 새로운 경로가 없을 때까지 반복한다.

이를 코드로 구현해보면 다음과 같이 나타낼 수 있다.

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;

#define Max = 100;
#define Inf = 1000000000;

int n, maxFlow;

int p[Max]; // path
int c[Max][Max]; // capacity
int f[Max][Max]; // flow

vector<int> g[Max]; // graph

void maxFlow (int start, int end)
{
    while (1)
    {
        fill(p, p + Max, -1); // 경로를 -1로 초기화
        
        queue<int> q;
        q.push(start);
        while (!q.empty())
        {
            int x = q.front();
            q.pop();
            for (int i = 0; i < g[x].size(); i++)
            {
                int y = g[x][i];
            
                // 방문하지 않은 노드 중 용량이 남은 경우
                if (c[x][y] - f[x][y] > 0 && p[y] == -1)
                {
                    q.push(y);
                    p[y] = x; // 경로 저장
                    if (y == end) break; // 도착 지점에 도달
                }
            }
        }
        
        if (p[end] == -1) break; // 더 이상 도착 지점에 도달하는 경로가 없는 경우
        
        int flow = Inf; // 찾은 경로를 지나는 최대 유량
        for (int i = end; i != start; i = p[i])
            flow = min(flow, c[p[i]][i] - f[p[i]][i]);
        
        for (int i = end; i != start; i = p[i])
        {
            f[p[i]][i] += flow;
            f[i][p[i]] -= flow;
        }
        maxFlow += flow;
    }
}
```

앞에서 언급했듯이, 에드몬드-카프 알고리즘의 시간복잡도는 $O(VE^2)$으로 알려져 있다.

BFS를 이용해서 소스에서 싱크까지의 경로를 찾는데 $O(E)$이므로 위 사실을 증명하기 위해서는 증가 경로를 많아야 $VE$번 찾는다는 사실을 보이면 된다.

어떤 그래프의 최단 경로의 길이를 $D$라고 하자.

최단 경로를 하나 탐색하면 적어도 하나의 간선은 해당 간선의 유량이 용량과 같아지게 되며, 더 이상 최단 경로가 $D$인 경로 중에는 해당 간선을 통과하는 경로가 존재하지 않게 된다.

만약 길이가 $D$이면서 해당 간선의 반대 방향으로 지나는 경로가 존재한다고 가정하면, $D-1$인 경로가 존재하게 되어 최단 경로가 $D$라는 전제에 모순이다.

그러므로 최단 경로의 길이가 $D$인 동안은 최대 $E$번 증가 경로를 찾게 된다.

최단 경로의 길이는 1부터 $V$까지 가능하므로 위의 과정이 최대 $VE$번 반복된다.

따라서 에드몬드-카프 알고리즘의 시간복잡도는 $O(VE^2)$이다.


<br/>
## 4. 
