---
title: "유니온 파인드 (Union - Find)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:    
  - Algorithm
use_math: true
comments: true

---

## 1. Union-Find Algorithm

유니온 파인드 알고리즘은 그래프 알고리즘의 일종으로, **두 노드가 같은 그래프에 속하는지 판별하는 알고리즘**이다.

노드를 합치는 **Union** 연산과 노드가 속한 트리의 루트 노드를 찾는 **Find** 연산으로 이루어진다.

노드를 트리 구조로 합치기 때문에 트리 구조로 이루어진 자료구조라고 할 수 있으며, **서로소 집합** 또는 **상호 베타적 집합(Disjoint-Set)**으로 불리기도 한다.

예를 들어 1, 2, 3, 4 노드를 하나로 묶고 싶다면 다음과 같이 배열을 이용해 연결해준다.

> `parent[2] = 1`, `parent[3] = 2`, `parent[4] = 3`

이 상황에서 어떤 두 노드가 연결되어 있는지 알고 싶다면 **두 노드가 속한 트리 구조의 루트 노드가 같은지 비교**하면 된다.

루트 노드가 같으면 연결되어 있는 것이고, 같지 않다면 연결되어 있지 않은 것을 의미한다.

그런데 위 방법처럼 연결하면 `1-2-3-4`와 같이 높이가 큰 트리 구조가 만들어지게 된다.

루트 노드를 찾는데 레벨에 비례하는 시간이 걸리기 때문에 위와 같은 트리 구조는 비효율적이다.

이를 해결하기 위해 노드를 연결하는 Union 연산을 할 때는 **연결하고자 하는 두 노드의 루트 노드들을 서로 연결**해준다.

<br/>

## 2. Union-Find Implementation

C++를 통해 유니온 파인드를 구현해보자.

이때 `parent[i]`는 노드 i의 부모 노드를 저장하는 배열을 의미한다.

위 배열의 초기 상태는 자기 자신을 가리키도록 `parent[i] = i`와 같이 설정해준다.

### 2-1. 루트 노드 찾는 함수: find

어떤 노드를 입력받아 해당 노드가 속한 트리의 루트 노드를 찾아 반환하는 함수를 구현해보자.

```cpp
int find (int x)
{
    if (parent[x] == x) return x; // 루트 노드를 발견하면 반환
    return find(parent[x]); // 루트 노드가 아니면 부모 노드를 재귀적으로 탐색
}
```

하지만 트리가 한쪽으로 치우쳐진 경우, 검색 효율이 떨어지기 때문에 루트 노드를 찾아 `parent[x]`의 값을 루트 노드로 바꾸어줌으로써 효율을 개선할 수 있다.

```cpp
int find (int x)
{
    if (parent[x] == x) return x; // 루트 노드를 발견하면 반환
    return parent[x] = find(parent[x]); // 루트 노드를 찾아 부모 노드를 루트 노드로 만들어준다.
}
```

### 2-2. 노드를 합치는 함수: union

두 노드를 연결하는 함수를 구현해보자.

```cpp
void union (int x, int y)
{
    x = find(x);
    y = find(y);
    if (x == y) return;
    parent[y] = x;
}
```

두 노드를 연결하는 방법은 각 노드가 속한 트리의 루트 노드를 찾아 루트 노드를 연결해주는 것이다.

### 2-3. 두 노드가 연결되어 있는지 판별하는 함수: isUnion

```cpp
bool isUnion (int x, int y)
{
    x = find(x);
    y = find(y);
    if (x == y) return true;
    return false;
}
```

<br/>

## 3. 

하지만 단순히 `x`를 합친 트리의 루트 노드로 해버리면, 높이가 높은 트리가 높이가 낮은 트리 밑으로 들어갈 수 있는데, 이로 인해 트리의 높이가 계속 커질 수 있다.










