---

title: "트리 Tree"

toc: true

toc_label: "On this page"

toc_icon: "chevron-right"

categories:

  - Algorithm

use_math: true

comments: true

---

## 1. Tree structure

트리(tree)는 그래프의 일종으로, **노드(node)**와 **가지(edge)**로 구성된다.

트리는 여러 노드가 한 노드를 가리킬 수 없고, 회로가 없으며, 서로 다른 두 노드를 있는 가지가 하나뿐이라는 특징을 갖고 있다.

다음은 트리 구조에서 알아두어야 할 용어들이다.

---

노드 A가 노드 B를 가리킬 때 A를 B의 **부모 노드(parent node)**, B를 A의 **자식 노드(child node)**라고 한다.

> 하나의 노드가 가질 수 있는 자식 노드의 수에는 제한이 없지만, 부모 노드는 하나뿐이다.
> 
> 이때 각 노드가 갖는 자식의 수를 **차수(degree)**, 모든 노드의 차수가 n 이하인 트리를 **n진 트리**라고 한다.

부모 노드가 같은 노드를 **형제(sibling)**라고 한다.

어떤 노드에서 위쪽으로 가지를 따라가면서 만나는 모든 노드를 **조상(ancestor)**, 아래쪽으로 가지를 따라가면서 만나는 모든 노드를 **자손(descendant)**이라고 한다.

트리에서 가장 위쪽에 있는 노드를 **루트 노드(root node)**라고 하며, 루트 노드는 부모 노드가 없다.

자식 노드가 없는 노드를 **잎 노드(leaf node)**, 잎 노드가 아닌 노드를 **내부 노드(internal node)**라고 한다.

---

어떤 노드가 루트 노드에서 얼마나 멀리 떨어져 있는지 나타낸 숫자를 **레벨(level)**이라고 한다.

이때 **루트 노드의 레벨은 0**이며 가지를 따라 아래로 내려갈수록 1씩 증가한다.

루트 노드에서 가장 멀리 있는 리프 노드까지의 거리(=레벨의 최댓값)을 트리의 **높이(height)**라고 한다.

---

어떤 노드를 루트 노드로 하고, 그 자손으로 구성된 트리를 전체 트리의 **서브 트리(subtree)**라고 한다.

**빈 트리(none tree, null tree)**는 노드와 가지가 없는 트리이다.

형제 노드의 순서 관계가 있는 트리를 **순서 트리(ordered tree)**, 순서 관계가 없는 트리를 **무순서 트리(unordered tree)**라고 한다.

---

<br/>

## 2. 순서 트리의 탐색

트리를 탐색하는 방법은 크게 두 가지로 나뉘어진다.

### 2-1. 너비 우선 탐색 (Breadth First Search, BFS)

트리에서 너비 우선 탐색이란 낮은 레벨부터 왼쪽에서 오른쪽으로 탐색하고, 한 레벨에서 탐색을 모두 마치면 다음 레벨로 내려가는 방법이다.

### 2-2. 깊이 우선 탐색 (Depth First Search, DFS)

깊이 우선 탐색은 리프에 도달할 때까지 아래쪽으로 내려가면서 탐색하고, 리프에 도달해서 더 이상 탐색할 노드가 없으면 부모 노드로 돌아간 후, 탐색하지 않았던 자식 노드로 내려가는 방법이다.

깊이 우선 탐색은 **어느 시점에 실제로 노드를 방문하는지에 따라** 세 종류로 구분한다.

1. **전위 순회(preorder)**: 노드 - 왼쪽 자식 노드 - 오른쪽 자식 노드 (**N**LR)
2. **중위 순회(inorder)**: 왼쪽 자식 노드 - 노드 - 오른쪽 자식 노드 (L**N**R)
3. **후위 순회(postorder)**: 왼쪽 자식 노드 - 오른쪽 자식 노드 - 노드 (LR**N**)

---

<br/>

## 3. 완전 이진 트리 & 이진 검색 트리

이진 트리란 모든 노드의 자식 노드의 수가 2 이하인 트리를 말한다.

대표적인 이진 트리의 분류인 완전 이진 트리와 이진 검색 트리에 대해 알아보자.

---

### 3-1. 완전 이진 트리 (Complete Binary Tree)

다음과 같은 조건을 만족하도록 노드가 채워져 있는 이진 트리를 완전 이진 트리라고 한다.

1. 마지막 레벨을 제외하고 모든 레벨에 노드가 가득 차 있다.
2. 마지막 레벨은 왼쪽부터 오른쪽으로 노드를 채우되 반드시 끝까지 채우지 않아도 되다.

높이가 $h$인 완전 이진 트리가 가질 수 있는 최대 노드의 수는 $2^{h+1} - 1$이다.

$n$개의 노드로 구성된 완전 이진 트리의 높이는 $\log n$이다.

---

### 3-2. 이진 검색 트리 (Binary Search Tree)

모든 노드가 다음 조건을 만족하는 이진 트리를 이진 검색 트리라고 한다.

1. 노드의 왼쪽 서브트리에 있는 노드들의 값은 자신보다 작아야 한다.
2. 노드의 오른쪽 서브트리에 있는 노드들의 값은 자신보다 커야 한다.

위 조건에 의해 이진 검색 트리에는 **값이 동일한 노드는 존재하지 않는다**.

이진 검색 트리는 다양한 알고리즘에서 자주 사용되는데, 이는 다음과 같은 특징들을 갖고 있기 때문이다.

- 구조가 단순하다.
- 중위 순회(inorder, LNR)를 통해 **노드들의 값을 오름차순으로 얻을 수 있다**.
- 이진 검색(binary search)과 비슷한 방식으로 **아주 빠르게 값을 검색**할 수 있다.
- 노드를 비교적 쉽게 삽입할 수 있다.

---

### 3-3. 균형 검색 트리 (Self-Balancing Search Tree)

이진 검색 트리는 오름차순으로 노드가 삽입되면 트리의 높이가 커진다는 단점이 있다.

예를 들어 비어 있는 이진 검색 트리에 1, 2, 3, 4, 5 순으로 노드를 삽입하면 직선 모양의 트리가 된다.

이는 마치 선형 리스트와 같은 구조를 가지고 있기 때문에 검색이 비효율적으로 변한다.

이를 해결하기 위해 트리의 높이를 $O(\log n)$으로 제한되도록 고안된 검색 트리를 **균형 검색 트리**라고 한다.

- 이진 트리 중 균형 검색 트리: **AVL tree**, **Red-Black tree**
- 이진 트리가 아닌 균형 검색 트리: **B tree**, **2-3 tree**

(Red-Black tree에 대한 자세한 설명은 [이 포스트](https://damo1924.github.io/algorithm/RedBlackTree)에서 볼 수 있다.)

---

<br/>

## References

[1] [위키백과, '트리 구조'](https://ko.m.wikipedia.org/wiki/%ED%8A%B8%EB%A6%AC_%EA%B5%AC%EC%A1%B0)  
[2] [Geeksforgeeks, 'Introduction to Tree Data Structure'](https://www.geeksforgeeks.org/introduction-to-tree-data-structure/)
