---
title: "동적계획법에서의 볼록껍질 최적화 (Convex Hull Trick, CHT)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:    
  - Algorithm
use_math: true
comments: true

---

`Tags` DP, 

## 1. Idea of the Convex Hull Trick

다음과 같은 점화식이 주어졌을 때, 이를 일반적으로 구하면 $O(n^2)$의 시간복잡도를 갖게 된다.

\begin{aligned}
DP_i = \min_{j < i} \left( DP_j + A_i \cdot B_j \right)
\end{aligned}

위 점화식은 다음과 같이 바꾸어서 생각할 수 있다.

- $DP_i$는 $j < i$ 를 만족한는 $j$에 대한 직선 $y = B_j x + DP_j$ 들의 $x = A_i$ 에서의 최솟값이다.

이때 **$B_j$가 $j$에 대하여 감소**한다는 조건을 추가하면, 다음과 같은 그래프를 그릴 수 있다.

<center><img src="" width="60%" height="60%"></center>

$DP_i$를 구하기 위해 필요한 것은 지금까지 구한 $DP_j$들에 대응되는 직선들의 가장 아랫부분들을 이은 빨간색 그래프이다.

> 모양이 볼록 껍질과 비슷하기 때문에 Convex Hull이라는 이름이 붙게 되었다.

따라서 각 직선이 어느 구간에서 최솟값을 가지는지 저장해둔다면, $A_i$가 속하는 구간을 이분탐색으로 찾음으로써 빠르게 $DP_i$를 구할 수 있게 되는 것이다.

이분탐색으로 원하는 직선을 찾고, 최솟값을 구하는 과정의 시간복잡도는 $O(\log n)$ 이므로, 직선을 효율적으로 관리할 수 있다면 시간복잡도를 개선할 수 있을 것이다.

<br/>

## 2. How to deal with a New Line

$DP_i$를 구하고 나면, 직선 $y = B_i x + DP_i$ 가 어떤 구간에서 최솟값을 갖는지 구해야한다.

$B_j$가 $j$에 대하여 감소하기 때문에 위 직선이 마지막 구간 $\[x_i, \infty)$ 을 차지하게 될 것이다.

따라서 뒤에서부터 기존에 저장된 직선들과의 교점을 구해보면서 적절한 $x_i$를 찾아보면 된다.

맨 뒤에 있는 직선 $y = B_j x + DP_j$ 이 $x$좌표가 $x_j$ 이상인 구간에서 최솟값에 해당한다고 하면, 두 직선의 교점의 $x$좌표는

\begin{aligned}
x_{ji} = \frac{DP_i + DP_j}{B_j - B_i}
\end{aligned}

만약 $x_{ji} > x_j$ 이면, 직선 $y = B_j x + DP_j$이 최솟값인 구간도 존재하므로 그대로 새로운 직선을 추가해주면 되고, 이때 $x_i = x_{ji}$ 가 된다.

반대로 $x_{ji} \leq x_j$ 이면 직선 $y = B_j x + DP_j$이 최솟값이 되는 구간이 없어진다.

이 경우 해당 직선을 제거하고, 다시 마지막 직선과 교점을 구해 $x_i$를 구하는 과정을 반복해준다.

이 과정을 수행하기 위해 직선에 대해 알아야하는 정보는 해당 직선의 기울기와 $y$절편, 그리고 최솟값에 해당하는 구간의 시작 $x$좌표인 $x_i$이다.

<br/>

## 3. Time Complexity

직선들을 벡터에 저장해둔다고 하면 각 직선을 한 번씩 벡터에 삽입하고, 최대 한 번씩 벡터에서 제거하기 때문에 $DP_n$까지 구하는데 $O(n)$의 시간복잡도를 갖는다.

앞서 말했듯이 $x = A_i$ 가 속하는 구간을 찾을 때마다 $O(\log n)$이 걸리기 때문에 전체 시간복잡도는 $O(n \log n)$ 임을 알 수 있다.

이때 **$A_i$가 $i$에 대하여 증가**한다는 조건을 추가하면 모든 직선을 저장할 필요 없이 구간이 $A_i$보다 작다면 제거해버리면 되기 때문에 시간복잡도가 $O(n)$이 된다.

직선들을 앞과 뒤에서 제거할 수 있어야하기 때문에 덱(deque)을 이용하면 쉽게 구현할 수 있다.

<br/>

## 4. Implementation










