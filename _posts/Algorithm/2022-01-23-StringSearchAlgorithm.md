---
title: "KMP Algorithm"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Algorithm
use_math: true
comments: true

---

`Tags` 문자열 검색 알고리즘

## 0. String Searching Algorithm

문자열 검색 알고리즘은 **어떤 문자열 안에 다른 문자열이 포함되어 있는지 탐색**하고, 만약 포함되어 있다면 그 위치까지 찾는 알고리즘이다.

이때 검색되는 쪽의 문자열을 **텍스트(text)**, 찾고자 하는 문자열을 **패턴(pattern)**이라고 한다.

즉, 문자열 탐색 알고리즘은 텍스트에서 패턴을 찾아내는 것이라고 할 수 있다.

가장 단순한 방법은 아래와 같이 브루트 포스(brute force)법으로 검색을 하는 것이다.

<center><img src="https://user-images.githubusercontent.com/88201512/150712279-9144c34e-fdb6-4f95-978e-920b2e141e2d.jpg" width="60%" height="60%"></center>

그림의 `i`와 `j`는 비교하고 있는 텍스트와 패턴의 인덱스를 의미한다.

텍스트의 길이를 $N$, 패턴의 길이를 $M$이라고 하면, 시간복잡도는 $O(NM)$이다.

이번 포스팅에서는 좀 더 효율적으로 문자열을 검색할 수 있는 알고리즘들에 대해 다루어 볼 것이다.

<br/>

## 1. KMP Algorithm

KMP 알고리즘은 텍스트와 패턴의 겹치는 문자열을 이용해서 불필요한 탐색을 줄이는 알고리즘이다.

> KMP는 이를 고안한 D. E. Knuth, J. H. Morris, V. R. Pratt의 이름에서 따온 것이다.

### 1-1. IDEA

아래 예시를 보자.

<center><img src="https://user-images.githubusercontent.com/88201512/150723218-2dc3c693-cf7f-45eb-bd52-e5159d332f02.jpg" width="60%" height="60%"></center>

브루트 포스법에서는 탐색에 실패하면 패턴의 첫 번째 글자부터 다시 비교하였었다.

그러나 KMP 알고리즘은 지금까지 탐색한 패턴(ABCA)의 앞과 뒤에 겹치는 부분(A)가 있다는 정보를 토대로, 불필요한 중간 단계를 건너뛰고 탐색을 진행한다.

텍스트의 네 번째 글자 A부터 시작하는 문자열과 패턴을 비교해야하는데, 이미 첫 번째 글자인 A가 겹친다는 사실을 알고 있으므로 그 다음 글자부터 탐색하면 된다.

다른 예시를 보자.

<center><img src="https://user-images.githubusercontent.com/88201512/150717491-13de56f9-4274-4b1b-bd70-a98dc3a3716f.jpg" width="60%" height="60%"></center>

이번에는 지금까지 탐색한 패턴(AB)의 앞과 뒤에 겹치는 부분이 없으므로 패턴의 첫 번째 글자부터 탐색해야한다.

그 대신, 텍스트의 두 번째 글자(B)부터 시작하는 문자열(BCA)과 세 번째 글자 (C)부터 시작하는 문자열(CAB)에 대해서는 굳이 탐색할 필요가 없다.

그러므로 텍스트의 다음 글자인 A와 패턴의 첫 번째 글자부터 비교를 이어나가면 된다.

---

### 1-2. Algorithm

위 내용을 명료하게 정리하기 위해서 다음과 같은 용어들을 사용할 것이다.

> **접두사(prefix)** & **접미사(suffix)**
> 
> `ABC`의 접두사는 `A`, `AB`, `ABC`이고 접미사는 `C`, `BC`, `ABC`이다.

탐색한 패턴의 앞과 뒤에 겹치는 부분에 대한 정보를 저장하는 배열 `pi`를 정의하자.

> `pi[j]` = 패턴에서 인덱스 0~j에 해당하는 부분 문자열에 대해 다음 조건을 만족하는 접두사 중 가장 긴 것의 길이
> 
> - **접두사와 접미사가 동일**
> - **접두사가 해당 부분 문자열과 동일하지 않다.**

이 배열을 이용하면 탐색 과정에서 다른 부분이 발견되었을 때, **패턴의 몇 번째 글자부터 다시 탐색해야 하는지**를 바로 알 수 있게 된다.

KMP 알고리즘은 다음과 같다.

**1.** 비교할 텍스트의 인덱스를 `i`, 패턴의 인덱스를 `j`라고 하자.  
**2.** `i`를 1씩 증가시키면서 다음 과정을 반복한다.  
  **2-1.** `text[i] == pattern[j]`이면 `j++`  
  **2-2.** `text[i] != pattern[j]`이면 `j = pi[j - 1]`로 바꾸고 2-1로 돌아간다.
  
즉, `pi`배열을 구했다면 $O(N)$의 시간복잡도로 탐색이 가능하다는 것을 알 수 있다.

재미있는 점은 위 과정과 비슷하게 `pi`배열마저 $O(M)$으로 구할 수 있다는 것이다.

**1.** 비교할 패턴의 인덱스를 `i`, 접두사의 바로 다음 글자에 해당하는 인덱스를 `j`라고 하자.  
**2.** `i`를 1씩 증가시키면서 다음 과정을 반복한다.  
  **2-1.** `j == 0`이면 `pi[i] = 0`  
  **2-2.** `pattern[i] == pattern[j]`이면 `pi[i] = ++j`  
  **2-3.** `pattern[i] != pattern[j]`이면 `j = pi[j - 1]`으로 바꾸고 2-1로 돌아간다.
  
따라서 전체 알고리즘의 시간복잡도는 $O(N + M)$이다.
  
---

### 1-3. Implementation

이제 직접 KMP 알고리즘을 구현해보도록 하자.

[백준 1786. 찾기 문제 링크](https://www.acmicpc.net/problem/1786)

길이가 1 이상 100만 이하인 두 문자열 T, P가 주어질 때 P가 T의 몇 번째 글자에 나타나는지 구하는 문제이다.

`pi`배열을 구하는 `getPi()` 함수와 겹치는 부분을 구하는 `KMP()` 함수를 구현하여 해결하였다.

```cpp

```



## Reference





