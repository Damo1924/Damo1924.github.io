---
title: "Trie"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Algorithm
use_math: true
comments: true

---

`Tags` 문자열 검색 알고리즘, 트라이 자료구조, 

## 1. What is Trie?

트라이(trie)는 주어진 집합의 원소들을 키(key)로 갖는 탐색 트리의 일종이다.

대부분 키는 문자열(string)이며, **문자열을 저장하고 효율적으로 탐색**하기 위해 사용된다.

> **자동완성 기능**이나 **사전 검색** 등에서 사용된다.

가장 대표적인 탐색 트리인 이진 탐색 트리와의 가장 큰 차이점은 **키가 자료 구조 전체에 분산되어 있다**는 점이다.

이해를 돕기 위해 아래 그림을 보자.

<center><img src="https://user-images.githubusercontent.com/88201512/150998998-53ab16ac-15c2-403d-9450-ce72e9582292.jpg" width="60%" height="60%"></center>

어떤 노드의 모든 자손은 **해당 노드에 할당된 문자열**을 **공통된 접두사**로 갖는다는 것을 알 수 있다.

즉, 키에 특정 노드에 대응된다기보다는 **키의 일부(문자 또는 문자열)가 노드에 대응**된다고 할 수 있다.

만약 어떤 키에 접근하고 싶다면, 트라이를 **DFS**로 탐색하면 된다.

> 반드시 키가 문자열이어야 하는 것은 아니며, **순열(permutations)**과 같이 같은 원리를 적용할 수 있다면 키로 사용이 가능하다.
> 
> 특히 **정수**나 **메모리 주소** 같이 **고정 길이 이진 자료(fixed-length binary data)**를 표현하는 각각의 비트로 구성된 트라이를 **비트 트라이(bitwise trie)**라고 부른다.

<br/>

## 2. 트라이의 장단점

트라이의 장점은 **빠르게 문자열 검색을 수행**할 수 있다는 점이다.

문자열의 길이를 $m$이라고 하면, 검색/삽입/삭제 모두 $O(m)$의 시간복잡도로 수행할 수 있다.

이진 검색 트리로 문자열을 검색하기 위해서는 $O(m \log n)$의 시간복잡도가 필요하다는 것을 생각하면, 훨씬 효율적이라는 것을 알 수 있다.

하지만 그만큼 **메모리를 많이 사용**한다는 단점이 존재한다.

문자열을 이루는 문자가 모두 영소문자라고 해도 자식 노드를 가리키는 26개의 포인터가 필요하다.

이러한 문제를 해결하기 위해 **맵(map)**이나 **벡터(vector)**를 사용해서 구현하기도 한다.

<br/>

## 3. Implementation

트라이를 구성하는 노드는 다음과 같다.

```cpp
struct Trie {
    bool isTerminal;
    Trie* child[26];
    
    Trie() { // 생성자
        isTerminal = false;
        for (int i = 0; i < 26; i++) child[i] = NULL;
    }
    
    ~Trie() { // 소멸자
        for (int i = 0; i < 26; i++)
            if (child[i]) delete child[i];
    }
}
```

- `isTerminal`: 문자열의 끝부분이면 true, 아니면 false
- `child[]`: 자식 노드

만약 문자열 키를 통해서 연결된 값을 얻으려고 할 때에는 해당되는 타입의 멤버변수 `value`를 추가하면 된다.

지금 구현하는 것은 단순히 문자열 검색을 위한 트라이이므로 사용하지 않았다.

새로운 문자열을 삽입하는 `insert()` 멤버함수를 구현해보자.

```cpp
    void insert(const char* s) {
        if (!*s) {
            this->isTerminal = true;
            return;
        }
        int idx = *s - 'a';
        if (!child[idx]) child[idx] = new Trie;
        child[idx]->insert(s + 1);
    }
```

다음은 저장된 문자열을 검색하는 `find()` 멤버함수이다.

```cpp
    bool find(const char* s) {
        if (!*s) {
            if (isTerminal) return true;
            return false;
        }
        int idx = *s - 'a';
        if (!child[idx]) return false;
        return child[idx]->find(s + 1);
    }
```

전체 코드는 다음과 같다.

```cpp
struct Trie {
    bool isTerminal;
    Trie* child[26];
    
    Trie() {
        isTerminal = false;
        for (int i = 0; i < 26; i++) child[i] = NULL;
    }
    
    ~Trie() {
        for (int i = 0; i < 26; i++)
            if (child[i]) delete child[i];
    }
    
    void insert(const char* s) {
        if (!*s) {
            this->isTerminal = true;
            return;
        }
        int idx = *s - 'a';
        if (!child[idx]) child[idx] = new Trie;
        child[idx]->insert(s + 1);
    }
    
    bool find(const char* s) {
        if (!*s) {
            if (isTerminal) return true;
            return false;
        }
        int idx = *s - 'a';
        if (!child[idx]) return false;
        return child[idx]->find(s + 1);
    }
};
```

<br/>

## 4. 관련 문제

트라이를 이용해서 해결할 수 있는 문제들을 풀어보자.

### [백준] 14725. 개미굴

개미굴을 DFS로 탐색한 결과가 주어질 때, 개미굴의 형태를 출력하는 문제이다.

각 방의 키가 문자가 아니라 문자열이라는 특징이 있다.

**[Solution]**






## Reference

[1] [위키백과, '트라이(컴퓨팅)'](https://ko.m.wikipedia.org/wiki/%ED%8A%B8%EB%9D%BC%EC%9D%B4_(%EC%BB%B4%ED%93%A8%ED%8C%85))  
[2] [Geeksforgeeks, 'Trie|(Insert and Search)'](https://www.geeksforgeeks.org/trie-insert-and-search/)  








