---
title: "Z algorithm"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:    
  - Algorithm
use_math: true
comments: true

---

`Tags` 문자열 알고리즘, Z array, 문자열 검색

## 1. Z array

문자열 $S$에 대하여 Z 배열의 원소 $Z\[i\]$ 은 다음과 같이 정의된다.

- $Z\[i\]$ : $S\[i\]$로 시작하는 부분문자열이면서 $S$의 접두사인 문자열들 중 길이가 가장 긴 것의 길이

<br/>

## 2. Z algorithm

Z 알고리즘은 Z 배열을 구하는 알고리즘이다.

문자열 $S$의 길이가 $N$이라고 하면, Z 알고리즘은 $O(N)$의 시간복잡도를 갖는다.

단순히 생각했을 때, $Z\[i\]$를 구하기 위해서는,

- $S\[0\]$과 $S\[i\]$를 비교
- $S\[1\]$과 $S\[i + 1\]$를 비교
- $\vdots$
- $S\[k\]$과 $S\[k + 1\]$를 비교
- $\vdots$

위와 같은 과정을 두 문자가 같지 않을 때까지 반복해주면 된다.

이렇게 Z 배열을 구하면 $O(N^2)$이 걸리게 되는데, 다른 문자열 관련 알고리즘들과 마찬가지로 알고있는 정보를 이용해서 시간을 단축할 것이다.

---

### 2-1. Idea

어떤 $i$에 대하여 $Z\[0\]$부터 $Z\[i-1\]$까지 구했을 때 $Z\[i\]$를 구해보자.

임의의 $j$에 대하여 다음을 정의하자.

- $S_j$ : $Z\[j\]$에 해당하는 부분문자열 ($S\[j\]$로 시작하는 부분문자열이면서 $S$의 접두사인 것들 중 길이가 가장 긴 것)
- $r_j$ : $S_j$의 오른쪽 끝 인덱스
- $L_j, R_j$ : $r_0, \dots, r_j$ 중 가장 큰 것을 $r_k$라고 할 때, $R_j = r_k$, $L_j = k$

항상 $L_{i-1} < i$ 이므로

1. $R_{i-1} < i$
2. $L_{i-1} < i \leq R_{i-1}$

와 같이 두 가지 케이스로 나누어서 생각할 수 있다.

**Case 1)** 이 경우에는 지금까지 구한 정보들을 이용할 수 없기 때문에 $S\[0\]$과 $S\[i\]$부터 차례대로 비교해나간다.

만약 $S_i$가 존재한다면 $L_i = i$, $R_i = r_i$, $Z_i = r_i - i + 1$ 가 되고,

$S_i$가 존재하지 않는다면 $L_i = L_{i-1}$, $R_i= R_{i-1}$, $Z_i = 0$ 이 된다.

**Case 2)** 이 경우에는 지금까지 구한 정보를 이용해서 $Z\[i\]$를 빠르게 구할 수 있다.

왼쪽 끝 인덱스가 $l$, 오른쪽 끝 인덱스가 $r$인 부분문자열을 $S(i, j)$라고 할 때,

$S(L, R) = S(0, R - L)$ 이고 $S(i-L, R-L) = S(i, R)$ 이다.

따라서 $Z\[i\]$를 구하기 위해 $0 \leq j \leq R - i$ 인 $j$에 대하여 $S\[j\]$와 $S\[i + j\]$을 비교하는 것은 $S\[j\]$와 $S\[i-L+j\]$를 비교하는 것과 동일하다.

그런데 $S\[j\]$와 $S\[(i-L)+j\]$를 비교하는 것은 $Z\[i - L\]$을 구하면서 이미 수행한 과정이다.

그렇다면 

<br/>

## References

[1] 


