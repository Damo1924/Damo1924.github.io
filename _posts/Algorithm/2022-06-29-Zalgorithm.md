---
title: "Z algorithm"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:    
  - Algorithm
use_math: true
comments: true

---

`Tags` 문자열 알고리즘, Z array, 문자열 검색

## 1. Z array

문자열 $S$에 대하여 Z 배열의 원소 $Z\[i\]$ 은 다음과 같이 정의된다.

- $Z\[i\]$ : $S\[i\]$로 시작하는 부분문자열이면서 $S$의 접두사인 문자열들 중 길이가 가장 긴 것의 길이

<br/>

## 2. Z algorithm

Z 알고리즘은 Z 배열을 구하는 알고리즘이다.

문자열 $S$의 길이가 $N$이라고 하면, Z 알고리즘은 $O(N)$의 시간복잡도를 갖는다.

단순히 생각했을 때, $Z\[i\]$를 구하기 위해서는,

- $S\[0\]$과 $S\[i\]$를 비교
- $S\[1\]$과 $S\[i + 1\]$를 비교
- $\dots$
- $S\[k\]$과 $S\[i + k\]$를 비교
- $\dots$

위와 같은 과정을 두 문자가 같지 않을 때까지 반복해주면 된다.

이렇게 Z 배열을 구하면 $O(N^2)$이 걸리게 되는데, 다른 문자열 관련 알고리즘들과 마찬가지로 알고있는 정보를 이용해서 시간을 단축할 것이다.

---

### 2-1. Algorithm

어떤 $i$에 대하여 $Z\[0\]$부터 $Z\[i-1\]$까지 구했을 때 $Z\[i\]$를 구해보자.

임의의 $j$에 대하여 다음을 정의하자.

- $S_j$ : $Z\[j\]$에 해당하는 부분문자열 ($S\[j\]$로 시작하는 부분문자열이면서 $S$의 접두사인 것들 중 길이가 가장 긴 것)
- $r_j$ : $S_j$의 오른쪽 끝 인덱스 ($Z\[j\] = r_j - j + 1$)
- $L, R$ : $r_0, \dots, r_j$ 중 가장 큰 것을 $r_k$라고 할 때, $R = r_k$, $L = k$

$Z\[i-1\]$까지 구했을 때 $L \leq i- 1 < i$ 이므로

1. $R < i$
2. $L < i \leq R$

와 같이 두 가지 케이스로 나누어서 생각할 수 있다.

**Case 1)** 이 경우에는 지금까지 구한 정보들을 이용할 수 없기 때문에 $S\[0\]$과 $S\[i\]$부터 차례대로 비교해나간다.

만약 $S_i$가 존재한다면 $L = i$, $R = r_i$ 로 갱신해준다.

반대로 $S_i$가 존재하지 않는다면 $L, R$을 갱신하지 않고, $Z\[i\] = 0$ 이 된다.

**Case 2)** 이 경우에는 지금까지 구한 정보를 이용해서 $Z\[i\]$를 빠르게 구할 수 있다.

왼쪽 끝 인덱스가 $l$, 오른쪽 끝 인덱스가 $r$인 부분문자열을 $S(l, r)$라고 할 때,

$S(L, R) = S(0, R - L)$ 이고 $S(i-L, R-L) = S(i, R)$ 이다.

따라서 $Z\[i\]$를 구하기 위해 $0 \leq j \leq R - i$ 인 $j$에 대하여 $S\[j\]$와 $S\[i + j\]$을 비교하는 것은 $S\[j\]$와 $S\[i-L+j\]$를 비교하는 것과 동일하다.

그런데 $S\[j\]$와 $S\[(i-L)+j\]$를 비교하는 것은 $Z\[i - L\]$을 구하면서 이미 수행한 과정이고, 이미 그 결과인 $Z\[i-L\]$을 알고 있다.

그렇다면 다시 한 번 다음과 같이 경우를 나눌 수 있다.

- $Z\[i-L\] < R - i$
- $R - i \leq Z\[i-L\]$

첫 번째 경우라면, 이미 두 문자가 서로 다른 위치를 알고 있기 때문에 추가로 비교할 필요 없이 $Z\[i\] = Z\[i-L\]$ 가 된다.

또한, $r_i = i + Z\[i\] - 1 < R$ 이므로 $L, R$은 갱신되지 않는다.

두 번째 경우라면, $Z\[i\]$는 최소 $R-i+1$ 라는 사실만 알 수 있다.

$Z\[i\]$의 정확한 값을 구하기 위해서는 $S\[R+1-i\]$와 $S\[R+1\]$부터 차례대로 비교해나가면 된다.

그렇게 $Z\[i\]$를 구한 후에 $L = i$, $R = i + Z\[i\] - 1$ 로 갱신해준다.

---

### 2-2. Time Complexity

Case 1에서는 자명히 $R$보다 큰 인덱스에 대해서만 비교한다.

또, Case 2에서는 $R$보다 작거나 같은 인덱스에 대한 비교 결과를 전에 구해두었던 $Z\[i - L\]$로부터 알 수 있기 때문에 마찬가지로 $R$보다 큰 인덱스에 대해서만 비교를 하게 된다.

즉, 마지막으로 비교했던 위치($R+1$)부터 다시 비교해나가며 $R$을 갱신해주기 때문에 알고리즘의 시간복잡도는 $O(N)$임을 알 수 있다.

---

### 2-3. Implementation

다음은 Z 배열을 구하는 코드이다.

```cpp

```

<br/>

## References

[1] 


