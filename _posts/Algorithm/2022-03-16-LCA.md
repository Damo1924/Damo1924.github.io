---
title: "Lowest Common Ancestor (LCA)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Algorithm
use_math: true
comments: true

---

`Tags` 최소 공통 조상

## 1. Lowest Common Ancestor

LCA(최소 공통 조상)는 **트리의 어떤 두 정점의 공통 조상 노드 중 레벨이 가장 큰 노드**를 말한다.

쉽게 말해 두 노드에서 각자의 조상 노드를 거슬러 올라갈 때, 처음으로 만나는 노드이다.

LCA를 구하는 가장 쉬운 방법은 두 노드의 레벨을 맞춘 후에 조상 노드를 거슬러 올라가면서 처음으로 만나는 노드를 찾는 것이다.

노드가 $n$개인 트리에서 위와 같이 LCA를 구하는 시간복잡도는 $O(n)$이다.

그렇기 때문에 LCA를 구하는 쿼리가 많이 주어지는 문제의 경우, 시간 제한에 걸릴 수 있다.

이번 포스팅에서는 LCA를 빠르게 구할 수 있는 두 가지 방법에 대해 살펴볼 것이다.

<br/>

## 2. DFS: $O(\log n)$

첫 번째는 트리 전체가 전처리를 해줌으로써 LCA를 $O(\log n)$으로 구할 수 있는 방법이다.

각 노드의 조상 노드를 거슬러 올라간다는 원리는 동일하지만, 노드의 조상 노드를 미리 구해두어 더 빠르게 탐색할 수 있도록 한다.

그렇다고 각 노드의 모든 조상 노드를 전부 저장하기에는 $n^2$ 크기의 배열이 필요하기 때문에 불가능하다.

그런데 굳이 모든 조상 노드를 구할 필요 없이, **각 노드의 $2^i$($0 \leq i \leq \lfloor \log n \rfloor$)번째 조상 노드**만 구해두어도 충분하다는 사실을 알 수 있다.

위 정보를 이용하기 위해서 각 노드의 레벨도 함께 구하자.

즉, 다음과 같은 배열들을 정의하고 DFS를 통해 미리 구해두는 것이다.

> `anc[x][i]` : 정점 $x$의 $2^i$번째 조상 노드를 저장
> 
> `dep[x]` : 정점 $x$의 레벨(깊이)

---

### 2-1. Preprocessing

먼저 앞서 정의한 두 배열을 구하는 부분부터 구현해보자.

정점 $x$의 $2^i$번째 조상 노드는 $x$의 $2^{i-1}$번째 조상 노드의 $2^{i-1}$번째 조상 노드와 같다.

이를 이용하면 다음과 같이 `anc` 배열을 구할 수 있다.

```cpp
for (int i = 1; i < 20; i++)
        for (int x = 1; x <= n; x++)
            anc[x][i] = anc[anc[x][i - 1]][i - 1];
```

각 노드의 깊이를 구하기 위해서는 루트 노드부터 DFS로 트리를 탐색해야한다.

```cpp
void dfs(int x, int d)
{
    dep[x] = d;
    for (int y : graph[x])
    {
        if (dep[y]) continue;
        dfs(y, d + 1);
    }
}
```

이때 `graph[x]`는 정점 $x$에 인접한 노드의 번호를 저장한 벡터이다.

조상 노드들을 구하는데 $O(n \log n)$, 깊이를 구하는데 $O(n)$이므로 전처리 과정의 시간복잡도는 $O(n \log n)$이다.

---

### 2-2. LCA

이제 두 노드의 LCA를 구하는 함수를 구현하자.

원리는 $O(n)$ 방식과 동일하다.

- 두 정점의 깊이를 같게 만들고,
- 조상 
