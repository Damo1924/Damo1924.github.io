---
title: "Minimum Cost Maximum Flow (MCMF)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Algorithm
use_math: true
comments: true

---

`Tags` Maximum Flow Problem, Shortest Path Problem, SPFA

## 1. Minimum Cost Maximum Flow (MCMF)

Maximum Flow 문제는 그래프의 각 간선에 유량이 존재할 때, 어떤 두 정점 사이를 지날 수 있는 최대 유량을 구하는 문제였다.

> Maximum Flow 문제는 [이 포스트](https://damo1924.github.io/algorithm/MaximumFlow/)에서 자세히 다루고 있다.

Minimum Cost Maximum Flow 문제는 **그래프의 각 간선에 유량과 함께 비용이 주어지는 경우**에서 **최소 비용에 대한 최대 유량**을 구하는 문제이다.

예를 들어 어떤 간선의 비용이 $d$이고, 해당 간선에 순방향으로 $f$만큼의 유량이 흐르고 있을 때 소비되는 비용은 $d \times f$가 된다.

MCMF 문제는 지금까지 다룬 알고리즘들을 이용해서 쉽게 해결할 수 있다.

그래프의 소스를 $S$, 싱크를 $T$라고 할 때, MCMF 알고리즘은 다음과 같다.

---

1. 간선의 비용을 가중치라고 생각하고 $S$에서 $T$까지의 최단 거리를 구한다.
2. 최단 거리에 해당하는 경로에 흐를 수 있는 최대 유량을 흘려준다. 이때 최대 유량 문제를 풀 때처럼 **각 간선에 반대 방향의 유량이 흐른다고 생각할 수 있으므로** 이를 고려해준다.
3. 더 이상 유량을 흘리지 못할 때까지 1~2를 반복한다.

---

즉, MCMF 문제는 최단 경로 문제와 최대 유량 문제를 더한 것이라고 생각하고 풀면 된다.

이때 1번 과정에서 최단 경로를 찾을 때에는 **음수 가중치가 존재**하는 그래프에서의 최단거리를 구할 수 있는 알고리즘을 사용해야한다.

그 이유는 2번에서 최대 유량을 흘려줄 때, 반대 방향으로 음의 유량이 흐른다고 생각하기 때문에 원래 간선의 비용이 $c$였다면, 반대 방향의 비용은 $-c$가 된다.

따라서 음수 가중치가 존재하는 그래프에서의 최단 경로를 찾을 수 있는 **Bellman-Ford algorithm**이나 조금 더 효율적인 $SPFA$를 이용한다.

> [Bellman-Ford algorithm](https://damo1924.github.io/algorithm/ShortestPathAlgorithm/#3-bellman-ford-algorithm)  
> [Shortest Path Faster Algorithm (SPFA)](https://damo1924.github.io/algorithm/SPFA/)

이제 MCMF 문제를 직접 풀어보도록 하자.

<br/>

## [백준] 11408. 열혈강호 5

**[PROBLEM]**

강호네 회사에는 직원이 $N$명이 있고, 해야 할 일이 $M$개가 있다.

직원은 1번부터 $N$번, 해야 할 일은 1번부터 $M$번으로 번호가 매겨져 있다.

각 직원은 하나의 일만 할 수 있고 각각의 일을 담당하는 사람은 1명이어야 한다.

각각의 직원이 할 수 있는 일의 목록과 그 일을 할 때 강호가 지급해야 하는 월급이 주어졌을 때, M개의 일 중에서 최대 몇 개를 할 수 있는지, 그리고 그 때 강호가 지불해야하는 월급의 최솟값을 구하여라.

**[INPUT]**

첫째 줄에 직원의 수 $N$과 일의 개수 $M$이 주어진다. ($1 \leq N, M \leq 400$)

둘째 줄부터 N개의 줄의 i번째 줄에는 i번 직원이 할 수 있는 일의 개수와 할 수 있는 일의 번호, 그 일을 할 때의 월급이 주어진다.

월급은 10,000보다 작거나 같은 자연수 또는 0이다.

**[OUTPUT]**

첫째 줄에 강호네 회사에서 할 수 있는 일의 개수를 출력한다.

둘째 줄에는 그 때 강호가 지급해야 하는 월급의 최솟값을 출력한다.

---

### [Solution]










## Reference

[1] 
