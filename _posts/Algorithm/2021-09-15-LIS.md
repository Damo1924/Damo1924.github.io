---
title: "Algorithms to find the Longest Increasing Subsequence(LIS)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Algorithm
use_math: true
comments: true

---

## 1. LIS

LIS는 Longest Increasing Subsequence의 약자로, 우리말로 하면 '최장 증가 부분 수열'이다.

**부분 수열**이란, 전체 수열에서 일부 원소를 선택해서 만들어진 수열을 말한다.

이때 해당 수열이 오름차순으로 정렬되어 있으면 **증가하는 부분 수열**이라고 부른다.

예를 들어 $\\{10, 30, 20, 50, 30, 40\\}$인 수열을 생각해보자.

위 수열의 LIS는 많은 증가하는 부분 수열 중 가장 긴 $\\{10, 20, 30, 40\\}$이다.

이렇게 수열을 입력했을 때 LIS를 구하는 문제는 **대표적인 DP(Dynamic Programming) 문제**이다.

이번 포스트에서는 일반적으로 알고 있는 $O(N^2)$의 시간복잡도를 갖는 알고리즘과 좀 더 어렵지만 $O(N \log N)$의 시간복잡도를 갖는 알고리즘에 대해서 다루어 볼 것이다.


<br/>
## 2. $O(N^2)$

### 2-1. Algorithm

수열을 입력받아 배열 `arr`에 저장하고, 그 길이를 n이라 하자.

먼저, 동적 계획법을 이용하기 위해 다음과 같은 `dp` 배열을 정의한다.

- `dp[i]` = i번째 원소를 마지막 원소로 하는 부분 수열 중 최장 증가 부분 수열의 길이

알고리즘은 다음과 같다.

1. 입력받은 수열의 길이(n)와 동일한 길이의 `dp` 배열 선언
2. `dp[0]`부터 `dp[n-1]`까지 순서대로 값을 구해나간다. 이때, `dp[i]`의 값을 구하는 방법은 다음과 같다.  
  (1) `dp[i]`의 값을 1로 초기화  
  (2) 현재 원소보다 앞에 있는 원소들 중 현재 원소보다 작은 원소를 탐색  
  (3) 앞에서 찾은 원소 `arr[j]`에 대해 `dp[j]+1`의 값이 `dp[i]`보다 크다면 값을 갱신
3. `dp` 배열의 원소 중에서 가장 큰 값이 최장 증가 부분 수열의 길이

### 2-2. [백준] 11053. 가장 긴 증가하는 부분 수열

[백준 11053. 가장 긴 증가하는 부분 수열 문제 링크](https://www.acmicpc.net/problem/11053)

수열이 주어질 때, 최장 증가 부분 수열의 길이를 구하는 문제이다.

수열의 최대 길이가 1000이기 때문에 $O(N^2)$으로도 충분히 해결할 수 있다.

```cpp
#include <iostream>
using namespace std;

const int maxLen = 1000;

int dp[maxLen]; // dp[i]: arr[i]로 끝나는 가장 긴 증가하는 부분 수열

int main()
{
    // Fast I/O
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int n; // 수열 A의 크기
    cin >> n;
    
    int arr[maxLen]; // 수열 A
    for (int i = 0; i < n; i++) cin >> arr[i];
    
    int ans = 1;
    fill_n(dp, n, 1);
    for (int i = 1; i < n; i++) {
        for (int j = i-1; j > -1; j--)
            if (arr[i] > arr[j])
                dp[i] = (dp[i] > dp[j] + 1) ? dp[i] : dp[j] + 1;
        if (dp[i] > ans) ans = dp[i];
    }
    cout << ans;
}
```

### 2-3. [백준] 14002. 가장 긴 증가하는 부분 수열 4

[백준 14002. 가장 긴 증가하는 부분 수열 4](https://www.acmicpc.net/problem/14002)

이 문제는 2-2 문제와 동일하지만, 가장 긴 증가하는 부분 수열 중 아무거나 하나를 길이와 함께 출력해야하는 문제이다.

수열을 직접 출력해야하기 때문에 LIS에서 어떤 원소의 바로 앞 원소를 알 수 있게 다음 배열을 추가로 정의하였다.

- `previousElement[i]` = LIS에서 `arr[i]` 앞에 오는 원소의 인덱스를 저장

예를 들어 $\\{10, 20, 10, 30, 20, 50\\}$의 LIS를 구하는 과정은 다음과 같다.

|i|0|1|2|3|4|5|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|arr[i]|10|20|10|30|20|50|
|dp[i]|1|2|1|3|2|4|
|previousElement[i]|x|0|x|1|2|3|

dp 배열 중 최댓값은 4이므로 `i=5`부터 시작해서 `i = previousElement[i]`로 i를 갱신하면 LIS의 원소들의 인덱스를 얻을 수 있다.

i = 5 $\rightarrow$ i = 3 $\rightarrow$ i = 1 $\rightarrow$ i = 0

이를 거꾸로 나열하면 LIS를 얻을 수 있다.

arr[0] = 10 $\rightarrow$ arr[1] = 20 $\rightarrow$ arr[3] = 30 $\rightarrow$ arr[5] = 50

시간복잡도는 그대로 $O(N^2)$이다.

```cpp
#include <iostream>
using namespace std;

const int maxLen = 1000;

int main()
{
    int n; // 수열의 길이
    cin >> n;
    
    int arr[maxLen]; // 수열
    for (int i = 0; i < n; i++) cin >> arr[i];
    
    int dp[maxLen] = {};
    int previousElement[maxLen] = {}; // 바로 앞 원소의 인덱스를 저장
    int maxIndex = 0; // dp[i]가 최대인 i를 저장
    for (int i = 0; i < n; i++)
    {
        dp[i] = 1; // 초기화
        for (int j = 0; j < i; j++)
            if (arr[j] < arr[i] && dp[j] + 1 > dp[i]) // LIS 조건을 만족하면,
            {
                dp[i] = dp[j] + 1; // dp 배열의 값 갱신
                previousElement[i] = j; // LIS에서 i 앞에 j가 온다는 정보를 저장
            }
        
        if (dp[maxIndex] < dp[i]) maxIndex = i; // dp가 최대인 인덱스 구하기
    }
    
    int L = dp[maxIndex]; // LIS의 길이
    
    int subarr[L], k = maxIndex; // LIS를 저장할 배열
    for (int i = L - 1; i >= 0; i--)
    {
        subarr[i] = arr[k];
        k = previousElement[k]; // LIS의 맨 끝 원소부터 시작해서 맨 앞 원소까지 추적
    }
    
    cout << L << "\n";
    for (int i = 0; i < dp[maxIndex]; i++)
        cout << subarr[i] << " ";
}
```


<br/>
## 3. $O(N \log N)$ Algorithm
