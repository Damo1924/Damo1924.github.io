---
title: "Fenwick Tree (Binary Indexed Tree, BIT)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Algorithm
use_math: true
comments: true

---

`Tags` Segment tree, 

## 1. Fenwick Tree

> 펜윅 트리는 Binary indexed tree라는 이름으로 불리기도 하며, 줄여서 BIT라고 한다.

펜윅 트리는 **주어진 수열의 부분 수열들의 구간 합**을 빠르게 구하기 위해 고안된 자료구조이다.

부분 수열의 구간 합을 구하는 대표적인 방법은 **세그먼트 트리(segment tree)**를 이용하는 것이다.

펜윅 트리는 세그먼트 트리와 마찬가지로 구간 합을 구하는 작업과 값을 업데이트하는 작업을 모두 $O(\log n)$에 처리할 수 있다.

---

### 1-1. Structure

길이가 $n$인 수열 $a\[1\], a\[2\], \dots, a\[n\]$이 주어졌을 때,

정수 $i(1 \leq i \leq n)$에 대해 펜윅 트리의 노드 $i$에 저장된 값 $BIT\[i\]$는 다음과 같이 정의된다.

1. $i$가 홀수일 때: $i = 2x + 1$
  \begin{aligned}
  BIT\[2x + 1\] = a\[2x + 1\]
  \end{aligned}
2. $i$가 $2^k$의 배수이면서 $2^{k+1}$의 배수가 아닐 때: $i = 2^{k+1}x + 2^k)$
  \begin{aligned}
  BIT\[2^{k+1}x + 2^k\] = \sum_{j = 1}^{2^k} a\[2^{k+1}x + j\]
  \end{aligned}

아래 그림은 $n = 16$일 때 펜윅 트리의 각 노드가 포함하는 범위를 표시한 것이다.

<center><img src="https://user-images.githubusercontent.com/88201512/153751102-f360bfdc-2039-4e4f-9752-30f6098948f4.jpg"></center>

---

### 1-2. Get Sum

펜윅 트리의 구조에 대해 공부했으니, 이제 구간 합을 구하는 방법과 값 업데이트를 반영하는 방법에 대해 알아보자.

먼저 구간 $\[1, b\]$의 합을 구하는 방법은 $b$를 **이진법**으로 표현하는 것이다.

예를 들어 $b = 11$에 대한 구간 합은 다음과 같이 구할 수 있다.

\begin{aligned}
\sum_{i = 1}^11 a\[i\] = BIT\[11\] + BIT\[10\] + BIT\[8\]
\end{aligned}

> 각 숫자를 이진법으로 표현하면 $11 = 1011_2$, $10 = 1010_2$, $8 = 1000_2$이다.
> 
> $1011_2$에서 **가장 오른쪽에 있는 1**을 빼주면 $1010_2$을 얻을 수 있고,
> 
> $1010_2$에서 가장 오른쪽에 있는 1을 빼주면 $1000_2$를 얻을 수 있다.
> 
> 이진법으로 나타냈을 때, 가장 오른쪽에 있는 1을 빼주는 것은 비트 연산자를 이용해서 다음과 같이 구현할 수 있다.
> 
> ```cpp
> b &= (b - 1);
> ```

이처럼 주어진 $b$에 대해 $O(\log b)$로 구간 합을 구할 수 있다.

그렇다면 구간 $\[a, b\]$의 합은 어떻게 구할까?

바로 $\[1, b\]$에서 $\[1, a\]$를 빼주는 것이다.

따라서 임의의 두 자연수 $a, b(a \leq b)$에 대해 구간 $\[a, b\]$의 합을 $O(\log n)$에 구할 수 있다.

구간 합을 구하는 함수 `_sum()`은 다음과 같이 구현할 수 있다.

```cpp

```

---

### 1-3. Update Value

어떤 정수 $i(1 \leq i \leq n)$에 대해 $a\[i\]$를 $v$로 바꾸면, $a\[i\]$를 포함하는 펜윅 트리의 노드들을 모두 업데이트해야한다.

예를 들어 $n = 16$일 때 $a\[5\]$의 값을 바꾸면, 다음 값들을 업데이트해야한다.

\begin{aligned}
BIT\[5\], BIT\[6\], BIT\[8\], BIT\[16\]
\end{aligned}

> 각 숫자를 이진법으로 표현하면, $5 = 00101_2$, $6 = 00110_2$, $8 = 01000_2$, $16 = 10000_2$이다.
> 
> 앞서 구간 합을 구할 때에는 가장 오른쪽에 있는 1을 빼주었다면, 이번에는 **가장 오른쪽에 있는 1을 더함**으로써 다음 숫자를 얻을 수 있다.
> 
> $i$의 가장 오른쪽 1에 해당하는 값은 `i & (-i)`로 얻을 수 있으므로, 다음과 같이 다음 숫자를 구할 수 있다.
> 
> ```cpp
> i += (i & (-i));
> ```

따라서 값을 업데이트하는데 $O(\log n)$의 시간복잡도가 필요하게 된다.

값을 업데이트하는 함수 `_update()`는 다음과 같이 구현할 수 있다.

```cpp

```

<br/>

## References

[1] 
