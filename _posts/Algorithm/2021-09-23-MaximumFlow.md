---
title: "최대 유량(Maximum Flow) 문제"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Algorithm
use_math: true
comments: true

---

## 1. Maximum Flow Problem

최대 유량(Maximum Flow) 문제는 그래프의 두 지점 사이를 지날 수 있는 최대 유량을 구하는 문제이다.

총 세 개의 노드 A, B, C로 이루어진 그래프가 있다.

이때 A와 B 사이의 간선은 최대 10만큼의 유량이 통과할 수 있고, B와 C 사이의 간선은 최대 5만큼의 유량이 통과할 수 있으며, A와 C는 연결되어 있지 않다.

그렇다면 A에서 C로 흐를 수 있는 최대 유량을 얼마일까?

어렵지 않게 5라고 답할 수 있다.

이처럼 그래프의 각 간선이 통과할 수 있는 최대 유량을 가질 때, 어떤 시작 지점부터 도착 지점까지 흐를 수 있는 최대 유량을 구하는 문제를 최대 유량 문제라고 한다.

다음은 최대 유량 문제에서 사용하는 용어들이다.

- **유량 네트워크(Flow network)**: 각 간선에 용량이 주어진 그래프
- **소스(source)**: 시작 지점
- **싱크(sink)**: 도착 지점
- **용량(capacity)**: 각 간선에 대해서 흐를 수 있는 최대 유량

이때 **유량(flow)**이란, 다음 조건을 만족하는 값을 의미한다.

- **용량의 제한(capacity constraint)**: 유량은 그 간선의 용량을 초과할 수 없다.
- **유량의 보존(conservation of flows)**: 소스와 싱크를 제외한 정점에는 들어오는 유량와 나가는 유량이 동일하다.

그렇다면, 이를 해결할 수 있는 알고리즘에 대해 알아보자.


<br/>
## 2. Ford-Fulkerson Algorithm

포드-풀커슨 알고리즘은 다음과 같다.

---

1) 소스에서 싱크까지 모든 간선의 용량이 0보다 큰 경로를 구한다.

> 이러한 경로를 **증가 경로**라고 부른다.

2) 위에서 찾은 경로를 지날 수 있는 최대 용량(f)을 구한다.

3) 해당 간선들을 지나는 유량에 f를 더한다.

4) 해당 간선들의 반대 방향 간선들을 지나는 유량에 f를 뺀다.

5) 위 과정(1 ~ 4)를 더 이상 증가 경로가 존재하지 않을 때까지 반복한다.

---

문제는, 이 알고리즘은 증가 경로를 찾는 방법에 대해 제시하지 않았다는 점이다.

그러므로 대표적인 그래프 탐색 방법인 DFS 또는 BFS를 통해 증가 경로를 찾으면 되는데, 어느 방법이든 $O(f \cdot E)$의 시간 복잡도를 갖는다.

이때 $f$는 유량의 총 크기이다.

그런데 증가 경로를 BFS로 찾는 경우, 시간 복잡도가 $O(VE^2)$임이 증명되었고, 따라서 최대 유량 문제를 풀 때는 BFS를 사용하면 된다.

BFS를 사용하는 알고리즘을 Edmonds-Karp Algorithm이라고 부른다.


<br/>
## 3. Edmonds-Karp Algorithm & Implementation

에드몬드-카프 알고리즘은 포드-풀커슨 알고리즘에서 증가 경로를 찾는 방법만을 제시한 것이므로 알고리즘 자체는 동일하다.

다만, 이번에는 코드를 구현하는 관점에서 알고리즘을 정리해보았다.

---

1) BFS를 통해 시작 지점에서 도착 지점까지 이어지는 경로를 하나 찾고, 배열을 하나 선언하여 경로를 저장한다.

2) 위에서 찾은 경로를 따라가면서 해당 경로로 지나갈 수 있는 최대 유량을 구한다.

3) 경로를 따라가면서 각 간선을 통과하는 유량에 앞에서 구한 값을 더해준다. 이때, 각 간선의 반대 방향으로 음의 유량이 지난다고 생각할 수 있으므로 각 간선의 반대 방향 유량에 앞에서 구한 값을 빼준다.

> 예를 들어 A에서 B로 가는 간선에 10만큼의 유량이 흐른다면 B에서 A로 가는 유량은 -10이라고 할 수 있다.
>
> 이를 고려해주어야 하는 이유는 B에서 A로 가는 경로가 존재할 수 있기 때문이다.
>
> B에서 A 방향으로 가는 경로를 발견했을 때, 해당 간선을 통과할 수 있는 최대 유량은 10 - 0 = 10이 아니라 10 - (-10) = 20이다.
>
> 즉, A에서 B로 가는 유량 10, B에서 A로 가는 유량 20을 더하면 B에서 A로 10만큼의 유량이 흐르는 것이므로 용량을 초과하지 않으면서 두 경로를 최대한으로 이용할 수 있게 된다.

4) 결과값에 위에서 구한 유량을 더해준다.

5) 위 과정(1 ~ 4)를 더 이상 시작 지점에서 끝 지점으로 가는 새로운 경로가 없을 때까지 반복한다.

---

앞에서 언급했듯이, 에드몬드-카프 알고리즘의 시간복잡도는 $O(VE^2)$으로 알려져 있다.

BFS를 이용해서 소스에서 싱크까지의 경로를 찾는데 $O(E)$이므로 위 사실을 증명하기 위해서는 증가 경로를 많아야 $VE$번 찾는다는 사실을 보이면 된다.

어떤 그래프의 최단 경로의 길이를 $D$라고 하자.

최단 경로를 하나 탐색하면 적어도 하나의 간선은 해당 간선의 유량이 용량과 같아지게 되며, 더 이상 최단 경로가 $D$인 경로 중에는 해당 간선을 통과하는 경로가 존재하지 않게 된다.

만약 길이가 $D$이면서 해당 간선의 반대 방향으로 지나는 경로가 존재한다고 가정하면, $D-1$인 경로가 존재하게 되어 최단 경로가 $D$라는 전제에 모순이다.

그러므로 최단 경로의 길이가 $D$인 동안은 최대 $E$번 증가 경로를 찾게 된다.

최단 경로의 길이는 1부터 $V$까지 가능하므로 위의 과정이 최대 $VE$번 반복된다.

따라서 에드몬드-카프 알고리즘의 시간복잡도는 $O(VE^2)$이다.

이를 이용해서 간단한 문제 하나를 풀어보도록 하자.

### [백준] 6086. 최대 유량

[백준 6086. 최대 유량 문제 링크](https://www.acmicpc.net/problem/6086)

첫 줄에 간선의 개수 N($1 \leq N \leq 700$)이 주어지고 둘째 줄부터 각 간선의 정보가 주어진다.

각 노드의 이름은 알파벳 소문자(a ~ z)와 대문자(A ~ Z)이며, 간선의 용량은 1000 이하의 자연수이다.

이때 A에서 Z까지의 최대 유량을 구하는 문제로, Edward-Karp Algorithm을 이용하면 시간 내에 해결할 수 있다.

Edward-Karp Algorithm을 이용해서 최대 유량을 반환하는 함수 `maxFlow()`와 노드의 이름이 문자로 주어지므로 이를 0 ~ 51의 정수로 변환해주는 `index()` 함수를 구현하였다.

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;

const int Max = 52, Inf = 1000000000;

int n;

int p[Max]; // path
int c[Max][Max]; // capacity
int f[Max][Max]; // flow

vector<int> g[Max]; // graph

int maxFlow(int start, int end)
{
    int ans = 0;

    while (1)
    {
        fill(p, p + Max, -1); // 경로를 -1로 초기화

        queue<int> q;
        q.push(start);
        while (!q.empty() && p[end] == -1)
        {
            int x = q.front();
            q.pop();
            for (int i = 0; i < g[x].size(); i++)
            {
                int y = g[x][i];

                // 방문하지 않은 노드 중 용량이 남은 경우
                if (c[x][y] - f[x][y] > 0 && p[y] == -1)
                {
                    q.push(y);
                    p[y] = x; // 경로 저장
                }
            }
        }

        if (p[end] == -1) break; // 더 이상 도착 지점에 도달하는 경로가 없는 경우

        int flow = Inf; // 찾은 경로를 지나는 최대 유량
        for (int i = end; i != start; i = p[i])
            flow = min(flow, c[p[i]][i] - f[p[i]][i]);

        for (int i = end; i != start; i = p[i])
        {
            f[p[i]][i] += flow;
            f[i][p[i]] -= flow;
        }
        ans += flow;
    }

    return ans;
}

int index(char c)
{
    if (c >= 'a') return c - 71;
    else return c - 65;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> n;
    for (int i = 0; i < n; i++)
    {
        char a, b;
        int tmp, A, B;
        cin >> a >> b >> tmp;
        A = index(a);
        B = index(b);

        g[A].push_back(B);
        g[B].push_back(A);
        c[A][B] += tmp;
        c[B][A] += tmp;
    }

    cout << maxFlow(0, 25);
}
```


<br/>
## 4. 
