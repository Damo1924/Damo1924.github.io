---
title: "Shortest Path Faster Algorithm (SPFA)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Algorithm
use_math: true
comments: true

---

`Tags` 최단 경로 문제, Shortest Path Problem, Dijkstra, Bellman-Ford, 다익스트라, 벨만-포드

## 1. Shortest Path Faster Algorithm (SPFA)

SPFA는 **Bellman-Ford algorithm을 개선한 알고리즘**으로, **방향 가중치 그래프에서 단일 출발 최단 거리 문제**를 해결할 수 있다.

대표적인 Shortest Path algorithm인 다익스트라(Dijkstra) 알고리즘이나 벨만-포드(Bellman-Ford) 알고리즘처럼 **Edge Relaxation**을 이용한다.

(최단 경로 문제와 알고리즘에 대한 자세한 내용은 [이 포스트](https://damo1924.github.io/algorithm/ShortestPathAlgorithm/)에서 다루고 있다.)

SPFA의 Worst-case 시간 복잡도는 $O(\left\vert V \right\vert \left\vert E \right\vert)$로 벨만-포드 알고리즘과 동일하지만, 실제 실행 시간은 훨씬 더 빠르다.

무엇보다 SPFA의 장점은 벨만-포드를 개선시킨만큼 **음수 가중치 간선을 가진 그래프에도 적용이 가능하다**는 것이다.

SPFA는 다음과 같은 과정으로 이루어진다.

---
1. Queue에 탐색을 시작할 정점을 삽입한다.
2. Queue에서 정점을 뽑아 연결된 간선들을 순회하며 주변 정점들로의 최단 경로를 갱신한다.
3. 2번 과정에서 최단 경로가 갱신된 점들 중 Queue에 없는 정점들은 Queue에 삽입해준다.
4. 2~3번 과정을 Queue에 원소가 없을 때까지 반복한다.
---

즉, 벨만-포드 알고리즘이 **모든 간선에 대해 최단 경로를 갱신**했다면, SPFA는 **최단 경로가 갱신된 정점에 연결된 간선에 대해서만 탐색**한다고 생각하면 된다.

그렇다보니 설령 최악 시간복잡도가 동일하다해도 **일반적으로 SPFA가 벨만-포드 알고리즘보다 훨씬 더 빠르게 동작한다**.

> 실제 SPFA의 평균 실행 시간은 $O(\left\vert E \right\vert)$ 정도로 알려져 있지만, 증명된 사실은 아니다.

SPFA를 구현할 때는 다음과 같은 자료구조들을 이용한다.

- 최단 경로가 갱신된 정점들을 저장하는 큐
- 각 정점까지의 최단 경로를 저장할 배열
- **각 정점이 큐에 들어있는지 판별할 배열**

이제 직접 SPFA로 최단 경로 문제를 해결해보자.

---

### [백준]

