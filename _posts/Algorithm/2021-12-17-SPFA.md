---
title: "Shortest Path Faster Algorithm (SPFA)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Algorithm
use_math: true
comments: true

---

`Tags` 최단 경로 문제, Shortest Path Problem, Dijkstra, Bellman-Ford, 다익스트라, 벨만-포드

## 1. Shortest Path Faster Algorithm (SPFA)

SPFA는 **Bellman-Ford algorithm을 개선한 알고리즘**으로, **방향 가중치 그래프에서 단일 출발 최단 거리 문제**를 해결할 수 있다.

대표적인 Shortest Path algorithm인 다익스트라(Dijkstra) 알고리즘이나 벨만-포드(Bellman-Ford) 알고리즘처럼 **Edge Relaxation**을 이용한다.

(최단 경로 문제와 알고리즘에 대한 자세한 내용은 [이 포스트](https://damo1924.github.io/algorithm/ShortestPathAlgorithm/)에서 다루고 있다.)

SPFA의 Worst-case 시간 복잡도는 $O(\left\vert V \right\vert \left\vert E \right\vert)$로 벨만-포드 알고리즘과 동일하지만, 실제 실행 시간은 훨씬 더 빠르다.

무엇보다 SPFA의 장점은 벨만-포드를 개선시킨만큼 **음수 가중치 간선을 가진 그래프에도 적용이 가능하다**는 것이다.

SPFA는 다음과 같은 과정으로 이루어진다.

---
1. Queue에 탐색을 시작할 정점을 삽입한다.
2. Queue에서 정점을 뽑아 연결된 간선들을 순회하며 주변 정점들로의 최단 경로를 갱신한다.
3. 2번 과정에서 최단 경로가 갱신된 점들 중 Queue에 없는 정점들은 Queue에 삽입해준다.
4. 2~3번 과정을 Queue에 원소가 없을 때까지 반복한다.

---

즉, 벨만-포드 알고리즘이 **모든 간선에 대해 최단 경로를 갱신**했다면, SPFA는 **최단 경로가 갱신된 정점에 연결된 간선에 대해서만 탐색**한다고 생각하면 된다.

그렇다보니 설령 최악 시간복잡도가 동일하다해도 **일반적으로 SPFA가 벨만-포드 알고리즘보다 훨씬 더 빠르게 동작한다**.

> 실제 SPFA의 평균 실행 시간은 $O(\left\vert E \right\vert)$ 정도로 알려져 있지만, 증명된 사실은 아니다.

SPFA를 구현할 때는 다음과 같은 자료구조들을 이용한다.

- 최단 경로가 갱신된 정점들을 저장하는 큐
- 각 정점까지의 최단 경로를 저장할 배열
- 각 정점이 큐에 들어있는지 판별할 배열 -> **큐에 없는 경우에만 큐에 삽입한다.**
- 각 정점을 몇 번 방문했는지 세는 배열 -> **같은 정점을 N번 이상 방문했으면 음의 사이클이 존재함을 의미한다.**

이제 직접 SPFA로 최단 경로 문제를 해결해보자.

---

### [백준] 11657. 타임머신

[백준 11657. 타임머신 문제 링크](https://www.acmicpc.net/problem/11657)

[벨만-포드 알고리즘을 사용한 풀이](https://damo1924.github.io/algorithm/ShortestPathAlgorithm/#%EB%B0%B1%EC%A4%80-11657-%ED%83%80%EC%9E%84%EB%A8%B8%EC%8B%A0)

다른 포스트에서 벨만-포드 알고리즘으로 풀었던 문제를 SPFA를 이용해서 풀어보았다.

```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;
const int INF = 1000000000;

vector<pair<int, int>> graph[501]; // 정점에 연결된 간선 정보 저장

long long dist[501]; // dist[i]: 1부터 i까지의 최단 시간

bool isInQueue[501]; // isInQueue[i]: i가 큐에 있으면 true, 아니면 false

int cycle[501]; // cycle[i]: i를 방문한 횟수, 음의 사이클 존재 파악에 이용한다.

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    int N, M;
    cin >> N >> M;
    
    int a, b, c;
    for(int i = 0; i < M; i++)
    {
        cin >> a >> b >> c;
        graph[a].push_back({b, c});
    }   
    
    for(int i = 1; i <= N; i++) dist[i] = INF; // 매우 큰 값으로 초기화
    
    queue<int> q;
    q.push(1);
    dist[1] = 0;
    isInQueue[1] = 1;
    while (!q.empty())
    {
        int cur = q.front();
        q.pop();
        isInQueue[cur] = 0;
        
        // 같은 정점을 N번 이상 방문 -> 음의 사이클 존재
        cycle[cur]++;
        if (cycle[cur] >= N)
        {
            cout << -1;
            return 0;
        }
        
        // 연결된 간선 탐색
        for (int i = 0; i < graph[cur].size(); i++)
        {
            int next = graph[cur][i].first;
            if (dist[next] > dist[cur] + graph[cur][i].second)
            {
                dist[next] = dist[cur] + graph[cur][i].second;
                if (!isInQueue[next])
                {
                    isInQueue[next] = 1;
                    q.push(next);
                }
            }
        }
    }
    
    for (int i = 2; i <= N; i++)
    {
        if (dist[i] == INF) cout << "-1\n";
        else cout << dist[i] << "\n";
    }
}
```

<br/>

## 2. Proof of Correctness

알고리즘이 항상 정확한 최단 경로를 구한다는 사실을 증명해보자.

가중치가 있는 방향 그래프 $G = (V, E)$와 소스(source) $s$가 주어졌다.

정점 $u$, $v$ 사이의 간선의 가중치는 $w(u, v)$이다.

**[Lemma]** 큐가 비어있는지 확인할 때, 현재 edge relaxation을 일으킬 수 있는 정점은 모두 큐에 있다.

> ***Proof.***
> 
> 큐가 비어있는지 확인하는 시점에, 어느 두 정점 $u$, $v$에 대해서 $dist[w] > dist[u] + w(u, w)$가 성립한다면 $u$가 이미 큐에 있다는 사실을 증명하고자 한다.
> 1
> 이는 반복문을 실행한 횟수 $k$에 대한 귀납법으로 증명할 수 있다.
> 1
> 먼저, 반복문을 처음 실행할 때($k = 0$)에는 오직 $u = s$인 경우에만 relaxation이 일어난다는 것은 자명하다.
> 1
> 다른 정점까지의 거리는 모두 매우 큰 값으로 초기화된 상태이고 $s$까지의 거리만 0이기 때문이다.
> 1
> 이때 $s$는 반복문을 처음 수행하기 전에 큐에 삽입되었으므로 성립한다.
> 1
> 이제 어떤 자연수 $k$에 대해서 $k$번 반복문을 실행했을 때를 생각해보자.
> 1
> 어떤 정점 $u$가 큐에서 삭제되면서 간선으로 연결된 다른 정점들에 대한 relaxation을 수행하게 된다.
> 1
> 만약 위 과정 이후에 어떤 정점 $x$에 대해 $dist[x] > dist[w] + w(w, x)$를 만족하고 큐에 없는 $w$가 생겼다면, 두 가지 경우를 생각할 수 있다.
> 1
> 첫 번째는 $dist[x]$가 증가하는 것인데, 거리가 더 멀어지도록 갱신하진 않으므로 불가능하다.
> 1
> 두 번째는 


### Reference

[1] [WIKIPEDIA, 'Shortest Path Faster Algorithm'](https://en.m.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm)





