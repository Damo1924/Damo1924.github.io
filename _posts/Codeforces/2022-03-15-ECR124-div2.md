---
title: "[CF#9] Educational Codeforces Round #124 (Div. 2)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Codeforces
use_math: true
comments: true

---

`Tags` 

## Result & Review

C번까지 어렵지 않게 30분 내에 풀었고, D번을 이후 한 시간 동안 풀었다.

E번을 조금 건드려보긴 했는데 적절한 아이디어가 떠오르지 않아 테스트케이스도 못 돌려보고 대회가 끝났다.

오랜만에 div.2 대회에서 4솔을 해서 나름 만족스러웠고, 생각보다 높은 등수를 받아 점수가 많이 올라서 기분이 좋았다 ㅎㅎ

<img src="https://user-images.githubusercontent.com/88201512/158290243-0d76abe4-d0a9-486e-84c0-fc33bca9a6a9.jpg">

앞으로 꾸준히 4솔을 하는 것을 목표로 퍼플까지 찍는 것을 목표로 달려야지.

<br/>

## A. Playoff

[A번 문제 링크](https://codeforces.com/contest/1651/problem/A)

**[PROBLEM]**

$2^n$명의 선수들이 참가한 대회에서 토너먼트 방식으로 우승자를 결정하려고 한다.

각 선수들은 토너먼트 대진표 상의 순서대로 $1$번부터 $2^n$번까지 번호가 매겨져 있다.

즉, 토너먼트의 첫 대진은 $1$번과 $2$번, $3$번과 $4$번, $\dots$ 이렇게 이루어진다.

이때 각 대진의 승패는 다음 규칙에 따라서 결정된다.

- $x$번과 $y$번이 만났을 때, $x + y$가 홀수이면 더 작은 번호가 승리하고, $x + y$가 짝수이면 더 큰 번호가 승리한다.

정수 $n$이 주어질 때, 토너먼트 우승자의 번호를 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 30$)가 주어진다.

각 테스트케이스는 하나의 정수 $n$($1 \leq n \leq 30$)으로 이루어진다.

**[OUTPUT]**

각 테스트케이스에 대해 $2^n$명이 참여하는 토너먼트의 우승자의 번호를 출력한다.

---

### [SOLUTION] Math

먼저 첫 번째 대진에서는 $x + y$가 홀수이기 때문에 번호가 더 작은 쪽이 올라간다.

따라서 홀수 번호 $1, 3, 5, \dots, 2^n - 1$들이 승리하게 된다.

이제 홀수만 남았으므로 항상 $x + y$가 짝수이고, 번호가 더 큰 쪽이 올라간다.

따라서 남은 번호들 중 가장 큰 번호($=2^n - 1$)가 우승자임을 알 수 있다.

```cpp
#include <iostream>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        int ans = 1;
        while (n--) ans *= 2;
        cout << ans - 1 << "\n";
    }
}
```

<br/>

## B. Prove Him Wrong

[B번 문제 링크](https://codeforces.com/contest/1651/problem/B)

**[PROBLEM]**

당신의 친구는 아래와 같은 수열 $a$에 대한 연산을 발견하였다.

- $i \neq j$인 $i, j$를 선택하여 $a_i = a_j = \left\vert a_i - a_j \right\vert$로 수열을 업데이트

친구는 다음과 같은 결론에 도달하였다.

- 길이가 $n$인 모든 정수 수열 $a$($1 \leq a_i \leq 10^9$)에 대해, 연산을 적용했을 때 수열의 전체 합이 감소하는 $(i, j)$가 반드시 존재한다.

당신은 이에 대해 의문을 품고, 친구가 틀렸다는 것을 증명하고자 한다.

정수 $n$이 주어질 때, 친구의 결론에 대한 반례가 존재하는지 판별하고, 반례가 존재한다면 반례를 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 100$)가 주어진다.

각 테스트케이스는 하나의 정수 $n$($2 \leq n \leq 1000$)으로 이루어진다.

**[OUTPUT]**

각 테스트케이스에 대해 반례가 존재하면 "YES", 존재하지 않으면 "NO"를 출력한다.

만약 반례가 존재하면 다음 줄에 아무 반례를 하나 출력한다.

---

### [SOLUTION] Math

찾고자 하는 반례는 모든 $i, j$에 대해 다음을 만족하는 수열이다.

\begin{aligned}
a_i + a_j \leq 2 \cdot \left\vert a_i - a_j \right\vert
\end{aligned}

$a_i \geq a_j$라고 가정하고 부등식을 풀면 다음을 얻을 수 있다.

\begin{aligned}
3 a_j \leq a_i
\end{aligned}

즉, 수열에서 임의의 두 수를 골랐을 때 큰 수가 작은 수의 3배 이상이어야 반례가 된다.

그런데 수의 범위가 $1$부터 $10^9$으로 제한되어 있으므로 $3^{n-1} \leq 10^9$을 만족하는 $n$만 반례가 존재한다.

따라서 $n > 19$이면 반례가 존재하지 않고, $n <= 19$이면 반례가 존재한다.

반례는 $1, 3, 3^2, \dots, 3^{n-1}$이다.

```cpp
#include <iostream>
using namespace std;

int p[19];

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    p[0] = 1;
    for (int i = 1; i < 19; i++) p[i] = 3 * p[i - 1];

    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        if (n >= 20) cout << "NO\n";
        else
        {
            cout << "YES\n";
            for (int i = 0; i < n; i++) cout << p[i] << " ";
            cout << "\n";
        }
    }
}
```

<br/>

## C. Fault-tolerant Network

[C번 문제 링크](https://codeforces.com/contest/1651/problem/C)

**[PROBLEM]**



**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 100$)가 주어진다.

각 테스트케이스는 하나의 정수 $n$($2 \leq n \leq 1000$)으로 이루어진다.

**[OUTPUT]**

각 테스트케이스에 대해 반례가 존재하면 "YES", 존재하지 않으면 "NO"를 출력한다.

만약 반례가 존재하면 다음 줄에 아무 반례를 하나 출력한다.

---

### [SOLUTION] 


