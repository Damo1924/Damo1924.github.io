---
title: "[CF# 11] Educational Codeforces Round #126 (Div. 2)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Codeforces
use_math: true
comments: true

---

`Tags` 

## Result & Review

지난 코포 대회에서 2솔, 코드잼 1라운드 1솔에 그치고 홧김에 참여한 대회.

겨우 두 문제를 풀었는데 심지어 B번은 해킹을 당해서 최종 결과는 6문제 중 1솔이었다..

두 대회 연속으로 망해버리니 점수가 너무 떨어졌다 ㅜ

<br/>

## A. Array Balancing

[A번 문제 링크](https://codeforces.com/contest/1661/problem/A)

**[PROBLEM]**

길이가 $n$인 두 수열 $a_1, a_2, \dots, a_n$과 $b_1, b_2, \dots, b_n$이 주어진다.

두 수열에 대해 아래 연산을 원하는 만큼 수행할 수 있다.

- $1 \leq i \leq n$인 정수 $i$를 선택하여 $a_i$와 $b_i$를 교환한다.

이때 $\sum_{i=1}^{n-1} \left( \left\vert a_i - a_{i+1} \right\vert + \left\vert b_i - b_{i+1} \right\vert \right)$의 최솟값을 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 4000$)가 주어진다.

각 각 테스트케이스의 첫 번째 줄에는 정수 $n$($2 \leq n \leq 25$)가 주어진다.

두 번째 줄에는 $n$개의 정수 $a_1, a_2, \dots, a_n$($1 \leq a_i \leq 10^9$)이 주어진다.

세 번째 줄에는 $n$개의 정수 $b_1, b_2, \dots, b_n$($1 \leq b_i \leq 10^9$)이 주어진다.

**[OUTPUT]**

각 테스트케이스에 대해 $\sum_{i=1}^{n-1} \left( \left\vert a_i - a_{i+1} \right\vert + \left\vert b_i - b_{i+1} \right\vert \right)$의 최솟값을 출력한다.

---

### [SOLUTION] Greedy

모든 $i$에 대해 $a_i \leq b_i$를 만족하도록 만들 때 최솟값을 얻을 수 있다.

```cpp
#include <iostream>
#include <vector>
#include <math.h>
using namespace std;
typedef long long ll;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        vector<int> a(n), b(n);
        for (int i = 0; i < n; i++) cin >> a[i];
        for (int i = 0; i < n; i++) cin >> b[i];
        
        for (int i = 0; i < n; i++) if (a[i] > b[i]) swap(a[i], b[i]);
        
        ll ans = 0;
        for (int i = 1; i < n; i++) ans += abs(a[i - 1] - a[i]) + abs(b[i - 1] - b[i]);
        cout << ans << "\n";
    }
}
```

<br/>

## B. Getting Zero

[B번 문제 링크](https://codeforces.com/contest/1661/problem/B)

**[PROBLEM]**

정수 $v$에 대해 다음 두 연산을 수행할 수 있다.

- $v = (v + 1) \bmod 32768$
- $v = (2 \cdot v) \bmod 32768$

$n$개의 정수 $a_1, a_2, \dots, a_n$이 주어질 때, 각 $a_i$를 $0$으로 만드는데 필요한 최솟한의 연산 횟수를 구하여라.

**[INPUT]**

첫 번째 줄에 정수 $n$($1 \leq n \leq 32768$)이 주어진다.

두 번째 줄에는 $n$개의 정수 $a_1, a_2, \dots, a_n$($0 \leq a_i < 32768$)이 주어진다.

**[OUTPUT]**

모든 $i$에 대해 $a_i$를 $0$으로 만드는데 필요한 최솟한의 연산 횟수를 출력한다.

---

### [SOLUTION 1] Greedy

$32768 = 2^{15}$이므로 주어진 정수 $a_i$에 $+1$ 또는 $\times 2$를 해서 $2^{15}$의 배수로 만드는 것이 목표이다.

이때, $\times 2$ 다음에 $+1$을 두 번하는 것은 $+1$을 한 뒤 $\times 2$를 수행한 것과 동일하다.

- $v \to 2v \to 2v + 1 \to 2v + 2$ : 3번
- $v \to v + 1 \to 2v + 2$ : 2번

따라서 $\times 2$ 다음에 $+1$은 최대 한 번까지만 수행할 수 있다.

이를 이용하면 주어진 정수 $v$가 홀수일 때 택할 수 있는 전략은 두 가지뿐임을 알 수 있다.

1. $\times 2$: $15$번
2. $+ 1$: 홀수 번 $\to$ $\times 2$: 필요한 만큼

그 이유는 $2$를 곱해준 뒤에 $1$을 더하면 다시 홀수로 돌아가기 때문이다.

이를 $v$가 짝수일 때에 적용하면,

1. $\times 2$: 필요한 만큼
2. $+ 1$: 짝수 번 $\to$ $\times 2$: 필요한 만큼

가 되고, 따라서 최소한의 연산을 통해 $0$을 만드는 방법은 $1$을 먼저 더해주고, $2$를 곱하는 것임을 알 수 있다.

최소 연산 횟수의 최댓값이 $15$라는 점을 이용하면, 정수 $v$에 $+1$을 $15$번까지 해가며 최소 연산 횟수를 구하면 된다.

```cpp
#include <iostream>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int n; cin >> n;
    while (n--)
    {
        int a, ans = 15; cin >> a;
        for (int i = 0; i <= 15; i++)
        {
            int k = 0;
            while ((a << k) % 32768) k++;
            ans = min(ans, i + k);
            a++;
        }
        cout << ans << " ";
    }
}
```

---

### [SOLUTION 2] BFS

이 문제는 그리디 외에도 다양한 방법으로 풀 수 있다.

대표적으로 $0$부터 시작해서 다른 수를 만드는데 몇 번의 연산이 필요한지 BFS를 통해 구하는 방법이 있다.

$+1$은 $-1$로, $\times 2$는 $\div 2$로 바꾸어서 역으로 구해준다.

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    vector<int> dp(32768, 15);
    queue<pair<int, int>> q;
    q.push({ 0, 0 });
    while (!q.empty())
    {
        auto [v, cnt] = q.front();
        q.pop();
        
        if (dp[v] <= cnt) continue;
        dp[v] = cnt;
        
        if (v == 0) v = 32768;
        q.push({ v - 1, cnt + 1 });
        if (v % 2 == 0)
        {
            q.push({ v / 2, cnt + 1 });
            q.push({ v / 2 + 16384, cnt + 1 });
        }
    }
    
    int n; cin >> n;
    while (n--)
    {
        int a; cin >> a;
        cout << dp[a] << " ";
    }
}
```

<br/>

## C. Water the Trees

[C번 문제 링크](https://codeforces.com/contest/1661/problem/C)

**[PROBLEM]**

공원에 $n$개의 나무가 있고, $i$번째 나무의 높이는 $h_i$이다.

하루에 한 번씩 선택한 나무에 물을 주어 해당 나무를 자라게 할 수 있는데,

만약 홀수 번째 날이면 $1$만큼 자라고, 짝수 번째 날이면 $2$만큼 자란다.

물론 물을 안 주고 넘어갈 수도 있다.

이때 모든 나무의 높이가 같아지도록 만들기 위해 걸리는 최소한의 기간을 구하여라.

**[INPUT]**

첫 번째 줄에 테스트케이스의 개수 $t$($1 \leq t \leq 2 \cdot 10^4$)가 주어진다.

각 테스트케이스의 첫 번째 줄에는 정수 $n$($1 \leq n \leq 3 \cdot 10^5$)이 주어진다.

두 번째 줄에는 $n$개의 정수 $h_1, h_2, \dots, h_n$($0 \leq h_i \leq 10^9$)이 주어진다.

**[OUTPUT]**

각 테스트케이스에 대해 모든 나무의 높이가 같아지도록 만드는데 필요한 최소한의 기간을 출력한다.

---

### [SOLUTION] Greedy








