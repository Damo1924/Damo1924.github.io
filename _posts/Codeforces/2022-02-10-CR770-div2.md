---
title: "[CF#2] Codeforces Round #770 (Div. 2, except F)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Codeforces
use_math: true
comments: true

---

`Tags` 

## Result & Review

D번은 커녕 B번도 풀지 못했다 ㅜㅜ

상처뿐인 대회..

<img src="https://user-images.githubusercontent.com/88201512/159196043-245f5367-ef0d-4bcd-9c7c-01a2ed7d6137.jpg">

<br/>

## A. Reverse and Concatenate

[A번 문제 링크](https://codeforces.com/contest/1634/problem/A)

**[PROBLEM]**

길이가 $n$인 문자열 $s$가 주어진다.

$rev(s)$를 문자열 $s$를 뒤집은 문자열이라고 정의할 때, 주어진 문자열에 대해 다음 두 가지 연산을 적용할 수 있다.

- $s$를 $s + rev(s)$로 바꾼다.
- $s$를 $rev(s) + s$로 바꾼다.

주어진 문자열 $s$에 위 연산을 정확히 $k$번 적용해서 얻을 수 있는 서로 다른 문자열의 개수를 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 100$)가 주어진다.

각 테스트케이스의 첫 번째 줄에는 두 정수 $n, k$($1 \leq n \leq 100$, $0 \leq k \leq 1000$)이 주어진다.

두 번째 줄에는 길이가 $n$인 문자열 $s$가 주어진다.

**[OUTPUT]**

각 테스트케이스에 대해 $s$에 연산을 $k$번 수행했을 때 얻을 수 있는 서로 다른 문자열의 개수를 출력한다.

---

### [SOLUTION] Math

다음 두 가지 사실을 이용하면 굉장히 간단하게 해결할 수 있다.

- 대칭인 문자열($s = rev(s)$)은 두 연산을 수행한 결과가 동일하다.
- 임의의 문자열 $s$에 두 연산을 수행하면 대칭인 문자열이 된다.

따라서 얻을 수 있는 서로 다른 문자열의 개수는 $k$와 무관하며, 주어진 문자열 $s$가 대칭이면 $1$개, 아니면 $2$개이다.

```cpp
#include <iostream>
#include <algorithm>
#include <string>
using namespace std;

string rev(string s) {
	reverse(s.begin(), s.end());
	return s;
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL);

	int t; cin >> t;
	while (t--)
	{
		int n, k; cin >> n >> k;
		string s; cin >> s;
		if (k == 0 || s == rev(s)) cout << "1\n";
		else cout << "2\n";
	}
}
```

<br/>

## B. Fortune Telling

[B번 문제 링크](https://codeforces.com/contest/1634/problem/B)

**[PROBLEM]**

길이가 $n$이고 음이 아닌 정수로 이루어진 수열 $a$와 음이 아닌 정수 $d$에 대해 다음 두 연산 중 하나를 선택해 수행한다.

- $d$를 $d + a_i$로 바꾼다.
- $d$를 $d \oplus a_i$로 바꾼다.($\oplus$는 bitwise XOR 연산을 의미한다.)

앨리스는 $d = x$, 밥은 $d = x + 3$으로 시작한다.

각 $i = 1, 2, \dots, n$에 대해 각자 두 연산 중 하나를 선택하여 수행한 결과, 둘 중 한 명만 $y$를 얻었다는 사실을 알게 되었다.

$x, y$가 주어질 때, 누가 $y$를 얻었는지 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 10^4$)가 주어진다.

각 테스트케이스의 첫 번째 줄에는 세 정수 $n, x, y$($1 \leq n \leq 10^5$, $0 \leq x \leq 10^9$, $0 \leq y \leq 10^{15}$)이 주어진다.

두 번째 줄에는 길이가 $n$인 수열 $a$($0 \leq a_i \leq 10^9$)가 주어진다.

**[OUTPUT]**

각 테스트케이스에 대해 누가 $y$를 얻을 수 있는지 출력한다.

---

### [SOLUTION] Math

두 연산은 다음과 같은 공통점을 가지고 있다.

- $d, a_i$가 모두 짝수이거나 모두 홀수이면 결과는 짝수이다.
- $d, a_i$가 홀수와 짝수로 이루어져있으면 결과는 홀수이다.

이때 $a_i$는 동일하므로 $d$에 따라서 결과가 홀수인지, 짝수인지 정해지게 된다.

앨리스는 $x$, 밥은 $x + 3$으로 시작하기 때문에 두 사람이 각 단계에서 얻은 결과는 항상 홀짝성이 다르다는 것을 알 수 있다.

따라서 $x$부터 시작해서 얻은 결과의 홀짝성이 $y$의 홀짝성과 같다면 답은 앨리스이고, 홀짝성이 다르다면 답은 밥이다.

```cpp
#include <iostream>
using namespace std;
typedef long long ll;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int t; cin >> t;
    while (t--)
    {
        ll n, x, y; cin >> n >> x >> y;
        for (int i = 0; i < n; i++)
        {
            int a; cin >> a;
            x += a;
        }
        if ((x % 2) == (y % 2)) cout << "Alice\n";
        else cout << "Bob\n";
    }
}
```

<br/>

## C. OKEA

[C번 문제 링크](https://codeforces.com/contest/1634/problem/C)

**[PROBLEM]**

어떤 가게에서 $n \cdot k$개의 물건을 팔고 있는데, $i$번째 물건의 가격이 $i$라고 한다.

이 물건들을 $n \times k$ 크기의 선반에 놓으려고 한다.

$i$($1 \leq i \leq n$)행 $j$($1 \leq j \leq k$)열에 있는 물건의 가격을 $a_{i, j}$라고 하자.

다음 조건을 만족하도록 선반에 물건들을 배치할 수 있는지 판단하고, 가능하다면 아무 예시나 출력하여라.

- $1$부터 $n \cdot k$까지의 모든 정수가 한 번씩 나타난다.
- 모든 $i, l, r$($l \leq r$)에 대해 $a_{i, l}, a_{i, l + 1}, \dots, a_{i, r}$의 평균이 정수이다.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 500$)가 주어진다.

각 테스트케이스는 두 정수 $n, k$($1 \leq n, k \leq 500$)로 이루어져있다.

**[OUTPUT]**

각 테스트케이스에 대해 조건을 만족하도록 물건들을 배치하는 것이 불가능하면 "NO"를 출력한다.

조건을 만족하도록 물건들을 배치하는 것이 가능하다면 "YES"를 출력하고, 물건들을 배치하는 방법을 출력한다.

---

### [SOLUTION] Constructive algorithm

$k = 1$이면 아무렇게나 배치해도 항상 조건을 만족한다.

$k > 1$인 경우는 각 행에 있는 물건들이 모두 홀수이거나 모두 짝수여야한다.

따라서 $k > 1$이면서 $n$이 홀수이면 조건을 만족하도록 배치하는 것이 불가능하다.

이제 $k > 1$이고 $n$이 짝수인 경우에 대해 다음과 같은 배치를 생각해보자.

> 첫 $\frac{n}{2}$행에 홀수를 순서대로 배치하고 나머지 행에 짝수를 순서대로 배치한다.
> 
> $a_{i, j}$($1 \leq i \leq \frac{n}{2}$, $1 \leq j \leq k$) $= 2k(i - 1) + 2j - 1$
> 
> $a_{i, j}$($\frac{n}{2} < i \leq n$, $1 \leq j \leq k$) $= 2k(i - \frac{n}{2} - 1) + 2j$

홀수로 이루어진 행의 평균을 구해보면,

\begin{aligned}
\frac{1}{r - l} \sum_{j = l}^r a_{i, j} = 2k(i - 1) - 1 + \frac{2}{r - l} \sum_{j = l}^r j
\end{aligned}

이므로 항상 정수임을 알 수 있다.

짝수로 이루어진 행의 평균은,

\begin{aligned}
\frac{1}{r - l} \sum_{j = l}^r a_{i, j} = 2k(i - \frac{n}{2} - 1) + \frac{2}{r - l} \sum_{j = l}^r j
\end{aligned}

이므로 마찬가지로 항상 정수이다.

따라서 $k > 1$이고 $n$이 짝수이면 항상 조건을 만족하도록 배치하는 것이 가능하다.

```cpp
#include <iostream>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int t; cin >> t;
    while (t--)
    {
        int n, k; cin >> n >> k;
        if (k == 1)
        {
            cout << "YES\n";
            for (int i = 1; i <= n; i++) cout << i << "\n";
        }
        else if (n % 2) cout << "NO\n";
        else
        {
            cout << "YES\n";
            for (int i = 1; i <= n / 2; i++)
            {
                for (int j = 1; j <= k; j++) cout << 2 * k * (i - 1) + 2 * j - 1 << " ";
                cout << "\n";
            }
            for (int i = 1; i <= n / 2; i++)
            {
                for (int j = 1; j <= k; j++) cout << 2 * k * (i - 1) + 2 * j << " ";
                cout << "\n";
            }
        }
    }
}
```

<br/>

## D. Finding Zero

[D번 문제 링크](https://codeforces.com/contest/1634/problem/D)

**[PROBLEM]**

> **Interactive problem**

길이가 $n$인 수열 $a_1, a_2, \dots, a_n$($0 \leq a_i \leq 10^9$)에 정확히 하나의 $0$이 있다.

이 문제의 목표는 $0$의 위치, 즉 $a_i = 0$인 $i$를 찾는 것이다.

이를 알아내기 위해 최대 $2 \cdot (n-2)$개의 다음과 같은 질문을 할 수 있다.

- Query: $i$ $j$ $k$
- Answer: $\max(a_i, a_j, a_k) - \min(a_i, a_j, a_k)$

질문들에 대한 답을 토대로 $0$의 위치를 맞출 수 있는 기회가 두 번 주어진다.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 500$)가 주어진다.

각 테스트케이스는 정수 $n$($4 \leq n \leq 1000$)로 이루어져있다.

**[OUTPUT]**

질문을 하기 위해서 "? $i$ $j$ $k$"을 출력한다.

그러면 $\max(a_i, a_j, a_k) - \min(a_i, a_j, a_k)$가 입력으로 주어진다.

만약 질문에 대한 답이 $-1$이면 최대 질문 횟수를 초과하였거나 유효하지 않은 질문이 들어왔다는 것을 의미한다.

최종 답은 "! $i$ $j$"의 형태로 출력한다.

단, 출력한 후에 output buffer를 flush해주어야한다.

> `fflush(stdout)` 또는 `cout.flush()`를 이용한다.

---

### [SOLUTION] Constructive algorithm

$a_1, a_2, a_3, a_4$가 $a_1 \leq a_2 \leq a_3 \leq a_4$를 만족한다고 하자.

이 네 정수에 대해 할 수 있는 질문은 총 네 개이고, 각 질문에 대답은 다음과 같다.

- $(1, 2, 3)$: $a_3 - a_1$
- $(2, 3, 4)$: $a_4 - a_2$
- $(1, 2, 4)$: $a_4 - a_1$
- $(1, 3, 4)$: $a_4 - a_1$

위 결과에서 $a_3 - a_1 \leq a_4 - a_1$, $a_4 - a_2 \leq a_4 - a_1$가 성립하므로, 다음과 같은 결론을 내릴 수 있다.

> 네 정수에 대해 네 질문을 했을 때 나올 수 있는 대답의 종류는 세 가지이다.
> 
> 1. $(x, x, x, x)$
> 2. $(x, y, y, y)$ ($x < y$)
> 3. $(x, y, z, z)$ ($x < y < z$)
> 
> 전체 수열에서 $0$은 딱 하나뿐이라는 것을 이용하면 각 대답으로부터 다음과 같은 사실을 알 수 있다.
> 
> 1. **네 정수 중 $0$이 없다.**
> 2. **$x$가 나온 질문의 세 정수는 모두 $0$이 아니다.**
> 3. **$z$가 나온 질문에 포함되지 않은 정수는 $0$이 아니다.**

따라서 우리는 네 수 중 확실히 $0$이 아닌 수를 적어도 두 개 찾아낼 수 있다.

정답을 맞출 수 있는 기회가 총 두 번 주어지기 때문에 우리는 $0$이 아닌 수를 최소 $n - 2$개 찾아야한다.

$n = 2k$이면 $2k - 2$개의 $0$이 아닌 수를 찾아야하므로 최대 $4(k - 1) = 2n - 4$개의 질문을 해야한다.

$n = 2k + 1$이면 $2k - 1$개의 $0$이 아닌 수를 찾아야하므로 최대 $4(k + 1) = 2n - 2$개의 질문을 해야한다.

따라서 모든 $n$에 대해서 $2n - 2$개의 질문을 통해서 반드시 답을 구할 수 있음을 알 수 있다.












