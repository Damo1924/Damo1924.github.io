---
title: "[CF# 12] Codeforces Round #783 (Div. 2, except F)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Codeforces
use_math: true
comments: true

---

`Tags` 

## Result & Review

지난 두 대회를 처참하게 망해서 마음을 비우고 참여했다.

다행히(?) 이번에는 앞 세 문제까지는 빠르게 풀었는데, 아쉽게도 남은 시간 동안 D, E를 조금씩 건드려보다가 끝났다.

나름 E번은 아이디어가 나쁘지 않았던 것 같았는데, 더 최적인 방법이 있었다.

세 문제밖에 풀지 못했지만 600등 정도로 마무리했는데, 아마 D, E번을 푼 사람이 매우 적다보니 A, B, C 타임어택이 된 듯 하다.

다시 파랭이로 돌아왔다 ㅜㅜ

<br/>

## A. Direction Change

[A번 문제 링크](https://codeforces.com/contest/1668/problem/A)

**[PROBLEM]**

크기가 $n \times m$인 직사각형이 주어지며, 직사각형은 $1 \times 1$ 크기의 정사각형으로 나누어져있다.

가장 왼쪽 위 정사각형을 $(1, 1)$, 가장 오른쪽 아래 정사각형을 $(n, m)$이라고 할 때, $(1, 1)$에서 $(n, m)$까지의 최단경로를 구하려고 한다.

한 정사각형에서 인접한 다른 정사각형으로 이동할 수 있는데, 같은 방향으로 두 번 연속 움직이는 것은 불가능하다.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 10^3$)가 주어진다.

각 테스트케이스는 두 정수 $n, m$($1 \leq n, m \leq 10^9$)로 이루어져 있다.

**[OUTPUT]**

각 테스트케이스에 대해 같은 방향으로 두 번 연속으로 움직이지 않을 때 $(1, 1)$에서 $(n, m)$까지의 최단 경로의 길이를 출력한다.

---

### [SOLUTION] Math

같은 방향으로 연속하여 이동하지 못한다는 조건이 없다면 최단 경로의 길이는 $(n-1) + (m-1)$이다.

$n = m$인 경우, 오른쪽 방향과 아래 방향으로 번갈아가며 이동하면 최단 경로의 길이는 $(n-1) + (m-1)$이다.

$n < m$인 경우, $2(n-1)$번 이동해서 $(n, n)$에 도달한 다음 추가로 오른쪽으로 $m-n$번 이동해야한다.

같은 방향으로 연속하여 이동할 수 없기 때문에 $m-n$번의 오른쪽 방향 사이사이에 위, 아래 방향을 끼워넣어야한다.

두 정수 $n, m$($n < m$, $n \neq 1$)에 대한 최단 경로의 길이는 다음과 같다.

\begin{aligned}
n + m - 2 + 2 \left\lfloor \frac{m-n}{2} \right\rfloor
\end{aligned}

단, $n = 1$인 경우는 이동할 수 있는 방향이 두 개밖에 없기 때문에 따로 예외 처리를 해주어야한다.

```cpp
#include <iostream>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int t; cin >> t;
    while (t--)
    {
        int n, m; cin >> n >> m;
        if (n > m) swap(n, m);
        
        if (n == 1)
        {
            if (m <= 2) cout << m - 1 << "\n";
            else cout << "-1\n";
        }
        else cout << m + n - 2 + (m - n) / 2 * 2 << "\n";
    }
}
```

<br/>

## B. Social Distance

[B번 문제 링크](https://codeforces.com/contest/1668/problem/B)

**[PROBLEM]**

$m$개의 의자가 원형 탁자 주위에 배치되어 있다.

의자들은 $0$부터 $m-1$까지의 번호가 매겨져 있고, $n$명의 사람들이 의자에 앉으려고 한다.

$i$번째 사람은 양옆으로 적어도 $a_i$개의 의자가 비어 있어야한다.

이때 모든 사람들이 의자에 앉는 것이 가능한지 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 5 \cdot 10^4$)가 주어진다.

각 테스트케이스의 첫 번째 줄에는 두 정수 $n, m$($2 \leq n \leq 10^5, 1 \leq m \leq 10^9$)가 주어진다.

두 번째 줄에는 $n$개의 정수 $a_1, a_2, \dots, a_n$($1 \leq a_i \leq 10^9$)가 주어진다.

**[OUTPUT]**

각 테스트케이스에 대해 모든 사람들이 의자에 앉는 것이 가능하면 "YES", 불가능하면 "NO"를 출력한다.

---

### [SOLUTION] Greedy

어떤 순서로 사람들을 앉혀야지 모든 사람들이 앉을 수 있기 위해 필요한 의자의 수가 최소가 되는지 알아내야한다.

의자에 앉은 순서대로 $a_1, a_2, \dots, a_n$의 순서를 바꾼 것을 $b_1, b_2, \dots, b_n$이라고 하면, 필요한 의자의 수는 다음과 같다.

(앞으로 사용할 수식에서 $i \equiv j \pmod{m}$이면 $b_i = b_j$로 생각)

\begin{aligned}
n + \sum_{i = 1}^{m} \max(b_i, b_{i+1})
\end{aligned}

위 식에서 $\sum_{i = 1}^{m} \max(b_i, b_{i+1})$의 값은 $b_1, \dots, b_n$ 중 $n$개를 선택해서 합한 것이라고 생각할 수 있다.

각 $b_i$가 몇 번씩 등장할 수 있는지 구해보자.

어떤 $b_i$가 한 번도 등장하지 않기 위해서는 $b_{i-1} > b_i$, $b_{i+1} > b_i$을 만족해야한다.

그런데 위와 같은 배치는 $b_i$를 $b_{i-1}$ 또는 $b_{i+1}$와 바꾸어주면 항상 $\sum_{i = 1}^{m} \max(b_i, b_{i+1})$의 값이 감소한다.

따라서 항상 등장할 수 없는 최솟값을 제외하고는 적어도 한 번씩은 등장해야함을 알 수 있다.

그런데 최댓값은 반드시 두 번 등장하므로, 최댓값과 최솟값을 제외한 $n-2$개의 수가 한 번씩 등장하면 $n$자리가 모두 채워지게 된다.

그러므로 최댓값을 두 번 더하고, 최댓값과 최솟값을 제외한 수들을 한 번씩 더한 것이 $\sum_{i = 1}^{m} \max(b_i, b_{i+1})$의 최솟값이다.

> 단, 최솟값을 얻도록 사람들을 탁자 주위에 배치하는 방법이 $a_i$의 크기순으로 정렬한 것뿐인 것은 아니다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
typedef long long ll;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int t; cin >> t;
    while (t--)
    {
        ll n, m; cin >> n >> m;
        vector<int> a(n);
        for (int i = 0; i < n; i++) cin >> a[i];
        sort(a.begin(), a.end());
        
        ll empty = max(a.back(), a[0]);
        for (int i = 1; i < n; i++) empty += max(a[i - 1], a[i]);
        if (empty + n <= m) cout << "YES\n";
        else cout << "NO\n";
    }
}
```

<br/>

## C. Make it Increasing

[C번 문제 링크](https://codeforces.com/contest/1668/problem/C)

**[PROBLEM]**

$n$개의 양의 정수로 이루어진 수열 $a$와 길이가 $n$이고 모든 $1 \leq i \leq n$에 대해 $b_i = 0$인 수열 $b$가 주어진다.

두 수열에 대해 다음 연산을 수행할 수 있다.

- 정수 $i$($1 \leq i \leq n$)을 선택하여 $b_i$에 $a_i$를 더하거나 $a_i$를 빼준다.

이때 수열 $b$가 단조 증가(strictly increasing)하기 위해 필요한 연산 횟수의 최솟값을 구하여라.

**[INPUT]**

첫 번째 줄에는 정수 $n$($2 \leq n \leq 5000$)이 주어진다.

두 번째 줄에는 $n$개의 정수 $a_1, a_2, \dots, a_n$($1 \leq a_i \leq 10^9$)이 주어진다.

**[OUTPUT]**

수열 $b$가 단조 증가(strictly increasing)하기 위해 필요한 연산 횟수의 최솟값을 출력한다.

---

### [SOLUTION] Greedy

이 문제는 반드시 최종 $b_i$ 중 반드시 $0$이 존재한다는 사실을 이용하면 쉽게 풀 수 있다.

최종 수열 $b$는 단조 증가이므로 $0$은 유일하다.

따라서 각 $b_i$를 $0$으로 고정하여 최소 연산 횟수를 구하고, 그 중 최솟값을 출력하면 된다.

```cpp
#include <iostream>
#include <vector>
using namespace std;
typedef long long ll;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int n; cin >> n;
    vector<ll> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    
    ll ans = 1e18;
    for (int i = 0; i < n; i++) // b_i = 0
    {
        ll res = 0, b = 0;
        for (int j = i - 1; j >= 0; j--)
        {
            res += (b / a[j] + 1);
            b = (b / a[j] + 1) * a[j];
        }
        b = 0;
        for (int j = i + 1; j < n; j++)
        {
            res += (b / a[j] + 1);
            b = (b / a[j] + 1) * a[j];
        }
        ans = min(ans, res);
    }
    cout << ans;
}
```

<br/>

## D. Optimal Partition

[D번 문제 링크](https://codeforces.com/contest/1668/problem/D)

**[PROBLEM]**

$n$개의 정수로 이루어진 수열 $a$가 주어진다.

$a$의 부분수열 $a_l, a_{l+1}, \dots, a_r$에 대해 $s = a_l + \dots + a_r$라고 하자.

이 부분수열에 해당하는 값은 다음과 같다.

- $s > 0$ : $r - l + 1$
- $s = 0$ : $0$
- $s < 0$ : $-(r - l + 1)$

수열 $a$를 여러 개의 부분수열로 나누었을 때, 부분수열들의 값을 모두 더한 것의 최댓값을 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 5 \cdot 10^5$)이 주어진다.

테스트케이스의 첫 번째 줄에는 정수 $n$($1 \leq n \leq 5 \cdot 10^5$)이 주어진다.

두 번째 줄에는 $n$개의 정수 $a_1, a_2, \dots, a_n$($-10^9 \leq a_i \leq 10^9$)이 주어진다.

**[OUTPUT]**

각 테스트케이스에 대해 수열 $a$를 여러 개의 부분수열로 나누었을 때, 부분수열들의 값을 모두 더한 것의 최댓값을 출력한다.

---

### [SOLUTION] DP + Segment Tree

$a_1, \dots, a_i$에 대해 구한 문제의 답을 $dp_i$라고 하고,

$a_l, \dots, a_r$의 값을 $v_{l, r}$라고 할 때, $dp_i$는 다음과 같이 구할 수 있다.

\begin{aligned}
dp_i = \max_{0 \leq j < i} (dp_j + v_{j+1, i})
\end{aligned}

이때 $dp_0 = 0$이다.

위와 같이 $dp_i$를 구하면 $O(n^2)$이므로, 좀 더 효율적인 방법이 필요하다.

부분수열들을 값에 따라서 양의 부분수열, 음의 부분수열, 0의 부분수열이라고 하자.

> 전체 수열을 나누어서 얻은 부분수열들 중 길이가 2 이상인 것이 음의 부분수열이거나 0의 부분수열이면, 해당 partition은 최댓값을 가지지 못한다.

즉, 부분수열들 중 길이가 2 이상인 것들이 모두 양의 부분수열이어야 최댓값을 가질 수 있다는 것이다.

이를 증명해보자.

> **Proof.**
> 
> 길이가 2 이상인 음의 부분수열을 길이가 $1$인 부분수열들로 쪼개면, 부분수열들의 값의 합이 그대로이거나 더 커지게 된다.
> 
> (합이 그대로인 최악의 경우는 음의 부분수열을 이루는 모든 원소가 음수인 경우)
> 
> 길이가 2 이상인 0의 부분수열은 길이가 짝수인 것과 홀수인 것으로 나누자.
> 
> 길이가 홀수인 것은 








