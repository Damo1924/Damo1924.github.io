---
title: "[CF# 12] Codeforces Round #783 (Div. 2, except F)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Codeforces
use_math: true
comments: true

---

`Tags` 

## Result & Review

지난 두 대회를 처참하게 망해서 마음을 비우고 참여했다.

다행히(?) 이번에는 앞 세 문제까지는 빠르게 풀었는데, 아쉽게도 남은 시간 동안 D, E를 조금씩 건드려보다가 끝났다.

나름 E번은 아이디어가 나쁘지 않았던 것 같았는데, 더 최적인 방법이 있었다.

세 문제밖에 풀지 못했지만 600등 정도로 마무리했는데, 아마 D, E번을 푼 사람이 매우 적다보니 A, B, C 타임어택이 된 듯 하다.

다시 파랭이로 돌아왔다 ㅜㅜ

<br/>

## A. Direction Change

[A번 문제 링크](https://codeforces.com/contest/1668/problem/A)

**[PROBLEM]**

크기가 $n \times m$인 직사각형이 주어지며, 직사각형은 $1 \time 1$ 크기의 정사각형으로 나누어져있다.

가장 왼쪽 위 정사각형을 $(1, 1)$, 가장 오른쪽 아래 정사각형을 $(n, m)$이라고 할 때, $(1, 1)$에서 $(n, m)$까지의 최단경로를 구하려고 한다.

한 정사각형에서 인접한 다른 정사각형으로 이동할 수 있는데, 같은 방향으로 두 번 연속 움직이는 것은 불가능하다.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 10^3$)가 주어진다.

각 테스트케이스는 두 정수 $n, m$($1 \leq n, m \leq 10^9$)로 이루어져 있다.

**[OUTPUT]**

각 테스트케이스에 대해 같은 방향으로 두 번 연속으로 움직이지 않을 때 $(1, 1)$에서 $(n, m)$까지의 최단 경로의 길이를 출력한다.

---

### [SOLUTION] Math

같은 방향으로 연속하여 이동하지 못한다는 조건이 없다면 최단 경로의 길이는 $(n-1) + (m-1)$이다.

$n = m$인 경우, 오른쪽 방향과 아래 방향으로 번갈아가며 이동하면 최단 경로의 길이는 $(n-1) + (m-1)$이다.

$n < m$인 경우, $2(n-1)$번 이동해서 $(n, n)$에 도달한 다음 추가로 오른쪽으로 $m-n$번 이동해야한다.

같은 방향으로 연속하여 이동할 수 없기 때문에 $m-n$번의 오른쪽 방향 사이사이에 위, 아래 방향을 끼워넣어야한다.

두 정수 $n, m$($n < m$, $n \neq 1$)에 대한 최단 경로의 길이는 다음과 같다.

\begin{aligned}
n + m - 2 + 2 \left\lfloor \frac{m-n}{2} \right\rfloor
\end{aligned}

단, $n = 1$인 경우는 이동할 수 있는 방향이 두 개밖에 없기 때문에 따로 예외 처리를 해주어야한다.

```cpp
#include <iostream>
using namespace std;


```


