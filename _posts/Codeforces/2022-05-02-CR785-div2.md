---
title: "[CF #14] Codeforces Round #785 (Div. 2, except F)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Coding Contest
use_math: true
comments: true

---

`Tags` 

## Result & Review

세 문제밖에 풀지 못했지만, 꽤 재미있던 라운드였다.

<br/>

## A. Subtle Substring Subtraction

[A번 문제 링크](https://codeforces.com/contest/1673/problem/A)

엘리스와 밥은 알파벳 소문자로 이루어진 문자열을 가지고 게임을 한다.

엘리스는 짝수 길이의 부분문자열을 제거할 수 있고, 밥은 홀수 길이의 부분문자열을 제거할 수 있다.

항상 엘리스부터 먼저 시작하며, 주어진 문자열이 비어있게 되면 라운드가 종료된다.

'a'를 1점, 'b'를 2점, ..., 'z'를 26점으로 계산해서 점수가 높은 사람이 승리하게 된다.

두 사람이 최적의 방법으로 플레이할 때, 각 라운드마다 이기는 사람이 누구인지, 그리고 두 사람의 점수 차이가 얼마인지 구하여라.

---

### [SOLUTION] Greedy

음수 점수가 없고 두 사람이 최적의 방법으로 플레이하므로, 두 사람은 자신에 차례에 가져갈 수 있는 만큼 최대로 가져가게 된다.

주어진 문자열의 길이가 짝수이면 엘리스가 전체 문자열을 제거할 수 있으므로, 항상 엘리스가 승리하며 점수차는 전체 문자열의 합이다.

주어진 문자열의 길이가 홀수($=n$)이면 엘리스가 $n-1$만큼 제거한 후, 밥이 남은 하나의 문자를 제거하게 된다.

엘리스는 앞 또는 뒤에서부터 $n-1$개를 택할 수도 있는데, 둘 중 더 큰 점수를 얻을 수 있는 방법을 택하도록 한다.

```cpp
#include <iostream>
#include <string>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        string s; cin >> s;
        int sum = 0;
        for (int i = 0; i < s.size(); i++) sum += s[i] - 96; // 'a' = 97
        if (s.size() % 2)
        {
            int b = min(s[0], s.back()) - 96;
            int a = sum - b;
            if (a < b) cout << "Bob " << b - a << "\n";
            else cout << "Alice " << a - b << "\n";
        }
        else cout << "Alice " << sum << "\n";
    }
}
```

<br/>

## B. A Perfectly Balanced String

[B번 문제 링크](https://codeforces.com/contest/1673/problem/B)

**[PROBLEM]**

문자열 $s$에 대하여

- $t$ : non-empty substring of $s$
- $u, v$ : characters present in $s$

라고 하자.

이때 문자열 $s$의 가능한 모든 순서쌍 $(t, u, v)$에 대해 $t$에 있는 $u, v$의 개수의 차이가 $1$보다 작거나 같으면 $s$를 "perfectly balanced"라고 부른다.

알페벳 소문자들로만 이루어진 문자열이 주어질 때, 문자열이 perfectly balanced인지 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 2 \cdot 10^4$)가 주어진다.

각 테스트케이스는 알파벳 소문자로 이루어진 문자열 $s$($1 \leq \left\vert s \right\vert \leq 2 \cdot 10^5$)로 이루어진다.

**[OUTPUT]**

각 테스트케이스에 대해 주어진 문자열이 perfectly balanced이면 "YES", 아니면 "NO"를 출력한다.

---

### [SOLUTION] Greedy

먼저, $s$에 나타나는 알파벳의 개수를 $m$이라고 하자.

길이가 $m$인 부분문자열에 한 알파벳이 두 번 나타나면 다른 한 알파벳이 나타나지 않으므로 조건을 만족하지 않는다.

따라서 **길이가 $m$인 모든 부분문자열은 $s$에 나타나는 알파벳들의 순열**이어야 한다.

위 조건을 만족하는 문자열들은 모두 perfectly balanced인데, 그 이유는 같은 알파벳 사이에 다른 알파벳들이 한 번씩 등장하기 때문이다.

나는 아래와 같이 구현하였다.

- 문자열에 등장하는 알파벳의 개수 $m$을 구한 후, 앞에서부터 $m$개의 문자가 서로 다른지 확인한다.
- 이후 $i$($1 \leq i \leq n - m$)번째 문자와 $i + m$번째 문자가 서로 같은지 확인한다.

시간복잡도는 $O(\left\vert s \right\vert)$이다.

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        string s; cin >> s;
        
        int n = s.size(), m = 0;
        vector<bool> chk(26, 0);
        for (int i = 0; i < n; i++)
            if (!chk[s[i] - 97]) chk[s[i] - 97] = 1, m++;
        
        bool flg = 0;
        for (int i = 0; i < m; i++)
        {
            if (chk[s[i] - 97]) chk[s[i] - 97] = 0;
            else flg = 1;
        }
        for (int i = 0; i < n - m; i++)
            if (s[i] != s[i + m]) flg = 1;
        
        cout << (flg ? "NO" : "YES") << "\n";
    }
}
```

<br/>

## C. Palindrome Basis

[C번 문제 링크](https://codeforces.com/contest/1673/problem/C)

**[PROBLEM]**

양의 정수 $n$이 주어졌을 때, $n$을 펠린드롬인 양의 정수들의 합으로 나타내는 방법의 수를 구하여라.

단, 순서만 다르고 사용한 수가 같다면 동일한 방법으로 생각한다.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 10^4$)가 주어진다.

각 테스트케이스는 한 정수 $n$($1 \leq n \leq 4 \cdot 10^4$)로 이루어진다.

**[OUTPUT]**

각 테스트케이스에 대해 방법의 수를 $10^9 + 7$로 나눈 나머지를 출력한다.

---

### [SOLUTION] DP

백준에서 풀어본 [BOJ. 15989. 1,2,3 더하기 4](https://www.acmicpc.net/problem/15989) 문제의 업그레이드 버전이다.

핵심 포인트는 다음과 같다.

- $40000$ 이하의 자연수 중 펠린드롬인 것은 $498$개뿐이다.
- 펠린드롬 정수들 간에 순서를 고려하지 않으므로 2차원 DP 배열을 사용해야한다.

다음과 같은 DP 배열을 정의하자.

- $dp(i, j)$ : $i$를 $j$번째 펠린드롬까지만 사용해서 표현하는 방법의 수

이때 $j$번째 펠린드롬을 $p_j$라 하며, 이는 펠린드롬들을 오름차순으로 정렬했을 때의 순서이다.

그렇다면 다음과 같은 점화식을 구할 수 있다.

\begin{aligned}
dp(i, j) = dp(i - p_j, 1) + \dots + dp(i - p_j, k) = \sum_{k = 1}^j dp(i - p_j, k)
\end{aligned}

나는 처음에 이 점화식을 그대로 구현했는데, 시간이 굉장히 오래걸렸다.

아무래도 시간복잡도가 $O(n \times p^2)$($p$: $n$ 이하의 펠린드롬의 개수)라서 그럴 수밖에 없었던 것 같다.

시간복잡도를 줄이기 위해 $dp(i, j)$를 **누적합**으로 저장하였다. 즉,

\begin{aligned}
dp'(i, j) = dp(i, 1) + \dots + dp(i, j) = \sum_{k = 1}^j dp(i, k)
\end{aligned}

와 같이 저장하면, $dp(i, j) = dp(i - p_j, j)$로 구할 수 있기 때문에 시간복잡도가 $O(n \times p)$이다.

단, $i$보다 작거나 같은 펠린드롬 수의 개수를 $mx_i$라고 했을 때 $j > mx_i$인 $dp(i, j) = dp(i, mx_i)$임에 주의해야한다.

나는 $dp(i, j) = dp(i - p_j, \min(mx_{i-p_j}, j))$ 와 같이 처리해주었다.

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int MOD = 1e9 + 7;

int p[500], mx[40001];
int dp[40001][500], ans[40001];

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    // get palindrome
    int idx = 1;
    for (int i = 1; i <= 40000; i++)
    {
        mx[i] = mx[i - 1];
        if (i % 10 == 0) continue;
        
        int tmp = i, rev = 0;
        while (tmp > rev)
        {
            rev = rev * 10 + tmp % 10;
            tmp /= 10;
        }
        if (tmp == rev || tmp == rev / 10) p[idx++] = i, mx[i]++;
    }
    
    // get dp
    dp[0][0] = 1;
    for (int i = 1; i <= 40000; i++)
    {
        for (int j = 1; j <= mx[i]; j++)
        {
            dp[i][j] = (dp[i][j] + dp[i - p[j]][min(mx[i - p[j]], j)]) % MOD;
            dp[i][j] = (dp[i][j] + dp[i][j - 1]) % MOD;
        }
        ans[i] = dp[i][mx[i]];
    }

    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        cout << ans[n] << "\n";
    }
}
```

<br/>





