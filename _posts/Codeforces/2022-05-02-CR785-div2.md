---
title: "[CF #14] Codeforces Round #785 (Div. 2, except F)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Coding Contest
use_math: true
comments: true

---

`Tags` 

## Result & Review

세 문제밖에 풀지 못했지만, 꽤 재미있던 라운드였다.

<br/>

## A. Subtle Substring Subtraction

[A번 문제 링크](https://codeforces.com/contest/1673/problem/A)

엘리스와 밥은 알파벳 소문자로 이루어진 문자열을 가지고 게임을 한다.

엘리스는 짝수 길이의 부분문자열을 제거할 수 있고, 밥은 홀수 길이의 부분문자열을 제거할 수 있다.

항상 엘리스부터 먼저 시작하며, 주어진 문자열이 비어있게 되면 라운드가 종료된다.

'a'를 1점, 'b'를 2점, ..., 'z'를 26점으로 계산해서 점수가 높은 사람이 승리하게 된다.

두 사람이 최적의 방법으로 플레이할 때, 각 라운드마다 이기는 사람이 누구인지, 그리고 두 사람의 점수 차이가 얼마인지 구하여라.

---

### [SOLUTION] Greedy

음수 점수가 없고 두 사람이 최적의 방법으로 플레이하므로, 두 사람은 자신에 차례에 가져갈 수 있는 만큼 최대로 가져가게 된다.

주어진 문자열의 길이가 짝수이면 엘리스가 전체 문자열을 제거할 수 있으므로, 항상 엘리스가 승리하며 점수차는 전체 문자열의 합이다.

주어진 문자열의 길이가 홀수($=n$)이면 엘리스가 $n-1$만큼 제거한 후, 밥이 남은 하나의 문자를 제거하게 된다.

엘리스는 앞 또는 뒤에서부터 $n-1$개를 택할 수도 있는데, 둘 중 더 큰 점수를 얻을 수 있는 방법을 택하도록 한다.

```cpp
#include <iostream>
#include <string>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        string s; cin >> s;
        int sum = 0;
        for (int i = 0; i < s.size(); i++) sum += s[i] - 96; // 'a' = 97
        if (s.size() % 2)
        {
            int b = min(s[0], s.back()) - 96;
            int a = sum - b;
            if (a < b) cout << "Bob " << b - a << "\n";
            else cout << "Alice " << a - b << "\n";
        }
        else cout << "Alice " << sum << "\n";
    }
}
```

<br/>

## B. A Perfectly Balanced String

[B번 문제 링크](https://codeforces.com/contest/1673/problem/B)

**[PROBLEM]**

문자열 $s$에 대하여

- $t$ : non-empty substring of $s$
- $u, v$ : characters present in $s$

라고 하자.

이때 문자열 $s$의 가능한 모든 순서쌍 $(t, u, v)$에 대해 $t$에 있는 $u, v$의 개수의 차이가 $1$보다 작거나 같으면 $s$를 "perfectly balanced"라고 부른다.

알페벳 소문자들로만 이루어진 문자열이 주어질 때, 문자열이 perfectly balanced인지 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 2 \cdot 10^4$)가 주어진다.

각 테스트케이스는 알파벳 소문자로 이루어진 문자열 $s$($1 \leq \left\vert s \right\vert 2 \cdot 10^5$)로 이루어진다.

**[OUTPUT]**

---

### [SOLUTION] Greedy

먼저, $s$에 나타나는 알파벳의 개수를 $m$이라고 하자.

길이가 $m$인 부분문자열에 한 알파벳이 두 번 나타나면 다른 한 알파벳이 나타나지 않으므로 조건을 만족하지 않는다.

따라서 **길이가 $m$인 모든 부분문자열은 $s$에 나타나는 알파벳들의 순열**이어야 한다.

위 조건을 만족하는 문자열들은 모두 perfectly balanced인데, 그 이유는 같은 알파벳 사이에 다른 알파벳들이 한 번씩 등장하기 때문이다.

```cpp

```





