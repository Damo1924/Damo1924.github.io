---
title: "[CF #14] Codeforces Round #785 (Div. 2, except F)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Coding Contest
use_math: true
comments: true

---

`Tags` 

## Result & Review

세 문제밖에 풀지 못했지만, 꽤 재미있던 라운드였다.

<br/>

## A. Subtle Substring Subtraction

[A번 문제 링크](https://codeforces.com/contest/1673/problem/A)

엘리스와 밥은 알파벳 소문자로 이루어진 문자열을 가지고 게임을 한다.

엘리스는 짝수 길이의 부분문자열을 제거할 수 있고, 밥은 홀수 길이의 부분문자열을 제거할 수 있다.

항상 엘리스부터 먼저 시작하며, 주어진 문자열이 비어있게 되면 라운드가 종료된다.

'a'를 1점, 'b'를 2점, ..., 'z'를 26점으로 계산해서 점수가 높은 사람이 승리하게 된다.

두 사람이 최적의 방법으로 플레이할 때, 각 라운드마다 이기는 사람이 누구인지, 그리고 두 사람의 점수 차이가 얼마인지 구하여라.

---

### [SOLUTION] Greedy

음수 점수가 없고 두 사람이 최적의 방법으로 플레이하므로, 두 사람은 자신에 차례에 가져갈 수 있는 만큼 최대로 가져가게 된다.

주어진 문자열의 길이가 짝수이면 엘리스가 전체 문자열을 제거할 수 있으므로, 항상 엘리스가 승리하며 점수차는 전체 문자열의 합이다.

주어진 문자열의 길이가 홀수($=n$)이면 엘리스가 $n-1$만큼 제거한 후, 밥이 남은 하나의 문자를 제거하게 된다.

엘리스는 앞 또는 뒤에서부터 $n-1$개를 택할 수도 있는데, 둘 중 더 큰 점수를 얻을 수 있는 방법을 택하도록 한다.

```cpp
#include <iostream>
#include <string>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        string s; cin >> s;
        int sum = 0;
        for (int i = 0; i < s.size(); i++) sum += s[i] - 96; // 'a' = 97
        if (s.size() % 2)
        {
            int b = min(s[0], s.back()) - 96;
            int a = sum - b;
            if (a < b) cout << "Bob " << b - a << "\n";
            else cout << "Alice " << a - b << "\n";
        }
        else cout << "Alice " << sum << "\n";
    }
}
```

<br/>

## B. A Perfectly Balanced String

[B번 문제 링크](https://codeforces.com/contest/1673/problem/B)

**[PROBLEM]**

문자열 $s$에 대하여

- $t$ : non-empty substring of $s$
- $u, v$ : characters present in $s$

라고 하자.

이때 문자열 $s$의 가능한 모든 순서쌍 $(t, u, v)$에 대해 $t$에 있는 $u, v$의 개수의 차이가 $1$보다 작거나 같으면 $s$를 "perfectly balanced"라고 부른다.

알페벳 소문자들로만 이루어진 문자열이 주어질 때, 문자열이 perfectly balanced인지 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 2 \cdot 10^4$)가 주어진다.

각 테스트케이스는 알파벳 소문자로 이루어진 문자열 $s$($1 \leq \left\vert s \right\vert \leq 2 \cdot 10^5$)로 이루어진다.

**[OUTPUT]**

각 테스트케이스에 대해 주어진 문자열이 perfectly balanced이면 "YES", 아니면 "NO"를 출력한다.

---

### [SOLUTION] Greedy

먼저, $s$에 나타나는 알파벳의 개수를 $m$이라고 하자.

길이가 $m$인 부분문자열에 한 알파벳이 두 번 나타나면 다른 한 알파벳이 나타나지 않으므로 조건을 만족하지 않는다.

따라서 **길이가 $m$인 모든 부분문자열은 $s$에 나타나는 알파벳들의 순열**이어야 한다.

위 조건을 만족하는 문자열들은 모두 perfectly balanced인데, 그 이유는 같은 알파벳 사이에 다른 알파벳들이 한 번씩 등장하기 때문이다.

나는 아래와 같이 구현하였다.

- 문자열에 등장하는 알파벳의 개수 $m$을 구한 후, 앞에서부터 $m$개의 문자가 서로 다른지 확인한다.
- 이후 $i$($1 \leq i \leq n - m$)번째 문자와 $i + m$번째 문자가 서로 같은지 확인한다.

시간복잡도는 $O(\left\vert s \right\vert)$이다.

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        string s; cin >> s;
        
        int n = s.size(), m = 0;
        vector<bool> chk(26, 0);
        for (int i = 0; i < n; i++)
            if (!chk[s[i] - 97]) chk[s[i] - 97] = 1, m++;
        
        bool flg = 0;
        for (int i = 0; i < m; i++)
        {
            if (chk[s[i] - 97]) chk[s[i] - 97] = 0;
            else flg = 1;
        }
        for (int i = 0; i < n - m; i++)
            if (s[i] != s[i + m]) flg = 1;
        
        cout << (flg ? "NO" : "YES") << "\n";
    }
}
```

<br/>

## C. Palindrome Basis

[C번 문제 링크](https://codeforces.com/contest/1673/problem/C)

**[PROBLEM]**

양의 정수 $n$이 주어졌을 때, $n$을 펠린드롬인 양의 정수들의 합으로 나타내는 방법의 수를 구하여라.

단, 순서만 다르고 사용한 수가 같다면 동일한 방법으로 생각한다.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 10^4$)가 주어진다.

각 테스트케이스는 한 정수 $n$($1 \leq n \leq 4 \cdot 10^4$)로 이루어진다.

**[OUTPUT]**

각 테스트케이스에 대해 방법의 수를 $10^9 + 7$로 나눈 나머지를 출력한다.

---

### [SOLUTION] DP

백준에서 풀어본 [BOJ. 15989. 1,2,3 더하기 4](https://www.acmicpc.net/problem/15989) 문제의 업그레이드 버전이다.

핵심 포인트는 다음과 같다.

- $40000$ 이하의 자연수 중 펠린드롬인 것은 $498$개뿐이다.
- 펠린드롬 정수들 간에 순서를 고려하지 않으므로 2차원 DP 배열을 사용해야한다.

다음과 같은 DP 배열을 정의하자.

- $dp(i, j)$ : $i$를 $j$번째 펠린드롬까지만 사용해서 표현하는 방법의 수

이때 $j$번째 펠린드롬을 $p_j$라 하며, 이는 펠린드롬들을 오름차순으로 정렬했을 때의 순서이다.

그렇다면 다음과 같은 점화식을 구할 수 있다.

\begin{aligned}
dp(i, j) = dp(i - p_j, 1) + \dots + dp(i - p_j, k) = \sum_{k = 1}^j dp(i - p_j, k)
\end{aligned}

나는 처음에 이 점화식을 그대로 구현했는데, 시간이 굉장히 오래걸렸다.

아무래도 시간복잡도가 $O(n \times p^2)$($p$: $n$ 이하의 펠린드롬의 개수)라서 그럴 수밖에 없었던 것 같다.

시간복잡도를 줄이기 위해 $dp(i, j)$를 **누적합**으로 저장하였다. 즉,

\begin{aligned}
dp'(i, j) = dp(i, 1) + \dots + dp(i, j) = \sum_{k = 1}^j dp(i, k)
\end{aligned}

와 같이 저장하면, $dp(i, j) = dp'(i - p_j, j)$로 구할 수 있기 때문에 시간복잡도가 $O(n \times p)$이다.

단, $i$보다 작거나 같은 펠린드롬 수의 개수를 $mx_i$라고 했을 때 $j > mx_i$인 $j$에 대해 $dp(i, j) = dp(i, mx_i)$임에 주의해야한다.

나는 $dp(i, j) = dp'(i - p_j, \min(mx_{i-p_j}, j))$ 와 같이 처리해주었다.

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int MOD = 1e9 + 7;

int p[500], mx[40001];
int dp[40001][500], ans[40001];

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    // get palindrome
    int idx = 1;
    for (int i = 1; i <= 40000; i++)
    {
        mx[i] = mx[i - 1];
        if (i % 10 == 0) continue;
        
        int tmp = i, rev = 0;
        while (tmp > rev)
        {
            rev = rev * 10 + tmp % 10;
            tmp /= 10;
        }
        if (tmp == rev || tmp == rev / 10) p[idx++] = i, mx[i]++;
    }
    
    // get dp
    dp[0][0] = 1;
    for (int i = 1; i <= 40000; i++)
    {
        for (int j = 1; j <= mx[i]; j++)
        {
            dp[i][j] = (dp[i][j] + dp[i - p[j]][min(mx[i - p[j]], j)]) % MOD;
            dp[i][j] = (dp[i][j] + dp[i][j - 1]) % MOD;
        }
        ans[i] = dp[i][mx[i]];
    }

    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        cout << ans[n] << "\n";
    }
}
```

<br/>

## D. Lost Arithmetic Progression

[D번 문제 링크](https://codeforces.com/contest/1673/problem/D)

**[PROBLEM]**

유한한 길이의 등차수열 $A, B$의 공통항으로 이루어진 수열을 $C$라고 하면, $C$도 등차수열이다.

$B, C$가 주어졌을 때, 가능한 $A$의 개수를 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 100$)가 주어진다.

각 테스트케이스의 첫 번째 줄에는 세 정수 $b, q, y$($-10^9 \leq b \leq 10^9$, $1 \leq q \leq 10^9$, $2 \leq y \leq 10^9$)로 이루어진다.

두 번째 줄에는 세 정수 $c, r, z$($-10^9 \leq c \leq 10^9$, $1 \leq r \leq 10^9$, $2 \leq z \leq 10^9$)가 주어진다.

이는 각각 등차수열 $B, C$의 첫 항, 공차, 수열의 길이를 의미한다.

**[OUTPUT]**

각 테스트케이스에 대해 수열 $A$로 가능한 수열의 개수를 $10^9+7$로 나눈 나머지를 출력한다.

만약 가능한 수열이 무한히 많다면 $-1$을 출력한다.

---

### [SOLUTION] Math

수열 $B$의 첫 항을 $a_b$, 공차를 $d_b$, 수열의 길이를 $n_b$, 마지막 항을 $l_b$라 하고, 마찬가지로 수열 $C$에 대해서도 정의하자.

먼저, 수열 $A$가 존재하지 않는 경우부터 처리하자.

조건을 만족하는 $A$가 존재하지 않으려면 $C$의 원소 중 $B$에 없는 수가 존재해야한다.

- $C$의 공차가 $B$의 공차의 배수가 아닌 경우
- $C$의 첫 항과 $B$의 첫 항의 차이가 $B$의 공차의 배수가 아닌 경우
- $C$의 첫 항이 $B$의 첫 항보다 작거나, $C$의 마지막 항이 $B$의 마지막 항보다 큰 경우

다음으로, $A$가 무한히 많은 경우를 처리하자.

$A$가 무한히 많이 존재하기 위해서는 다음 조건을 만족해야한다.

- $a_c - d_c < a_b$ or $l_b < l_c + d_c$

이를 만족하면 공차가 $d_c$인 수열 $A$를 무한히 만들 수 있게 된다.

이제 일반적인 경우에 대해 $A$의 개수를 구해보자.

$A$와 $B$의 공통항이 $C$이므로, $A$의 공차 $d_a$는 다음을 만족해야한다.

- $\lcm(d_a, d_b) = d_c$

이러한 $d_a$들에 대해 $A$의 첫 항이 가질 수 있는 수는

\begin{aligned}
a_c - (\frac{d_c}{d_a} - 1) d_a, \dots, a_c - d_a, a_c
\end{aligned}

으로 총 $\frac{d_c}{d_a}$개이고, 마찬가지로 $A$의 마지막 항이 가질 수 있는 수의 개수도 $\frac{d_c}{d_a}$이다.

따라서 $\lcm(d_a, d_b) = d_c$ 을 만족하는 모든 $d_a$에 대해 $\left( \frac{d_c}{d_a} \right)^2$을 더하면 된다.

```cpp
#include <iostream>
#include <vector>
#include <math.h>
using namespace std;
typedef long long ll;
const int MOD = 1e9 + 7;

// first term, common difference, number of term, last term
ll ab, db, nb, lb; // of B
ll ac, dc, nc, lc; // of C

ll gcd(ll i, ll j)
{
    if (i < j) swap(i, j);
    while (j)
    {
        int tmp = i % j;
        i = j;
        j = tmp;
    }
    return i;
}

ll lcm(ll i, ll j) { return i * j / gcd(i, j); }

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        cin >> ab >> db >> nb >> ac >> dc >> nc;
        lb = ab + db * (nb - 1), lc = ac + dc * (nc - 1);
        
        if (dc % db || (ac - ab) % db || ac < ab || lb < lc)
        {
            cout << "0\n";
            continue;
        }
        
        if (ab > ac - dc || lb < lc + dc)
        {
            cout << "-1\n";
            continue;
        }
        
        ll ans = 0, da = dc / db;
        da *= gcd(da, db);
        ll k = dc / da, i = 1;
        vector<ll> div;
        for (; i < sqrt(k); i++) if (k % i == 0)
        {
            div.push_back(i);
            div.push_back(k / i);
        }
        if (i * i == k) div.push_back(i);
        
        for (ll i : div)
        {
            ll j = i * da;
            if (lcm(j, db) == dc) ans = (ans + k / i * k / i) % MOD;
        }
        cout << ans << "\n";
    }
}
```

## E. Power or XOR?

[E번 문제 링크](https://codeforces.com/contest/1673/problem/E)

**[PROBLEM]**



**[INPUT]**



**[OUTPUT]**



---

### [SOLUTION] Math




