---
title: "[CF #13] Codeforces Global Round #20 (A ~ E)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Coding Contest
use_math: true
comments: true

---

`Tags` Two pointer, Binary search

## Result & Review

오랜만에 글로벌 라운드가 열렸다.

5문제가 목표였는데 E번에서 막히는 바람에 지난번과 같은 4솔로 마무리했다.

어느 정도 감은 잡았는데 내 접근 방식으로는 주어진 쿼리 개수 제한을 계속 넘어갔다.

그리고 앞으로 쉬운 문제들은 간단히 풀이와 소스코드 정도만 적고 넘어갈 생각이다.

<br/>

## A. Log Chopping

[A번 문제 링크](https://codeforces.com/contest/1672/problem/A)

$n$개의 통나무를 두 사람이 번갈아가며 자르는 게임에서 누가 이기는지 구하는 문제이다.

각 통나무는 정수 길이를 가지고 있으며, 통나무는 정수 길이로만 자를 수 있다.

통나무를 더 이상 자를 수 없는 사람이 패배하게 된다.

---

### [SOLUTION] Math

게임이 끝나는 상황을 생각해보면, 통나무들의 길이가 모두 $1$인 상황임을 알 수 있다.

즉, 각자가 어떤 통나무를 어떤 길이로 자르던 간에 상관없이 게임을 끝나기 위해 잘라야하는 횟수는 일정하다.

A가 먼저 자른다고 하면, 자를 수 있는 횟수가 홀수이면 A가 승리하고, 짝수이면 B가 승리한다.

```cpp
#include <iostream>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        int sum = 0;
        for (int i = 0; i < n; i++)
        {
            int a;  cin >> a;
            sum += a - 1;
        }
        if (sum % 2) cout << "errorgorn\n";
        else cout << "maomao90\n";
    }
}
```

<br/>

## B. I love AAAB

[B번 문제 링크](https://codeforces.com/contest/1672/problem/B)

"AB", "AAB", AAAB", ... 와 같이 마지막 문자가 B이고 나머지 문자들은 모두 A인 문자열을 good라고 한다.

처음에 비어 있는 문자열이 있고, 이 문자열의 원하는 위치에 good 문자열을 삽입할 수 있다.

이때 주어진 문자열을 위 방법으로 만들 수 있는지 구하는 문제이다.

---

### [SOLUTION] Math

먼저, 모든 good 문자열은 모두 B로 끝나기 때문에 주어진 문자열이 A로 끝난다면 불가능하다.

위 경우를 제외하고는 주어진 문자열이 다음 조건을 만족한다면 good 문자열로 만드는 것이 가능하다.

- 가능한 모든 $i$에 대하여, $i$번째 자리까지의 A의 개수가 항상 B의 개수보다 크거나 같다.

```cpp
#include <iostream>
#include <string>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        string s; cin >> s;
        if (s.back() == 'A')
        {
            cout << "NO\n";
            continue;
        }

        int a = 0, b = 0;
        bool flg = 0;
        for (int i = 0; i < s.size(); i++)
        {
            if (s[i] == 'A') a++;
            else b++;
            if (a < b)
            {
                cout << "NO\n";
                flg = 1;
                break;
            }
        }
        if (!flg) cout << "YES\n";
    }
}
```

<br/>

## C. Unequal Array

[C번 문제 링크](https://codeforces.com/contest/1672/problem/C)

**[PROBLEM]**

$1 \leq i \leq n - 1$인 정수 $i$ 중에서 $a_i = a_{i+1}$을 만족하는 것의 개수를 수열의 equality라고 정의하자.

길이가 $n$인 수열 $a$가 주어지고, 이 수열에 다음 연산을 수행할 수 있다.

- 두 정수 $i, x$($1 \leq i \leq n - 1$, $1 \leq x \leq 10^9$)을 선택하여 $a_i$와 $a_{i+1}$을 $x$로 바꾼다.

주어진 수열의 equality가 $1$ 이하이도록 만들기 위해 필요한 연산의 최소 횟수를 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 10^4$)이 주어진다.

각 테스트케이스의 첫 번째 줄에는 정수 $n$($2 \leq n \leq 2 \cdot 10^5$)이 주어진다.

두 번째 줄에는 $n$개의 정수 $a_1, a_2, \dots, a_n$($1 \leq a_i \leq 10^9$)이 주어진다.

**[OUTPUT]**

각 테스트케이스에 대해 주어진 수열의 equality가 $1$ 이하이도록 만들기 위해 필요한 연산의 최소 횟수를 출력한다.

---

### [SOLUTION] Constructive algorithm

만약 연속해서 같은 숫자가 나타나는 경우가 없다면 0을 출력한다.

수열에서 연속으로 같은 숫자가 나오는 것들끼리 묶어보자.

이들 중 길이가 $2$ 이상인 것들 중 가장 먼저 나타나는 것의 시작 인덱스를 $x$, 가장 마지막에 나타나는 것의 끝 인덱스를 $y$라고 하자.

수열의 equality가 $1$ 이하가 되도록 하기 위해서는 $x + 1 \leq i < y - 1$인 정수 $i$에 대해 주어진 연산을 수행해야한다.

따라서 필요한 연산의 최소 횟수는 $y - x - 2$이다.

그런데 $y - x = 1$이면 equality가 이미 $1$이므로 연산을 수행할 필요가 없고,

$y - x = 2$이면 연속한 세 수가 동일한 경우이므로 연산을 한 번 수행해주어야 한다.

따라서 $y - x \leq 2$인 경우에 대해서는 $y - x - 1$을 출력해준다.

```cpp
#include <iostream>
using namespace std;

int a[200000];

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        for (int i = 0; i < n; i++) cin >> a[i];
        
        int x = -1, y;
        for (int i = 1; i < n; i++) if (a[i - 1] == a[i]) { x = i - 1; break; }
        for (int i = n - 1; i; i--) if (a[i - 1] == a[i]) { y = i; break; }
        
        if (x < 0) cout << "0\n";
        else if (y - x <= 2) cout << y - x - 1 << "\n";
        else cout << y - x - 2 << "\n";
    }
}
```

<br/>

## D. Cyclic Rotation

[D번 문제 링크](https://codeforces.com/contest/1672/problem/D)

**[PROBLEM]**

길이가 $n$인 수열 $a$가 주어지고, 다음 연산을 원하는 만큼 수행할 수 있다.

- 두 정수 $l, r$($1 \leq l < r \leq n$)에 대해 $a_l = a_r$이면, $\[a_l, \dots, a_r\] = \[a_{l + 1}, \dots, a_r, a_l\]$와 같이 부분수열을 왼쪽으로 회전한다.

수열 $a$의 순열 $b$가 주어질 때, 위 연산을 통해 $a$를 $b$가 되도록 할 수 있는지 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 10^4$)이 주어진다.

각 테스트케이스의 첫 번째 줄에는 정수 $n$($1 \leq n \leq 2 \cdot 10^5$)이 주어진다.

두 번째 줄에는 $n$개의 정수 $a_1, a_2, \dots, a_n$($1 \leq a_i \leq n$)이 주어진다.

세 번째 줄에는 $n$개의 정수 $b_1, b_2, \dots, b_n$($1 \leq b_i \leq n$)이 주어진다.

**[OUTPUT]**

수열 $a$를 $b$로 만들 수 있으면 "YES", 없으면 "NO"를 출력한다.

---

### [SOLUTION] Two pointer

주어진 연산은 아래와 같이 생각할 수 있다.

- $l, r$($l < r$)에 대해 $a_l = a_r$이면, $a_l$을 $a_r$ 앞으로 당긴다.

즉, 수열의 어떤 수가 움직일 수 있는 범위는 수열에 해당 수가 등장하는 마지막 위치이다.

따라서 두 수열의 원소를 가리키는 두 포인터를 두 수열의 끝 위치에서부터 시작해서 왼쪽으로 이동시키면서 아래와 같은 과정을 수행한다.

두 포인터 $j, i$에 대해 $a_j$와 $b_i$를 비교하자.

1. $a_j = b_i$이면 각 포인터를 왼쪽으로 이동하고 $1$번부터 다시 비교한다.
2. $b_i = b_{i+1}$이면 $b_i$를 당겨올 수 있으므로 기억해두고 $i$를 왼쪽으로 이동하고 $1$번부터 다시 비교한다.
3. $a_j$가 저장되어 있으면 $j$를 왼쪽으로 이동하고 $1$번부터 다시 비교한다.

$a$를 $b$로 만드는 것이 불가능한 경우는 다음과 같다.

- $j < i$ 인 경우
- $a_j \neq b_i$, $b_{i-1} \neq b_i$ 일 때 저장된 $a_j$가 없는 경우

```cpp
#include <iostream>
using namespace std;

int a[200000], b[200000], cnt[200000];

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        for (int i = 1; i <= n; i++) cnt[i] = 0;
        for (int i = 0; i < n; i++) cin >> a[i];
        for (int i = 0; i < n; i++) cin >> b[i];
        
        bool flg = 0;
        int i = n - 1, j = n - 1;
        while (i >= 0)
        {
            if (a[j] == b[i]) i--, j--;
            else if (i + 1 < n && b[i] == b[i + 1]) cnt[b[i--]]++;
            else if (cnt[a[j]] > 0)
            {
                cnt[a[j--]]--;
                if (j < i) { flg = 1; break; }
            }
            else { flg = 1; break; }
        }

        if (flg) cout << "NO\n";
        else cout << "YES\n";
    }
}
```

<br/>

## E. notepad.exe (Interactive problem)

[E번 문제 링크](https://codeforces.com/contest/1672/problem/E)

**[PROBLEM]**

텍스트 편집기에 $n$개의 단어가 저장되어 있고, $i$번째 단어의 길이는 $l_i$이다.

$l_i$를 모르는 상태에서 단어들을 보여줄 디스플레이의 가로 길이를 출력하는 쿼리를 물어볼 수 있다.

그러면 텍스트 편집기는 해당 가로 길이의 디스플레이에 단어들이 잘리지 않고 나타나는 최소 높이를 알려준다.

단, 같은 줄에 있는 단어들 사이에는 공백이 한 칸 있어야한다.

최대 $n + 30$개의 쿼리를 물어볼 수 있을 때, 모든 단어를 표시할 수 있는 디스플레이의 넓이의 최솟값을 구하여라.

**[INPUT & OUTPUT]**

처음에 저장된 단어의 개수 $n$($1 \leq n \leq 2000$)이 주어진다.

다음부터 최대 $n + 30$개의 쿼리를 "? w"와 같이 물어볼 수 있다.

가로 길이 $w$는 $1 \leq w \leq 10^9$을 만족해야하고, 이에 대한 최소 높이 $h$가 주어지게 된다.

만약 $h = 0$이면, 단어들이 잘리지 않도록 표시하는 것이 불가능하다는 의미이다.

최솟값 $A$을 구했다면 "! A"와 같이 답을 출력한다.

---

### [SOLUTION] Binary Search

먼저 $n + 30$이라는 숫자에서 이분탐색을 이용해야한다는 것을 유추할 수 있다.

이분탐색을 이용해서 높이가 $1$인 디스플레이의 최소 가로 길이 $W = \sum_{i=1}^n + n - 1$의 값을 구하자.

이를 구하는데 최대 $30$번의 쿼리가 필요하다.

높이 $h$인 디스플레이에 단어들을 잘 배치해서 필수적인 공백을 제외하고 남는 공간이 없다면, 필요한 칸의 수는 $W - h + 1$이다.

이는 높이가 $h$인 디스플레이가 가질 수 있는 최소 넓이가 된다.

이미 높이가 $1$인 디스플레이의 최소 넓이 $W$를 가지고 있으므로, 더 작은 값을 찾아야한다.

따라서 가능한 높이 $h$에 대해 $\[W - h + 1, W)$ 구간에 속하는 최소 넓이를 구함으로써 최솟값을 얻을 수 있다.

디스플레이의 넓이는 $h$의 배수이므로 위 구간에 속하는 정수 중 $h$의 배수인 것을 찾으면 되는데, 이에 해당하는 너비는 다음과 같다.

\begin{aligned}
w = \left\lfloor \frac{W}{h} \right\rfloor
\end{aligned}

가능한 높이마다 하나의 쿼리를 이용해서 최소 넓이를 구할 수 있고, 높이의 최댓값은 $n$이므로 최대 $n + 30$개의 쿼리를 이용해서 최솟값을 구할 수 있다.

```cpp
#include <iostream>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int n; cin >> n;
    int s = n + (n - 1), e = 2000 * n + (n - 1), W;
    while (s <= e)
    {
        int m = (s + e) / 2;
        cout << "? " << m << "\n" << flush;
        int h; cin >> h;
        if (h == 1) W = m, e = m - 1;
        else s = m + 1;
    }
    
    int ans = W;
    for (int H = 2; H <= n; H++)
    {
        cout << "? " << W / H << "\n" << flush;
        int h; cin >> h;
        if (h) ans = min(ans, h * (W / H));
    }
    cout << "! " << ans;
}
```

<br/>

## F1. Array Shuffling

[F1번 문제 링크](https://codeforces.com/contest/1672/problem/F1)

**[PROBLEM]**

길이가 $n$인 수열 $a$를 섞어 수열 $b$로 바꾸었다.

수열 $b$를 다시 $a$로 만들기 위해 다음 연산을 수행할 수 있다.

- $1 \leq i, j \leq n$인 두 정수 $i, j$를 선택하여 $b_i$와 $b_j$를 교환한다.

수열 $b$의 sadness는 $b$를 $a$로 바꾸기 위해 필요한 연산의 최소 횟수라고 정의된다.

수열 $a$가 주어졌을 때, sadness가 최대가 되는 $a$의 순열 $b$를 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 10^4$)이 주어진다.

각 테스트케이스의 첫 번째 줄에는 정수 $n$($1 \leq n \leq 2 \cdot 10^5$)이 주어진다.

두 번째 줄에는 $n$개의 정수 $a_1, a_2, \dots, a_n$($1 \leq a_i \leq n$)이 주어진다.

**[OUTPUT]**

Sadness가 최대가 되는 수열 $b$를 출력한다.

답이 여러 개라면 그 중 아무거나 출력한다.

---

### [SOLUTION] 


