---
title: "[CF #19] Codeforces Round #809 (div 2)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Coding Contest
use_math: true
comments: true

---

`Tags` 

## Result & Review

거의 두 달만에 참여했고, 첫 세 문제를 해결하는데 그쳤다.

지난 두 달 동안에는 새로운 알고리즘들을 공부하고, 국내 알고리즘 대회들에도 참여하였다.

현대모비스 알고리즘 대회에서는 쉬운 문제들을 틀려 아쉽게 떨어졌지만, SCPC 1라운드는 무난히 통과할 듯 싶다.

SCPC 2라운드는 꽤나 어려운 문제들이 나오던데, 그때까지 열심히 해볼 생각이다.

<br/>

## A. Another String Minimization Problem

[A번 문제 링크](https://codeforces.com/contest/1706/problem/A)

두 정수 $n, m$($1 \leq n, m \leq 50$)에 대하여,

- 길이가 $n$인 수열 $a_1, a_2, \dots, a_n$($1 \leq a_i \leq m$)과
- 길이가 $m$이고 알파벳 "B"로만 이루어진 문자열 $s$

가 있다. 아래와 같인 연산을 $n$번 수행하여 만들 수 있는 문자열들 중 사전순으로 가장 앞서는 것을 구하는 문제이다.

- $i$번째 연산: 문자열의 $a_i$ 번째 또는 $m + 1 - a_i$ 번째 문자를 "A"로 바꾼다.

---

### [SOLUTION] Greedy

$\min(a_i, m+1-a_i)$ 번째 문자가 "B"이면 해당 문자를 "A"로 바꾸고,

$\min(a_i, m+1-a_i)$ 번째 문자가 이미 "A"이면 $\max(a_i, m+1-a_i)$ 번째 문자를 "A"로 바꾸어주면 된다.

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int t; cin >> t;
    while (t--) {
        int n, m; cin >> n >> m;
        vector<bool> chk(m, 0);
        for (int i = 0; i < n; i++) {
            int a; cin >> a;
            if (!chk[min(a - 1, m - a)]) chk[min(a - 1, m - a)] = 1;
            else chk[max(a - 1, m - a)] = 1;
        }
        for (int i = 0; i < m; i++) cout << (chk[i] ? "A" : "B"); cout << "\n";
    }
}
```

<br/>

## B. Making Towers

[B번 문제 링크](https://codeforces.com/contest/1706/problem/B)

정수 $n$($1 \leq n \leq 10^5$)에 대하여, $n$개의 색칠된 블록이 있다.

$i$번째 블록의 색깔은 $c_i$이고, $c_i$는 $1$ 이상 $n$ 이하의 정수이다.

아래 규칙을 만족하면서 블록들을 좌표평면에 놓는다.

1. 블록 $1$을 $(0, 0)$에 놓는다.
2. 정수 $2 \leq i \leq n$ 에 대하여 블록 $i - 1$을 $(x, y)$에 놓았다면, 블록 $i$는 $(x+1, y)$ 또는 $(x - 1, y)$ 또는 $(x, y + 1)$ 에 놓을 수 있다.
3. 단, 이미 블록이 놓인 자리에는 블록을 놓을 수 없다.

같은 색깔 $r$으로 칠해진 블록들이 $y$축 방향으로 연속해서 놓여 있으면, 해당 블록들을 "색깔 $r$의 탑"이라고 부른다.

각 색깔에 대하여 만들 수 있는 탑의 길이의 최댓값을 구하는 문제이다.

---

### [SOLUTION] Greedy

조금만 생각해보아도 탑을 만들기 위해서는 같은 색깔을 가진 블록들이 **홀수 칸만큼 떨어져 있어야 한다**는 것을 알 수 있다.

즉, 색깔 $r$을 가진 블록들을 $a_1, a_2, \dots, a_k$ 라고 하면 이웃한 $a_i$들 중 서로 홀짝성이 같은 블록들은 같은 탑에 존재할 수 없다.

따라서 $a_{i-1}$과 홀짝성이 다른 $a_i$를 찾을 때마다 탑의 높이를 $1$씩 늘려주면 된다.

```cpp
#include <iostream>
#include <vector>
using namespace std;

int idx[100001], ans[100001];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--) {
        int n; cin >> n;
        for (int i = 1; i <= n; i++) ans[i] = 0, idx[i] = 0;
        for (int i = 1; i <= n; i++) {
            int c; cin >> c;
            if (!idx[c]) ans[c]++, idx[c] = i;
            else if ((i - idx[c]) % 2) ans[c]++, idx[c] = i;
        }
        for (int i = 1; i <= n; i++) cout << ans[i] << " ";
        cout << "\n";
    }
}
```

<br/>

## C. Qpwoeirut And The City

[C번 문제 링크](https://codeforces.com/contest/1706/problem/C)

정수 $n$($3 \leq n \leq 10^5$)에 대하여, $n$개의 빌딩이 있으며, $i$번째 빌딩의 높이는 $h_i$이다.

정수 $1 < i < n$ 에 대하여 $i$번째 빌딩이 "멋진 빌딩"이기 위해서는 $h_i > h_{i-1}$ 과 $h_i > h_{i+1}$ 을 만족해야한다.

즉, 이웃한 두 빌딩보다 더 높아야한다.

각 건물의 높이를 높여서 도시를 리모델링을 하려는데, 멋진 빌딩이 최대한 많도록 리모델링할 것이다.

이때 추가하는 높이의 최솟값을 구하여라.

---

### [SOLUTION] Greedy

멋진 빌딩의 개수가 최대가 되기 위해서는  $2$번째 빌딩에서부터 $n-1$번째 빌딩까지 중 이웃하지 않도록 $\lfloor \frac{n-1}{2} \rfloor$ 개의 빌딩을 선택해서 멋진 빌딩으로 만들어 주어야 한다.

$n$이 홀수이면 모든 짝수 번째 빌딩들을 멋진 빌딩으로 만들면 된다.

$n$이 짝수이면 가능한 경우는 $\frac{n}{2}$ 가지인데, 이는 정수 $k$로 다음과 같이 표현할 수 있다.

- $2, 4, \dots, 2k$ 번째 빌딩들과 $2k + 3, 2k + 5, \dots, n - 1$ 번째 빌딩들을 멋진 빌딩으로 만든다.

$n$이 최대 $10^5$까지 주어질 수 있으므로 빠르게 처리하기 위해서는

- $2$번째 빌딩부터 시작해서 짝수 번째 빌딩들을 멋진 빌딩으로 만드는데 필요한 높이
- $n-1$번째 빌딩부터 시작해서 홀수 번째 빌딩들을 멋진 빌딩으로 만드는데 필요한 높이

를 부분합으로 미리 구해두어야한다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
typedef long long ll;

ll h[100010], s[100010];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--) {
        int n; cin >> n;
        for (int i = 0; i < n + 10; i++) h[i] = 0, s[i] = 0;
        for (int i = 1; i <= n; i++) cin >> h[i];
        for (int i = 2; i <= n; i += 2) {
            if (h[i] > max(h[i - 1], h[i + 1])) s[i] = s[i - 2];
            else s[i] = s[i - 2] + max(h[i - 1], h[i + 1]) + 1 - h[i];
        }
        for (int i = n / 2 * 2 - 1; i > 0; i -= 2) {
            if (h[i] > max(h[i - 1], h[i + 1])) s[i] = s[i + 2];
            else s[i] = s[i + 2] + max(h[i - 1], h[i + 1]) + 1 - h[i];
        }
        
        ll ans = 1e18;
        if (n % 2) ans = s[n - 1];
        else {
            for (int i = 0; i < n; i += 2) ans = min(ans, s[i] + s[i + 3]);
        }
        cout << ans << "\n";
    }
}
```

<br/>

## D. Chopping Carrots

[D1번 문제 링크](https://codeforces.com/contest/1706/problem/D1)

[D2번 문제 링크](https://codeforces.com/contest/1706/problem/D2)

정수 $n$에 대하여, 길이가 $n$인 정수 수열 $a_1, a_2, \dots, a_n$ 이 주어진다.

길이가 $n$인 정수 수열 $p_1, p_2, \dots, p_n$ 의 "비용"은

\begin{aligned}
\max_{1 \leq i \leq n} \left \lfloor \frac{a_i}{p_i} \rfloor \right) - \min_{1 \leq i \leq n} \left \lfloor \frac{a_i}{p_i} \rfloor \right)
\end{aligned}

와 같이 정의된다.

이때 정수 $k$에 대하여 $1 \leq p_i \leq k$ 를 만족하는 수열 $p$의 최소 비용을 구하는 문제이다.

- **D1**: $1 \leq n, k \leq 3000$, $1 \leq a_1 \leq a_2 \leq \dots \leq a_n \leq 3000$
- **D2**: $1 \leq n, k \leq 10^5$, $1 \leq a_1 \leq a_2 \leq \dots \leq a_n \leq 10^5$

---

### [D1 SOLUTION] Brute Force

정수 $v$($0 \leq v \leq a_1$)에 대하여, $\lfloor \frac{a_i}{p_i} \rfloor$ 의 최솟값이 $v$일 때의 최소 비용을 구하자.

최솟값이 $v$로 고정된 상태에서 최소 비용을 구하기 위해서는 최댓값을 작게 만들어야 하므로 조건을 만족하면서 $p_i$를 가능한 크게 만들면,

\begin{aligned}
p_i = \min \left( k, \lfloor \frac{a_i}{v} \rfloor \right)
\end{aligned}

와 같이 나타낼 수 있다. 이때 $v = 0$ 이면 $p_i = k$ 로 두면 된다.

이렇게 구한 $p_i$들에 대하여 최댓값을 계산해주고, $a_1 + 1$ 개의 최소 비용 중 가장 작은 것이 답이 된다.

전체 시간복잡도는 $O(a_1 n)$ 이다.

```cpp

```

---

### [D2 SOLUTION]











