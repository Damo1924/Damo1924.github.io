---
title: "[CF #19] Codeforces Round #809 (div 2)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Coding Contest
use_math: true
comments: true

---

`Tags` 

## Result & Review

거의 두 달만에 참여했고, 첫 세 문제를 해결하는데 그쳤다.

지난 두 달 동안에는 새로운 알고리즘들을 공부하고, 국내 알고리즘 대회들에도 참여하였다.

현대모비스 알고리즘 대회에서는 쉬운 문제들을 틀려 아쉽게 떨어졌지만, SCPC 1라운드는 무난히 통과할 듯 싶다.

SCPC 2라운드는 꽤나 어려운 문제들이 나오던데, 그때까지 열심히 해볼 생각이다.

<br/>

## A. Another String Minimization Problem

[A번 문제 링크](https://codeforces.com/contest/1706/problem/A)

두 정수 $n, m$($1 \leq n, m \leq 50$)에 대하여,

- 길이가 $n$인 수열 $a_1, a_2, \dots, a_n$($1 \leq a_i \leq m$)과
- 길이가 $m$이고 알파벳 "B"로만 이루어진 문자열 $s$

가 있다. 아래와 같인 연산을 $n$번 수행하여 만들 수 있는 문자열들 중 사전순으로 가장 앞서는 것을 구하는 문제이다.

- $i$번째 연산: 문자열의 $a_i$ 번째 또는 $m + 1 - a_i$ 번째 문자를 "A"로 바꾼다.

---

### [SOLUTION] Greedy

$\min(a_i, m+1-a_i)$ 번째 문자가 "B"이면 해당 문자를 "A"로 바꾸고,

$\min(a_i, m+1-a_i)$ 번째 문자가 이미 "A"이면 $\max(a_i, m+1-a_i)$ 번째 문자를 "A"로 바꾸어주면 된다.

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int t; cin >> t;
    while (t--) {
        int n, m; cin >> n >> m;
        vector<bool> chk(m, 0);
        for (int i = 0; i < n; i++) {
            int a; cin >> a;
            if (!chk[min(a - 1, m - a)]) chk[min(a - 1, m - a)] = 1;
            else chk[max(a - 1, m - a)] = 1;
        }
        for (int i = 0; i < m; i++) cout << (chk[i] ? "A" : "B"); cout << "\n";
    }
}
```

<br/>

## B. Making Towers

[B번 문제 링크](https://codeforces.com/contest/1706/problem/B)

정수 $n$($1 \leq n \leq 10^5$)에 대하여, $n$개의 색칠된 블록이 있다.

$i$번째 블록의 색깔은 $c_i$이고, $c_i$는 $1$ 이상 $n$ 이하의 정수이다.

아래 규칙을 만족하면서 블록들을 좌표평면에 놓는다.

1. 블록 $1$을 $(0, 0)$에 놓는다.
2. 정수 $2 \leq i \leq n$ 에 대하여 블록 $i - 1$을 $(x, y)$에 놓았다면, 블록 $i$는 $(x+1, y)$ 또는 $(x - 1, y)$ 또는 $(x, y + 1)$ 에 놓을 수 있다.
3. 단, 이미 블록이 놓인 자리에는 블록을 놓을 수 없다.

같은 색깔 $r$으로 칠해진 블록들이 $y$축 방향으로 연속해서 놓여 있으면, 해당 블록들을 "색깔 $r$의 탑"이라고 부른다.

각 색깔에 대하여 만들 수 있는 탑의 길이의 최댓값을 구하는 문제이다.

---

### [SOLUTION] Greedy

조금만 생각해보아도 탑을 만들기 위해서는 같은 색깔을 가진 블록들이 **홀수 칸만큼 떨어져 있어야 한다**는 것을 알 수 있다.

즉, 색깔 $r$을 가진 블록들을 $a_1, a_2, \dots, a_k$ 라고 하면 이웃한 $a_i$들 중 서로 홀짝성이 같은 블록들은 같은 탑에 존재할 수 없다.

따라서 $a_{i-1}$과 홀짝성이 다른 $a_i$를 찾을 때마다 탑의 높이를 $1$씩 늘려주면 된다.

```cpp
#include <iostream>
#include <vector>
using namespace std;

int idx[100001], ans[100001];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--) {
        int n; cin >> n;
        for (int i = 1; i <= n; i++) ans[i] = 0, idx[i] = 0;
        for (int i = 1; i <= n; i++) {
            int c; cin >> c;
            if (!idx[c]) ans[c]++, idx[c] = i;
            else if ((i - idx[c]) % 2) ans[c]++, idx[c] = i;
        }
        for (int i = 1; i <= n; i++) cout << ans[i] << " ";
        cout << "\n";
    }
}
```

<br/>

## C. Qpwoeirut And The City

[C번 문제 링크](https://codeforces.com/contest/1706/problem/C)

정수 $n$($3 \leq n \leq 10^5$)에 대하여, $n$개의 빌딩이 있으며, $i$번째 빌딩의 높이는 $h_i$이다.

정수 $1 < i < n$ 에 대하여 $i$번째 빌딩이 "멋진 빌딩"이기 위해서는 $h_i > h_{i-1}$ 과 $h_i > h_{i+1}$ 을 만족해야한다.

즉, 이웃한 두 빌딩보다 더 높아야한다.

각 건물의 높이를 높여서 도시를 리모델링을 하려는데, 멋진 빌딩이 최대한 많도록 리모델링할 것이다.

이때 추가하는 높이의 최솟값을 구하여라.

---

### [SOLUTION] Greedy

먼저 





