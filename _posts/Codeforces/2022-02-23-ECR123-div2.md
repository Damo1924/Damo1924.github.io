---
title: "[CF#5] Educational Codeforces Round #123 (Div. 2)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Codeforces
use_math: true
comments: true

---

`Tags` 

## Result & Review

5번째로 참여한 대회였고, 그렇게 만족스러운 결과를 얻지는 못했다.

총 6문제가 출제되었고, A번과 B번을 푸는데 20분, C번도 20분만에 해결하였다.

아직 대회를 많이 참여해보지는 못했지만, 앞에 세 문제정도만 빠르게 풀어도 블루 레이팅 정도는 유지할 수 있을 것 같아서 시간을 단축하려고 노력하는데, 시간을 줄이는게 쉽지 않은 것 같다.

평균적으로 A와 B가 10분, C가 20분 정도 걸리는 것 같다.

그렇게 D번으로 넘어갔지만, 시간을 1시간 남기고 구현한 풀이의 반례를 남은 시간 내내 찾지 못했다.

정말 1시간 내내 반례가 있나 찾았는데 못찾았다 ㅜㅜ

<img src="">

딱 4문제 풀고 블루를 갔으면 좋았을텐데, 많이 아쉽다.

<br/>

## A. Doors and Keys

[A번 문제 링크](https://codeforces.com/contest/1644/problem/A)

**[PROBLEM]**

좁고 긴 길에 빨간색, 초록색, 파란색 문이 있다.

각 문을 지나가기 위해서는 동일한 색깔의 키가 필요하다.

각 문과 키의 위치가 길이가 6인 문자열로 주어질 때, 길을 통과할 수 있는지 판별하여라.

대문자 'R', 'G', 'B'는 문을, 소문자 'r', 'g', 'b'는 키를 의미한다.

문자열에는 위 6가지 문자가 한 번씩 등장한다.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 720$)가 주어진다.

각 테스트케이스는 길이가 6인 문자열로 이루어져있다.

**[OUTPUT]**

길을 통과할 수 있으면 "YES", 통과하지 못한다면 "NO"를 출력한다.

---

### [SOLUTION] Implementation

'R' 앞에 'r'이 있는지, 'G' 앞에 'g'가 있는지, 'B' 앞에 'b'가 있는지 체크하면 된다.

세 가지 조건 모두 만족하면 길을 지나갈 수 있고, 하나라도 만족하지 않으면 지나갈 수 없다.

```cpp
#include <iostream>
#include <string>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    string door = "RGB", key = "rgb";

    int t; cin >> t;
    while (t--)
    {
        string s; cin >> s;
        
        bool canPass = 1;
        for (int i = 0; i < 3; i++)
            if (s.find(door[i]) < s.find(key[i])) canPass = 0;
        
        cout << (canPass ? "YES" : "NO") << "\n";
    }
}
```

<br/>

## B. Anti-Fibonacci Permutation

[B번 문제 링크](https://codeforces.com/contest/1644/problem/B)

**[PROBLEM]**

$1$부터 $n$까지의 정수로 이루어진 순열 $p$가 다음을 만족하면 **anti-Fibonacci**라고 부르기로 하자.

\begin{aligned}
p_{i-2} + p_{i-1} \neq p_i (3 \leq i \leq n)
\end{aligned}

어떤 자연수 $n$이 주어지면 길이가 $n$개의 anti-Fibonacci 순열을 출력하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 48$)가 주어진다.

각 테스트케이스는 정수 $n$($3 \leq n \leq 50$)으로 이루어진다.

**[OUTPUT]**

각 $n$에 대해 길이가 $n$인 anti-Fibonacci 순열 $n$개를 출력한다.

입력으로 주어지는 $n$에 대해, 항상 $n$개의 서로 다른 anti-Fibonacci 순열을 찾을 수 있음이 보장된다.

---

### [SOLUTION] Brute force (Constructive algorithm)

이 문제의 핵심 아이디어는 **내림차순으로 정렬된 수열이 anti-Fibonacci 조건을 만족한다**는 점이다.

순열의 맨 앞에 $x$($1 \leq x \leq n$)를 놓고 나머지 $n-1$개를 내림차순으로 정렬하자.

$x$가 $1$부터 $n$까지의 정수일 때 각 순열은 모두 anti-Fibonacci 순열임을 알 수 있다.

```cpp
#include <iostream>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        for (int i = 1; i <= n; i++)
        {
            cout << i;
            for (int j = n; j > 0; j--)
                if (i != j) cout << " " << j;
            cout << "\n";
        }
    }
}
```

그런데 조건을 만족하는 순열이 너무 많아서인지 DFS로 anti-Fibonacci 순열을 찾아도 여유롭게 통과된다.

<br/>

## C. Increase Subarray Sums

[C번 문제 링크](https://codeforces.com/contest/1644/problem/C)

**[PROBLEM]**

길이가 $n$인 수열 $a_1, a_2, \dots, a_n$과 어떤 정수 $x$가 주어진다.

음이 아닌 정수 $k$에 대해 $f(k)$를 다음과 같이 정의하자.

- 수열의 $k$개의 위치에 $x$를 더했을 때, $a$의 연속합의 최댓값

단, 비어있는 부분수열의 합(=0)도 고려한다.

이때 $0$부터 $n$까지의 모든 $k$에 대해 $f(k)$의 최댓값을 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 5000$)가 주어진다.

각 테스트케이스의 첫 번째 줄에는 두 정수 $n, x$($3 \leq n \leq 50$; $0 \leq x \leq 10^5$)가 주어진다.

두 번째 줄에는 $n$개의 정수 $a_1, a_2, \dots, a_n$($-10^5 \leq a_i \leq 10^5$)가 주어진다.

**[OUTPUT]**

각 테스트케이스에 대해 $0$부터 $n$까지의 모든 $k$에 대해 $f(k)$의 최댓값을 출력한다.

---

### [SOLUTION] DP



