---
title: "[CF #21] Educational Codeforces Round #133 (div 2)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Coding Contest
use_math: true
comments: true

---

`Tags` 

## Result & Review

A, B번은 에듀코포답게 매우 쉬운 편이어서 10분 내로 풀 수 있었다.

문제는 C번이었는데, 아이디어 자체는 보자마자 떠올랐으나 올바르게 구현하는데 1시간이 넘게 걸렸다.

대회가 끝나고 보니 1000명 정도 풀었던데 나만 어려웠던건 아니었던 것 같다.

오히려 D번이 아주 간단한 DP 문제였는데, 계속 시간초과가 나서 풀지 못했다.

알고보니 내가 불필요한 반복문을 사용해서 그랬던 것이었다.

C번이 상당히 난이도가 있어서 D번까지 풀었으면 아마 점수가 많이 올랐을텐데 너무 아쉽다.

<br/>

## A. 2-3 Moves

[A번 문제 링크](https://codeforces.com/contest/1716/problem/A)

수평선 위의 $0$ 위치에서 출발하여 $n$($1 \leq n \leq 10^9$) 위치로 움직이려고 한다.

현재 위치가 $x$이면 $1$분 후에 $x - 3, x - 2, x + 2, x + 3$ 중 하나의 위치로 움직일 수 있다.

이때 $0$에서 $n$으로 움직이기 위해 필요한 최소 시간을 구하여라.

---

### [SOLUTION] Greedy

$n$이 $3$의 배수라면 $+3$씩 움직이는 것이 최선이다.

$n$을 $3$으로 나눈 나머지가 $1$이라면 $n-4$까지 $+3$으로 움직인 후, $+2$로 두 번 움직이는 것이 최선이다.

$n$을 $3$으로 나눈 나머지가 $2$이라면 $n-2$까지 $+3$으로 움직인 후, $+2$로 한 번 움직이는 것이 최선이다.

> **$1$은 따로 예외 처리**를 해주는 것을 잊지 말자.

```cpp
#include <iostream>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--) {
        int n; cin >> n;
        if (n == 1) cout << "2\n";
        else if (n % 3) cout << n / 3 + 1 << "\n";
        else cout << n / 3 << "\n";
    }
}
```

<br/>

## B. Permutation Chain

[B번 문제 링크](https://codeforces.com/contest/1716/problem/B)

길이가 $n$인 순열 $p_1, p_2, \dots, p_n$ 에 대하여 $p_j = j$ 를 만족하는 $j$의 개수를 순열 $p$의 *fixedness* 라고 정의하자.

다음 규칙을 만족하는 길이가 $n$인 순열들로 이루어진 수열 $a_1, a_2, \dots$ 을 만들려고 한다.

- 첫 번째 순열 $a_1$은 $1, 2, 3, \dots, n$ 으로 고정
- $2 \leq i$ 인 모든 $i$에 대하여 $a_i$는 $a_{i-1}$에서 두 원소를 교환함으로서 얻을 수 있다.
- $2 \leq i$ 인 모든 $i$에 대하여 순열 $a_i$의 fixedness는 $a_{i-1}$의 fixedness보다 작아야한다.

위 조건을 만족하는 순열들의 수열을 permutation chain이라고 부른다.

정수 $n$($2 \leq n \leq 100$)이 주어질 때, 가장 긴 permutation chain의 길이를 구하고, 각 순열을 순서대로 출력하여라.

---

### [SOLUTION] Greedy

첫 번째 순열의 fixedness는 항상 $n$이고, 두 번째 순열의 fixedness는 항상 $n-2$이다.

세 번째 순열부터는 fixedness가 $1$씩 감소하도록 만들 수 있기 때문에 permutation chain의 길이의 최댓값은 $n$이다.

$2 \leq i$ 인 모든 $i$에 대하여 $a_i$는 $a_{i-1}$에서 $i-1$번째 원소와 $i$번째 원소를 교환함으로써 얻을 수 있다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
typedef long long ll;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--) {
        int n; cin >> n;
        vector<int> a(n);
        for (int i = 0; i < n; i++) a[i] = i + 1;
        
        cout << n << "\n";
        for (int i = 0; i < n; i++) {
            for (int i = 0; i < n; i++) cout << a[i] << " ";
            cout << "\n";
            if (i + 1 < n) swap(a[i], a[i + 1]);
        }
    }
}
```

<br/>

## C. Robot in a Hallway

[C번 문제 링크](https://codeforces.com/contest/1716/problem/C)

$2$개의 행과 $m$($2 \leq m \leq 2 \cdot 10^5$)개의 열로 이루어진 그리드가 있다.

행들은 위에서 아래로 $1$부터 $2$까지의 번호가 매겨져 있고, 열들은 왼쪽에서 오른쪽으로 $1$부터 $m$까지의 번호가 매겨져 있다.

로봇은 $(1, 1)$에서 출발하고, 다음 $1$초 동안 아래의 두 가지 행동 중 하나를 수행한다.

- 상하좌우로 인접한 칸으로 이동하기
- 제자리에서 기다리기

로봇은 그리드 바깥으로 나갈 수 없다.

칸 $(i, j)$에는 값 $a_{i,j}$이 있어서 해당 값만큼의 시간이 지난 후에야 해당 칸으로 이동이 가능하다.

로봇이 같은 칸을 두 번 이상 방문하지 않으면서 모든 칸을 전부 방문하는데 걸리는 최소 시간을 구하여라.

---

### [SOLUTION] Implementation

행이 두 개밖에 없기 때문에 $(1, 1)$에서 출발하여 같은 칸을 두 번 이상 방문하지 않고 모든 칸을 방문하는 경로는 $m$개뿐이다.

그렇다고 각 경로에 대하여 시간이 얼마나 걸리는지 구하는 것은 $O(m^2)$이므로 불가능하다.

따라서 각 경로에서 공통된 부분을 지나는데 걸리는 최소 시간을 미리 구해두어야한다.

<center><img src="https://user-images.githubusercontent.com/88201512/182986374-cc27cec4-5973-4a74-8a44-d49f977256d7.jpg" width="60%" height="60%"></center>

위 그림에서 알 수 있듯이,

- $(1, i)$에서 시계방향으로 도는 경로에서의 최댓값
- $(2, i)$에서 반시계방향으로 도는 경로에서의 최댓값

을 미리 구해둔다면, 각 경로를 지나는데 필요한 최소 시간을 $O(1)$로 구할 수 있게 된다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
typedef long long ll;

int a[2][200001], cw[200001], ccw[200001];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--) {
        int m; cin >> m;
        for (int j = 1; j <= m; j++) cin >> a[0][j];
        for (int j = 1; j <= m; j++) cin >> a[1][j];
        
        cw[m] = ccw[m] = -1;
        for (int j = m - 1; j; j--) {
            cw[j] = max(cw[j + 1] + 1, a[1][j + 1] + 1);
            cw[j] = max(cw[j], a[0][j + 1] + 2 * (m - j));
            ccw[j] = max(ccw[j + 1] + 1, a[0][j + 1] + 1);
            ccw[j] = max(ccw[j], a[1][j + 1] + 2 * (m - j));
        }
        
        int time = 0, i = 0;
        int ans = max(cw[1] + 1, max(2 * m - 1, a[1][1] + 1));
        for (int j = 1; j <= m; j++, i ^= 1) {
            time = max(time, a[i ^ 1][j] + 2 * (m - j) + 1);
            
            if (i) ans = min(ans, max(time, cw[j]));
            else ans = min(ans, max(time, ccw[j]));
            
            if (j + 1 <= m) time = max(time, a[i ^ 1][j + 1] + 2 * (m - j));
        }
        cout << ans << "\n";
    }
}
```

<br/>

## D. Chip Move

[D번 문제 링크](https://codeforces.com/contest/1716/problem/D)

수평선 위에서 칩을 아래 규칙에 따라 움직이려고 한다.

- 칩의 초기 위치는 $0$이다.
- 어떤 정수 $k$에 대하여 $i$번째 이동은 현재 위치에서 오른쪽으로 $k + i - 1$ 의 배수만큼 이동할 수 있다.

두 양의 정수 $n, k$($1 \leq k \leq n \leq 2 \cdot 10^5$)가 주어질 때, 모든 $1 \leq x \leq n$ 에 도달하는 방법의 수를 각각 구하여라.

결과를 $998244353$으로 나눈 나머지를 출력하여라.

---

### [SOLUTION] DP

$i$번째 이동을 했을 때 도달할 수 있는 가장 작은 위치 $s_i$는

\begin{aligned}
s_i = \sum_{j = 0}^{i-1} (k + j) = k \cdot i + \frac{(i-1)i}{2}
\end{aligned}

이다. 따라서 이동 횟수의 최댓값은 $O(\sqrt{n})$ 임을 알 수 있다.

$i + 1$번째 이동으로 각 $x$에 도달하는 경우의 수는 $i$번째 이동의 결과를 바탕으로 DP를 통해 $O(n - s_i)$ 로 구할 수 있다.

즉, 가능한 이동 전부를 탐색하는데 걸리는 전체 시간복잡도는 $O(n \sqrt{n})$ 이다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
typedef long long ll;
const int MOD = 998244353;

ll ans[200001], dp[2][200001];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int n, k; cin >> n >> k;
    int s = 0, i = 0;
    dp[0][0] = 1;
    while (s <= n) {
        for (int j = s; j <= n; j++)
            ans[j] = (ans[j] + dp[i][j]) % MOD;
        for (int x = s; x <= n - k; x++) {
            dp[i ^ 1][x + k] =  dp[i][x];
            dp[i][x + k] = (dp[i][x + k] + dp[i][x]) % MOD;
        }
        i ^= 1;
        s += k++;
    }
    for (int j = 1; j <= n; j++) cout << ans[j] << " ";
}
```

<br/>

## E. Swap and Maximum Block

[E번 문제 링크](https://codeforces.com/contest/1716/problem/E)

정수 $n$($1 \leq n \leq 18$)에 대하여 길이가 $2^n$인 수열이 주어진다.

수열의 원소들은 $1$부터 $2^n$까지 번호가 매겨지며, 원소들은 절댓값이 $10^9$보다 작거나 같은 정수이다.

정수 $k$($0 \leq k \leq n - 1$)로 이루어진 $q$($1 \leq 2 \cdot 10^5$)개의 쿼리가 주어진다.

- 모든 $1 \leq i \leq 2^n - 2^k$ 에 대하여, 오름차순으로 아래 작업을 수행한다.
- $i$번째 원소가 이번 쿼리에서 교환되었다면 다음 원소로 넘어간다.
- $i$번째 원소가 이번 쿼리에서 교환되지 않았다면 $i + 2^k$ 번째 원소와 교환한다.

위 연산을 수행한 후, 부분수열의 합의 최댓값을 출력한다. (비어 있는 부분수열도 포함)

---

### [SOLUTION] 










