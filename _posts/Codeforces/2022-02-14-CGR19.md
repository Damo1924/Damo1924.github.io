---
title: "[CF#3] Codeforces Global Round"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Codeforces
use_math: true
comments: true

---

`Tags` 

## Result & Review

벌써 세 번째 코드포스 대회에 참가하였다.

참가하기 전에는 디비전 구분이 없어서 너무 어렵지 않을까라는 걱정이 있었지만, 막상 문제를 보니 초반 문제들은 충분히 풀 수 있는 것들이었다.

일단 A, B, C번 문제는 모두 수학 문제였다.

이미 지난 대회에서 초반 문제들을 알고리즘이나 자료구조로 해결하려다가 망한 적이 있기 때문에 무조건 수학적으로 접근해서 풀어보려고 했고, 실제로 수월하게 풀 수 있었다.

각 문제당 10분, 20분, 20분 이렇게 걸렸다.

문제는 D번에서 수학적인 접근은 다 해두고 원하는 값을 어떻게 찾아야하는지를 몰라서 엄청 해맸다는 것이다...

중간에 그 뒤 문제들을 보았지만, 차라리 D번을 푸는게 나아보여서 그냥 남은 시간 모두 D번에 할애하기로 했다.

그러다 종료 10분 전에 DP로 풀 수 있다는 것을 깨닫고 어찌저찌 구현하여 30초를 남기고 제출한 코드가 AC를 받았다.

<img src="https://user-images.githubusercontent.com/88201512/153802159-03c5c13b-c644-4e99-aa96-8cc47f99e765.jpg">

<center>기적과 같은 2:29 AC (시간제한 2:30)</center>

상당히 확신이 있었기 때문에 예상치 못한 예외들만 없길 기도했는데, 다행히 이후 테스트에서도 통과되었다.

그렇게 총 8문제가 출제된 이번 대회에서 4문제를 풀었다.

<img src="https://user-images.githubusercontent.com/88201512/153802318-e0a4100b-3c0d-4396-8271-3410d34d769b.jpg">

그래도 이제 조금씩 수학적인 접근 방식이 익숙해지는 느낌이라 대회를 더 참여하다보면 앞에 있는 수학 문제들을 빠르게 풀 수 있을 것 같았다.

D번 DP 풀이를 빠르게 생각하지 못한 건 좀 많이 아쉽긴 하지만... 최근 문자열 알고리즘과 세그먼트 트리에 대해 공부하다보니 다른 알고리즘 감각이 떨어진 듯 하다.

매주 대회 참여하고 업솔빙을 하다보면 잘해지겠지...?

<br/>

## A. Sorting Parts

[A번 문제 링크](https://codeforces.com/contest/1637/problem/A)

**[PROBLEM]**

길이가 $n$인 배열 $a$가 주어진다.

어떤 정수 $len$($1 \leq len < n$)을 선택해서 앞 $len$개의 숫자들과 나머지 $n - len$개의 숫자들을 각각 정렬할 수 있다.

위 작업을 수행했을 때, 전체 배열이 정렬되지 않을 수 있는지 판단하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 100$)가 주어진다.

각 테스트케이스는 정수 $n$($2 \leq n \leq 10^4$)과 $n$개의 정수 $a_1, a_2, \dots, a_n$($1 \leq a_i \leq 10^9$)로 이루어진다.

**[OUTPUT]**

배열이 정렬되지 않을 수 있으면 "YES", 반드시 정렬된다면 "NO"를 출력한다.

---

### [SOLUTION] Math

어떤 $len$을 선택해도 반드시 전체 배열이 정렬되기 위해서는 **기존 배열이 정렬된 상태**여야한다.

따라서 배열 $a$가 오름차순으로 정렬되었으면 "NO", 아니면 "YES"를 출력하면 된다.

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        vector<int> a(n);
        for (int i = 0; i < n; i++) cin >> a[i];

        int A = a[0];
        bool flg = 0;
        for (int i = 1; i < n; i++)
        {
            if (A > a[i]) flg = 1;
            A = a[i];
        }
        cout << (flg ? "YES" : "NO") << "\n";
    }
}
```

<br/>

## B. MEX and Array

**[PROBLEM]**

배열 $b_1, b_2, \dots, b_k$를 $c$개의 연속한 구간 $\[l_1, r_1\], \dots, \[l_c, r_c\]$으로 나누었다.

$l_1 = 1$, $r_c = k$이고, 연속한 구간들이므로 $2 \leq i \leq c$를 만족하는 정수 $i$에 대해 $r_{i-1} + 1 = l_i$가 성립한다.

이때의 ***cost***을 다음과 같이 정의하자.

\begin{aligned}
c + \sum_{i = 1}^c mex(\{ b_{l_i}, \dots, b_{r_i} \})
\end{aligned}

정수들의 부분집합 $S$에 대해 $mex(S)$는 $S$에 속하지 않는 가장 작은 음이 아닌 정수를 의미한다.

배열 $b_1, b_2, \dots, b_k$의 ***value***를 ***cost***의 최댓값이라고 정의한다.

길이가 $n$인 배열 $a$가 주어질 때, 모든 subarray들의 ***value***의 합을 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 30$)가 주어진다.

각 테스트케이스는 정수 $n$($1 \leq n \leq 100$)과 $n$개의 정수 $a_1, a_2, \dots, a_n$($0 \leq a_i \leq 10^9$)로 이루어진다.

**[OUTPUT]**

각 테스트케이스에 대해 배열 $a$의 모든 subarray들의 ***value***의 합을 출력한다.

---

### [SOLUTION] Math

배열 $a_1 = 0, a_2 = 1, \dots, a_k = k-1$을 생각해보자.

$\sum mex(S_i)$의 최댓값은 $c = 1$일 때 $k$가 되고, 이때의 cost는 $1 + k$이다.

그런데 $c = k$로 나누면 $\sum mex(S_i) = 1$이 되어 마찬가지로 cost가 $1 + k$이다.

따라서 **아무리** $\sum mex(S_i)$**가 큰** $c$**를 찾아도,** $c = k$**로 나눈 것의 cost보다 작거나 같다**.

이로부터 배열 $b_1, b_2, \dots, b_k$의 value는 다음과 같이 구할 수 있다.

<center>$k +$ ($b_1, \dots, b_k$에 있는 0의 개수)</center>

따라서 길이가 $n$인 배열 $a$의 모든 subarray들의 value의 합은 다음과 같다.

<center>(모든 subarray의 길이의 합) + $\sum_{a_i = 0, 1 \leq i \leq n}$ ($a_i$를 포함하는 subarray의 개수)</center>

```cpp
#include <iostream>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;

        int a, ans = 0;
        for (int i = 1; i <= n; i++)
        {
            ans += i * (n + 1 - i); // 길이가 i인 subarray들의 길이의 합
            cin >> a;
            if (a == 0) ans += i * (n + 1 - i); // a_i를 포함하는 subarray들의 개수
        }
        cout << ans << "\n";
    }
}
```

<br/>

## C. Andrew and Stones

**[PROBLEM]**

앤드류는 $n$개의 돌무더기가 있다.

$i$번째 돌무더기는 $a_i$개의 돌로 이루어져있다.

앤드류는 다음 작업을 여러 번 수행해서 모든 돌을 첫 번째 또는 $n$번째 돌무더기로 옮기려고 한다.

- 서로 다른 세 정수 $i, j, k$($1 \leq i < j < k \leq n$)를 선택하여 $j$번째 돌무더기에서 두 개의 돌을 빼서 $i$, $k$번째 돌무더기에 각각 하나씩 놓는다.
- 
- 이때 $j$번째 돌무더기에는 반드시 두 개 이상의 돌이 있어야한다.

모든 돌을 첫 번째 또는 $n$번째 돌무더기로 옮길 때 필요한 최소 작업 횟수를 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 10^4$)가 주어진다.

각 테스트케이스는 정수 $n$($3 \leq n \leq 10^5$)과 $n$개의 정수 $a_1, a_2, \dots, a_n$($1 \leq a_i \leq 10^9$)로 이루어진다.

**[OUTPUT]**

각 테스트케이스에 대해 돌을 전부 옮기는데 필요한 최소 횟수를 출력한다.

모든 돌을 옮기는 것이 불가능하면 -1을 출력한다.

---

### [SOLUTION] Math




















