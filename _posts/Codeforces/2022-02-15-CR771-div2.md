---
title: "[CF#4] Codeforces Round #771 (Div. 2)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Codeforces
use_math: true
comments: true

---

`Tags` 

## Result & Review

지난 대회 문제들을 업솔빙하기도 전에 대회가 또 열려서 이틀만에 또 대회에 참가하게 되었다.

총 6문제가 출제되었는데, 앞 세 문제는 큰 어려움 없이 해결할 수 있었다.

A, B, C 문제를 푸는데 각각 10분, 10분, 20분 정도가 걸렸고, 대회 시작 후 40분이 지난 시점에서 D번 문제로 넘어갔다.

D번 문제를 어떻게 풀어야하는지 금방 감이 잡혔지만, 직접 구현하는 도중 여러 문제가 생겨 아이디어를 조금씩 수정하는 과정에서 시간이 오래 걸렸다.

20분 정도가 남아 E번 문제를 풀 수 있을까 했지만, 택도 없었다.

최종 결과는 다음과 같았다.

<img src="https://user-images.githubusercontent.com/88201512/153982362-8bb042bd-8c9b-4cd0-97be-cc323c2e71cd.jpg">

4번째 대회만에 민트색에 도달하였다!

<img src="https://user-images.githubusercontent.com/88201512/153982445-28ce4cc0-7818-4851-820f-04c2a2e8378e.jpg">

6문제짜리 대회에서 4솔을 한 것은 처음이라 나름 뿌듯했다 ㅎㅎ

<br/>

## A. Reverse

[A번 문제 링크](https://codeforces.com/contest/1638/problem/A)

**[PROBLEM]**

길이가 $n$인 순열 $p_1, p_2, \dots, p_n$가 주어진다.

두 정수 $l, r$($1 \leq l \leq r \leq n$)을 선택해서 $p_l, \dots, p_r$을 뒤집을 수 있다.

위 작업을 정확히 한 번 수행해서 얻을 수 있는 순열 중 **사전순으로 가장 작은 것**을 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 500$)가 주어진다.

각 테스트케이스는 정수 $n$($1 \leq n \leq 500$)과 $n$개의 정수 $p_1, p_2, \dots, p_n$($1 \leq p_i \leq n$)로 이루어진다.

**[OUTPUT]**

만들 수 있는 가장 작은 순열을 출력한다.

---

### [SOLUTION] Math

사전순으로 가장 작은 순열은 정수 $i$($1 \leq i \leq n$)에 대해 $p_i = i$인 순열이다.

따라서 주어진 순열에서 $p_i = i$**를 만족하지 않는 가장 작은** $i$를 $l$, $p_j = l$을 만족하는 $j$를 $r$이라 하고 뒤집으면 된다.

만약 모든 $i$에 대해 $p_i = i$를 만족하면 주어진 순열을 그대로 출력하면 된다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        vector<int> p(n + 1);
        for (int i = 1; i <= n; i++) cin >> p[i];

        int l = 0, r;
        for (int i = 1; i <= n; i++)
        {
            if (p[i] != i)
            {
                l = i;
                break;
            }
        }

        if (l != 0)
        {
            for (int i = l + 1; i <= n; i++)
            {
                if (p[i] == l)
                {
                    r = i;
                    break;
                }
            }
            while (l < r) swap(p[l++], p[r--]);
        }

        for (int i = 1; i <= n; i++) cout << p[i] << " ";
        cout << "\n";
    }
}
```

<br/>

## B. Odd Swap Sort

[B번 문제 링크](https://codeforces.com/contest/1638/problem/B)

**[PROBLEM]**

길이가 $n$인 배열 $a_1, a_2, \dots, a_n$가 주어진다.

정수 $i$($1 \leq i < n$)에 대해 $a_i + a_{i + 1}$이 홀수이면 $a_i$와 $a_{i + 1}$을 교환할 수 있다.

이를 이용해서 주어진 배열 $a$을 오름차순으로 정렬할 수 있는지 판단하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 10^5$)가 주어진다.

각 테스트케이스는 정수 $n$($1 \leq n \leq 10^5$)과 $n$개의 정수 $a_1, a_2, \dots, a_n$($1 \leq a_i \leq 10^9$)로 이루어진다.

**[OUTPUT]**

각 테스트케이스에 대해 오름차순으로 정렬이 가능하면 "YES", 불가능하면 "NO"를 출력한다.

---

### [SOLUTION] Math

이 문제의 핵심은 다음 사실을 빠르게 캐치하는 것이다.

> 두 정수 $i, j(i < j)$에 대해 $a_i > a_j$이면 반드시 $a_i + a_j$는 홀수여야한다.

전체 배열을 오름차순으로 정렬하기 위해서는 $a_i$와 $a_j$의 순서가 바뀌어야하는데, 그러기 위해서는 반드시 두 수를 직접 교환해야하기 때문이다.

위 사실을 바탕으로 배열을 오름차순으로 정렬할 수 있는 조건을 구할 수 있다.

> **짝수들로만 이루어진 부분수열과 홀수들로만 이루어진 부분수열은 각각 오름차순으로 정렬되어 있어야 한다.**

```cpp
#include <iostream>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        
        int a;
        int odd = 1, even = 0; // 마지막으로 등장한 홀수, 짝수
        bool flg = 1;
        for (int i = 0; i < n; i++)
        {
            cin >> a;
            if (a % 2)
            {
                if (odd > a) flg = 0;
                odd = a;
            }
            else
            {
                if (even > a) flg = 0;
                even = a;
            }
        }
        
        cout << (flg ? "YES" : "NO") << "\n";
    }
}
```

<br/>

## C. Inversion Graph

[C번 문제 링크](https://codeforces.com/contest/1638/problem/C)

**[PROBLEM]**

길이가 $n$인 순열 $p_1, p_2, \dots, p_n$가 주어진다.

다음과 같은 방법으로 undirected graph를 만들었다.

- $i < j$, $p_i > p_j$를 만족하는 정수 $i, j$에 대해 정점 $i, j$ 사이에 간선을 추가한다.

이렇게 얻은 그래프의 연결 요소(connected component)들의 개수를 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 10^5$)가 주어진다.

각 테스트케이스는 정수 $n$($1 \leq n \leq 10^5$)과 $n$개의 정수 $p_1, p_2, \dots, p_n$($1 \leq p_i \leq n$)로 이루어진다.

**[OUTPUT]**

각 테스트케이스에 대해 그래프의 연결 요소의 개수를 출력한다.

---

### [SOLUTION] Math

처음에 연결 요소만 보고 Union-Find를 사용하려고 했는데, 직접 간선들을 모두 구하면 $O(n^2)$이라 빠르게 다른 방법을 찾았다.

만약 $p_1 = 1$이면 1번 정점과는 어떤 정점도 연결될 수 없으므로 그 자체로 하나의 연결 요소가 된다.

1보다 큰 정수 $k$에 대해 $p_1 = k$인 경우를 생각해보자.

그렇다면 1번 정점은 $1 \leq p_i < k$를 만족하는 $k-1$개의 $i$에 대해 정점 $i$와 연결된다.

이를 바탕으로 조금 더 확장시켜보자.

> $p_1, \dots, p_k$가 1부터 $k$의 순열이라면, 1번 정점부터 $k$번 정점은 하나의 연결 요소를 이루게 된다.

왜냐하면 $p_{k+1}, \dots, p_n$은 모두 $k$보다 크기 때문이다.

즉, **어떤 정수** $i$**에 대해서** $p_1, \dots, p_i$**의 최댓값이** $i$**이면 1번 정점부터** $i$**번 정점은 하나의 연결 요소를 이룬다.**

```cpp
#include <iostream>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;

        int p; cin >> p;
        int m = p, k = 1; // m: p_i까지의 최댓값, k: 연결 요소의 개수
        for (int i = 1; i < n; i++)
        {
            cin >> p;
            if (m > p) continue;
            
            if (m == i) k++;
            m = p;
        }
        cout << k << "\n";
    }
}
```

<br/>

## D. Big Brush

[D번 문제 링크](https://codeforces.com/contest/1638/problem/D)

**[PROBLEM]**

$n \times m$ 크기의 그림을 발견하였다.

그림의 각 칸은 하나의 색으로 칠해져 있는데, $i$행 $j$열에 칠해진 색을 $c_{i, j}$라고 하자.

이 그림은 $2 \times 2$ 크기의 붓으로 다음과 같은 과정을 반복해서 칠해졌다.

> 행과 열을 의미하는 두 정수 $i, j$($1 \leq i < n, 1 \leq j < m$)와 색을 의미하는 정수 $k$($1 \leq k \leq nm$)에 대해,
> 
> $(i, j)$, $(i + 1, j)$, $(i, j + 1)$, $(i + 1, j + 1)$ 칸들을 $k$로 칠한다.

여러 번 칠해진 칸은 마지막으로 칠해진 색이 된다.

최대 $nm$번 칠해서 발견한 그림을 만들 수 있는지 판단하여라.

**[INPUT]**

첫 번째 줄에는 두 정수 $n, m$($2 \leq n, m \leq 1000$)이 주어진다.

다음 $n$개의 줄에 걸쳐 그림의 정보가 주어진다.($1 \leq c_{i, j} \leq nm$)

**[OUTPUT]**

최대 $nm$번 칠해서 그림을 만드는 것이 불가능하다면 $-1$을 출력한다.

그림을 만들 수 있으면, 첫 번째 줄에 칠하는 횟수 $q(1 \leq q \leq nm)$을 출력한다.

그리고 다음 $q$줄에 걸쳐 어느 위치를 어느 색으로 칠해야하는지를 의미하는 세 정수 $i, j, c$를 출력한다.

---

### [SOLUTION] Implementation

기본적인 아이디어는 $2 \times 2$이 모두 같은 색인 위치부터 **거꾸로 추적**하는 것이다.

같은 색으로 칠해준 $2 \times 2$는 **어떤 색이던 가질 수 있으므로** 0으로 표시하였다.

위치 $i, j$에 색을 칠할 수 있으면 해당 색의 번호를 반환하고, 서로 다른 색이 존재해서 칠할 수 없으면 -1을 반환하는 함수를 구현하였다.

```cpp
int canPaint(int i, int j)
{
    int P = p[i][j];
    int di[] = { 1, 0, 1 }, dj[] = { 0, 1, 1 };
    for (int k = 0; k < 3; k++)
    {
        int I = i + di[k], J = j + dj[k];
        if (p[I][J] == 0) continue; // 0은 어떤 색이던 상관없으므로 continue
        if (P == 0) P = p[I][J];
        else if (P != p[I][J]) return -1; // 다른 색이 존재하면 -1 반환
    }
    return P ? P : 1;
}
```

4칸이 모두 0인 경우에는 아무 색깔이나 칠해도 상관이 없기 때문에 1을 반환하도록 구현하였다.

이제 역추적하는 과정을 정리해보면 다음과 같다.

1. 그림에서 4칸이 모두 같은 색인 위치를 큐(queue)에 삽입한다.
2. 큐에 저장된 위치에 색을 칠하고 해당 위치를 큐에서 삭제한다. 이때 벡터(vector)에 색을 칠한 위치와 칠한 색을 저장한다.
3. 색을 칠한 위치 주변에 추가적으로 색을 칠할 수 있는 곳이 있으면 큐에 삽입한다.
4. 큐에 더 이상 원소가 없을 때까지 2~3번을 반복한다.

그렇다면 만들 수 없는 그림은 어떻게 판별할 수 있을까?

같은 위치에 여러 번 칠하는 것은 무의미하므로, 만약 그림을 그릴 수 있다면 $(n-1)(m-1)$번 이내에 그림을 그릴 수 있다.

그림을 그리기 위한 **최소 횟수**를 구하는 문제가 아니기 때문에 반드시 모든 위치에 한 번씩 칠하도록 해줘도 된다.

이렇게 구현하면 그림을 그리는 것이 불가능한 경우, 칠하는 작업에 대한 정보를 저장한 벡터의 크기가 $(n-1)(m-1)$보다 작아지게 된다.

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;
typedef pair<int, int> ii;

int p[1001][1001];

bool visited[1000][1000];

int canPaint(int i, int j)
{
    int P = p[i][j];
    int di[] = { 1, 0, 1 }, dj[] = { 0, 1, 1 };
    for (int k = 0; k < 3; k++)
    {
        int I = i + di[k], J = j + dj[k];
        if (p[I][J] == 0) continue;
        if (P == 0) P = p[I][J];
        else if (P != p[I][J]) return -1;
    }
    return P ? P : 1;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int n, m; cin >> n >> m;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> p[i][j];
    
    queue<ii> q; // 색을 칠할 수 있는 위치 저장
    for (int i = 1; i < n; i++)
    {
        for (int j = 1; j < m; j++)
        {
            if (canPaint(i, j) != -1)
            {
                q.push({ i, j });
                visited[i][j] = 1;
            }
        }
    }

    vector<pair<ii, int>> v; // {위치, 색}을 저장
    int di[] = { -1, 0, 1, 0, -1, -1, 1, 1}, dj[] = { 0, -1, 0, 1, -1, 1, -1, 1};
    while (!q.empty())
    {
        int i = q.front().first, j = q.front().second;
        q.pop();

        v.push_back({ {i, j}, canPaint(i, j) });
        p[i][j] = p[i + 1][j] = p[i][j + 1] = p[i + 1][j + 1] = 0;

        for (int w = 0; w < 8; w++)
        {
            int I = i + di[w], J = j + dj[w];
            if (I <= 0 || I >= n || J <= 0 || J >= m || visited[I][J]) continue;
            if (canPaint(I, J) != -1)
            {
                q.push({ I, J });
                visited[I][J] = 1;
            }
        }
    }

    if (v.size() != (n - 1) * (m - 1)) cout << "-1\n";
    else
    {
        cout << v.size() << "\n";
        for (int i = v.size() - 1; i >= 0; i--)
            cout << v[i].first.first << " " << v[i].first.second << " " << v[i].second << "\n";
    }
}
```

<br/>

## E. Colorful Operations

[E번 문제 링크](https://codeforces.com/contest/1638/problem/E)

**[PROBLEM]**

길이가 $n$인 배열 $a_1, a_2, \dots, a_n$의 각 원소 $a_i$는 **value**와 **color**를 갖는다.

모든 원소의 value와 color의 초기값은 각각 0과 1이다.

배열 $a$에 대한 쿼리 $q$개가 주어진다.

- Color $l$ $r$ $c$: 원소 $a_l, \dots, a_r$($1 \leq l \leq r \leq n$)의 color를 $c$로 바꾼다.
- Add $c$ $x$: color가 $c$($1 \leq c \leq n$)인 모든 원소들의 value에 $x$($-10^9 \leq x \leq 10^9$)를 더한다.
- Query $i$: $a_i$($1 \leq i \leq n$)를 출력한다.

**[INPUT]**

첫 번째 줄에는 두 정수 $n, q$($1 \leq n, q \leq 10^6$)가 주어진다.

다음 $q$개의 줄에 걸쳐 쿼리가 주어진다.

**[OUTPUT]**

주어진 쿼리를 처리한다.

---

### [SOLUTION] Fenwick Tree(or Segment Tree) + Lazy Propagation

구간 업데이트를 구현하기 전에, $l = r$라고 가정하고 어떻게 해결할지 생각해보자.

주어진 $c, x$에 대해 색깔이 $c$인 원소들에 $x$를 더하는 두 번째 쿼리를 빠르게 처리하기 위해 세그먼트 트리에서 사용한 [lazy propagation](https://damo1924.github.io/algorithm/SegmentTree/#3-lazy-propagation) 개념을 이용하자.

> $lazy\[c\]$ = 색깔이 $c$인 원소들에 더해주어야하는 값

$i$번째 원소들의 값을 저장하고 있는 배열을 $a\[i\]$, 색깔을 저장하고 있는 배열을 $color\[i\]$라고 하자.

이를 이용하면 각 쿼리를 다음과 같이 처리할 수 있다.

- Color $l$ $r$ $c$ : 
  $l = r = i$, $c' = color\[i\]$이라고 하면,
\begin{aligned}
a\[i\] := a\[i\] + lazy\[c'\] - lazy\[c\], color\[i\] := c
\end{aligned}
- Add $c$ $x$ :
\begin{aligned}
lazy\[c\] := lazy\[c\] + x
\end{aligned}
- Query $i$ :
  다음을 출력한다.
\begin{aligned}
a\[i\] + lazy\[color\[i\]\]
\end{aligned}

모든 쿼리를 $O(1)$로 처리할 수 있다는 것을 알 수 있다.

이제 $l = r$ 조건을 지우고 생각해보자.

구간에 속하는 원소들의 색깔을 업데이트해주는 쿼리는 다음 두 가지 작업을 수행해야한다.

- $a\[i\]$의 구간 업데이트
- $color\[i\]$의 구간 업데이트

이를 효율적으로 처리하기 위해서 **세그먼트 트리** 또는 **펜윅 트리**를 이용할 수 있다.

모든 $i$에 대해서 $a\[i\] = \sum_{k=1}^i b\[i\]$를 만족하는 배열 $b$에 대한 펜윅 트리를 정의하면, 다음과 같이 $a\[i\]$를 처리할 수 있게 된다.

- Color $l$ $r$ $c$ : 펜윅 트리에 $b\[l\]$와 $b\[r\]$의 업데이트를 적용
- Query $i$ : 펜윅 트리에서 구간 $\[1, i\]$의 합

각 작업은 $O(\log n)$의 시간복잡도로 수행할 수 있다.

또, `<set>` 자료구조를 이용해서 색이 바뀌는 경계값을 저장하면 $O(\log n)$의 시간복잡도로 다음 작업을 수행할 수 있게 된다.

- $i$번째 원소의 색깔 구하기 : $i$가 속하는 구간의 경계값의 색깔과 같다. (경계값은 `lower_bound()`로 구할 수 있다.)
- $\[l, r\]$의 색깔을 $c$로 업데이트 : 새로운 경계값을 삽입하거나 기존의 경계값을 제거해서 구간을 분리/확장한다.

구간 $\[l_i, r_i\]$의 색깔이 $c_i$이면, set에 $r_1, r_2, \dots$을 저장하고 구간의 색깔을 $color\[r_i\] = c_i$와 같이 배열에 저장하는 것이다.

더 자세한 설명은 아래 코드의 주석으로 남겨두었다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <set>
using namespace std;
typedef long long ll;
typedef pair<int,int> ii;
const int N = 1e6 + 10;

struct Fenwick {
    int n;
    vector<ll> bit;
    
    Fenwick(int _n) {
        n = _n + 1;
        bit.resize(n);
        fill(bit.begin(), bit.end(), 0);
    }
    
    void update(int i, ll v) {
        for( ; i < n; i += (i & -i)) bit[i] += v;
    }
    
    void update(int l, int r, ll v) {
        update(l, v);
        update(r + 1, -v);
    }
    
    ll sum(int i) {
        ll res = 0;
        for( ; i; i &= i - 1) res += bit[i];
        return res;
    }
};

int color[N]; // color[i]: i번째 원소의 color
int _left[N]; // _left[i]: i번째 원소의 구간의 왼쪽 끝

ll lazy[N]; // lazy[c]: 색깔이 c인 원소에 더해주어야하는 값

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int n, q; cin >> n >> q;
    
    set<int> interval; // 색깔이 바뀌는 경계값을 저장
    interval.insert(n);
    
    Fenwick f(n);
    
    _left[n] = 1; // 초기 상태: 모든 원소의 색깔이 1
    color[n] = 1;
    
    while (q--)
    {
        string s; cin >> s;
        if (s == "Add")
        {
            ll x, y; cin >> x >> y;
            lazy[x] += y;
        }
        else if (s == "Query")
        {
            int x; cin >> x;
            int v = *interval.lower_bound(x); // x가 속하는 구간의 오른쪽 경계값
            cout << f.sum(x) + lazy[color[v]] << "\n";
        }
        else
        {
            int l, r, c; cin >> l >> r >> c;
            while (true)
            {
                // l번째 원소가 속하는 구간: [left[v], v], 구간의 색: color[v]
                int v = *interval.lower_bound(l);
                
                // [left[v], v]에서 [l, r]에 포함되지 않는 구간 [left[v], l-1]을 분리
                if (_left[v] < l) {
                    color[l - 1] = color[v];
                    _left[l - 1] = _left[v];
                    interval.insert(l - 1);
                }
                
                // [l, r]와 [left[v], v]가 겹치는 구간에 lazy 업데이트
                f.update(max(l, _left[v]), min(r, v), lazy[color[v]]);
                
                // [l, v]가 [l, r]에 포함되므로 경계값 v를 제거하고 다음 경계값을 탐색
                if (v < r) {
                    interval.erase(v);
                    color[v] = 0;
                    	_left[v] = 0;
                }
                // [left[v], v]에서 [l, r]에 포함되지 않는 구간 [r + 1, v]을 분리하고 종료
                else {
                    if (r < v) {
                        _left[v] = r + 1;
                        interval.insert(r);
                    }
                    color[r] = c;
                    _left[r] = l;
                    break;
                }
            }
		        f.update(l, r, -lazy[c]); // 업데이트된 색깔 c의 lazy[c]를 빼준다.
        }
    }
}
```










