---
title: "[CF#4] Codeforces Round #771 (Div. 2)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Codeforces
use_math: true
comments: true

---

`Tags` 

## Result & Review

지난 대회 문제들을 업솔빙하기도 전에 대회가 또 열려서 이틀만에 또 대회에 참가하게 되었다.

총 6문제가 출제되었는데, 앞 세 문제는 큰 어려움 없이 해결할 수 있었다.

A, B, C 문제를 푸는데 각각 10분, 10분, 20분 정도가 걸렸고, 대회 시작 후 40분이 지난 시점에서 D번 문제로 넘어갔다.

D번 문제를 어떻게 풀어야하는지 금방 감이 잡혔지만, 직접 구현하는 도중 여러 문제가 생겨 아이디어를 조금씩 수정하는 과정에서 시간이 오래 걸렸다.

20분 정도가 남아 E번 문제를 풀 수 있을까 했지만, 택도 없었다.

최종 결과는 다음과 같았다.

<img src="https://user-images.githubusercontent.com/88201512/153982362-8bb042bd-8c9b-4cd0-97be-cc323c2e71cd.jpg">

4번째 대회만에 민트색에 도달하였다!

<img src="https://user-images.githubusercontent.com/88201512/153982445-28ce4cc0-7818-4851-820f-04c2a2e8378e.jpg">

6문제짜리 대회에서 4솔을 한 것은 처음이라 나름 뿌듯했다 ㅎㅎ

<br/>

## A. Reverse

[A번 문제 링크](https://codeforces.com/contest/1638/problem/A)

**[PROBLEM]**

길이가 $n$인 순열 $p_1, p_2, \dots, p_n$가 주어진다.

두 정수 $l, r$($1 \leq l \leq r \leq n$)을 선택해서 $p_l, \dots, p_r$을 뒤집을 수 있다.

위 작업을 정확히 한 번 수행해서 얻을 수 있는 순열 중 **사전순으로 가장 작은 것**을 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 500$)가 주어진다.

각 테스트케이스는 정수 $n$($1 \leq n \leq 500$)과 $n$개의 정수 $p_1, p_2, \dots, p_n$($1 \leq p_i \leq n$)로 이루어진다.

**[OUTPUT]**

만들 수 있는 가장 작은 순열을 출력한다.

---

### [SOLUTION] Math

사전순으로 가장 작은 순열은 정수 $i$($1 \leq i \leq n$)에 대해 $p_i = i$인 순열이다.

따라서 주어진 순열에서 $p_i = i$**를 만족하지 않는 가장 작은** $i$를 $l$, $p_j = l$을 만족하는 $j$를 $r$이라 하고 뒤집으면 된다.

만약 모든 $i$에 대해 $p_i = i$를 만족하면 주어진 순열을 그대로 출력하면 된다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        vector<int> p(n + 1);
        for (int i = 1; i <= n; i++) cin >> p[i];

        int l = 0, r;
        for (int i = 1; i <= n; i++)
        {
            if (p[i] != i)
            {
                l = i;
                break;
            }
        }

        if (l != 0)
        {
            for (int i = l + 1; i <= n; i++)
            {
                if (p[i] == l)
                {
                    r = i;
                    break;
                }
            }
            while (l < r) swap(p[l++], p[r--]);
        }

        for (int i = 1; i <= n; i++) cout << p[i] << " ";
        cout << "\n";
    }
}
```

<br/>

## B. Odd Swap Sort

[B번 문제 링크](https://codeforces.com/contest/1638/problem/B)

**[PROBLEM]**

길이가 $n$인 배열 $a_1, a_2, \dots, a_n$가 주어진다.

정수 $i$($1 \leq i < n$)에 대해 $a_i + a_{i + 1}$이 홀수이면 $a_i$와 $a_{i + 1}$을 교환할 수 있다.

이를 이용해서 주어진 배열 $a$을 오름차순으로 정렬할 수 있는지 판단하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 10^5$)가 주어진다.

각 테스트케이스는 정수 $n$($1 \leq n \leq 10^5$)과 $n$개의 정수 $a_1, a_2, \dots, a_n$($1 \leq a_i \leq 10^9$)로 이루어진다.

**[OUTPUT]**

각 테스트케이스에 대해 오름차순으로 정렬이 가능하면 "YES", 불가능하면 "NO"를 출력한다.

---

### [SOLUTION] Math

이 문제의 핵심은 다음 사실을 빠르게 캐치하는 것이다.

> 두 정수 $i, j(i < j)$에 대해 $a_i > a_j$이면 반드시 $a_i + a_j$는 홀수여야한다.

전체 배열을 오름차순으로 정렬하기 위해서는 $a_i$와 $a_j$의 순서가 바뀌어야하는데, 그러기 위해서는 반드시 두 수를 직접 교환해야하기 때문이다.

위 사실을 바탕으로 배열을 오름차순으로 정렬할 수 있는 조건을 구할 수 있다.

- **짝수들로만 이루어진 부분수열과 홀수들로만 이루어진 부분수열은 각각 오름차순으로 정렬되어 있어야 한다.**

```cpp
#include <iostream>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        
        int a;
        int odd = 1, even = 0; // 마지막으로 등장한 홀수, 짝수
        bool flg = 1;
        for (int i = 0; i < n; i++)
        {
            cin >> a;
            if (a % 2)
            {
                if (odd > a) flg = 0;
                odd = a;
            }
            else
            {
                if (even > a) flg = 0;
                even = a;
            }
        }
        
        cout << (flg ? "YES" : "NO") << "\n";
    }
}
```

<br/>

## C. Inversion Graph

[C번 문제 링크](https://codeforces.com/contest/1638/problem/C)

**[PROBLEM]**

길이가 $n$인 순열 $p_1, p_2, \dots, p_n$가 주어진다.

다음과 같은 방법으로 undirected graph를 만들었다.

- $i < j$, $p_i > p_j$를 만족하는 정수 $i, j$에 대해 정점 $i, j$ 사이에 간선을 추가한다.

이렇게 얻은 그래프의 연결 요소(connected component)들의 개수를 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 10^5$)가 주어진다.

각 테스트케이스는 정수 $n$($1 \leq n \leq 10^5$)과 $n$개의 정수 $p_1, p_2, \dots, p_n$($1 \leq p_i \leq n$)로 이루어진다.

**[OUTPUT]**

각 테스트케이스에 대해 그래프의 연결 요소의 개수를 출력한다.

---

### [SOLUTION] Math

처음에 연결 요소만 보고 Union-Find를 사용하려고 했는데, 직접 간선들을 모두 구하면 $O(n^2)$이라 빠르게 다른 방법을 찾았다.

만약 $p_1 = 1$이면 1번 정점과는 어떤 정점도 연결될 수 없으므로 그 자체로 하나의 연결 요소가 된다.

1보다 큰 정수 $k$에 대해 $p_1 = k$인 경우를 생각해보자.

그렇다면 1번 정점은 $1 \leq p_i < k$를 만족하는 $k-1$개의 $i$에 대해 정점 $i$와 연결된다.

이를 바탕으로 조금 더 확장시켜보자.

> $p_1, \dots, p_k$가 1부터 $k$의 순열이라면, 1번 정점부터 $k$번 정점은 하나의 연결 요소를 이루게 된다.

왜냐하면 $p_{k+1}, \dots, p_n$은 모두 $k$보다 크기 때문이다.

즉, **어떤 정수** $i$**에 대해서** $p_1, \dots, p_i$**의 최댓값이** $i$**이면 1번 정점부터** $i$**번 정점은 하나의 연결 요소를 이룬다.**

```cpp
#include <iostream>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;

        int p; cin >> p;
        int m = p, k = 1; // m: p_i까지의 최댓값, k: 연결 요소의 개수
        for (int i = 1; i < n; i++)
        {
            cin >> p;
            if (m > p) continue;
            
            if (m == i) k++;
            m = p;
        }
        cout << k << "\n";
    }
}
```

<br/>

## D. Big Brush

[D번 문제 링크](https://codeforces.com/contest/1638/problem/D)

**[PROBLEM]**

$n \times m$ 크기의 그림을 발견하였다.

그림의 각 칸은 하나의 색으로 칠해져 있는데, $i$행 $j$열에 칠해진 색을 $c_{i, j}$라고 하자.

이 그림은 $2 \tims 2$ 크기의 붓으로 다음과 같은 과정을 반복해서 칠해졌다.

> 행과 열을 의미하는 두 정수 $i, j$($1 \leq i < n, 1 \leq j < m$)와 색을 의미하는 정수 $k$($1 \leq k \leq nm$)에 대해,
> 
> $(i, j)$, $(i + 1, j)$, $(i, j + 1)$, $(i + 1, j + 1)$ 칸들을 $k$로 칠한다.

여러 번 칠해진 칸은 마지막으로 칠해진 색이 된다.

최대 $nm$번 칠해서 발견한 그림을 만들 수 있는지 판단하여라.

**[INPUT]**

첫 번째 줄에는 두 정수 $n, m$($2 \leq n, m \leq 1000$)이 주어진다.

다음 $n$개의 줄에 걸쳐 그림의 정보가 주어진다.($1 \leq c_{i, j} \leq nm$)

**[OUTPUT]**

최대 $nm$번 칠해서 그림을 만드는 것이 불가능하다면 $-1$을 출력한다.

그림을 만들 수 있으면, 첫 번째 줄에 칠하는 횟수 $q(1 \leq q \leq nm)$을 출력한다.

그리고 다음 $q$줄에 걸쳐 어느 위치를 어느 색으로 칠해야하는지를 의미하는 세 정수 $i, j, c$를 출력한다.

---

### [SOLUTION] 

같은 위치에 여러 번 칠하는 것은 무의미하므로, 만약 그림을 만들 수 있다면 $(n-1)(m-1)$번 




```cpp
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include <queue>
#include <math.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> ii;

int p[1001][1001];

int cnt[1000][1000];

bool visited[1000][1000];

int canPaint(int i, int j)
{
    int P = p[i][j];
    int di[] = { 1, 0, 1 }, dj[] = { 0, 1, 1 };
    for (int k = 0; k < 3; k++)
    {
        int I = i + di[k], J = j + dj[k];
        if (P == 0) P = p[I][J];
        else if (p[I][J] == 0) continue;
        else
        {
            if (P != p[I][J]) return -1;
        }
    }
    return P ? P : 1;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int n, m; cin >> n >> m;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> p[i][j];

    queue<ii> q;
    for (int i = 1; i < n; i++)
    {
        for (int j = 1; j < m; j++)
        {
            if (canPaint(i, j) != -1)
            {
                q.push({ i, j });
                visited[i][j] = 1;
            }
        }
    }

    vector<pair<ii, int>> v;
    int di[] = { -1, 0, 1, 0, -1, -1, 1, 1}, dj[] = { 0, -1, 0, 1, -1, 1, -1, 1};
    while (!q.empty())
    {
        int i = q.front().first, j = q.front().second;
        q.pop();

        v.push_back({ {i, j}, canPaint(i, j) });
        p[i][j] = p[i + 1][j] = p[i][j + 1] = p[i + 1][j + 1] = 0;

        for (int w = 0; w < 8; w++)
        {
            int I = i + di[w], J = j + dj[w];
            if (I <= 0 || I >= n || J <= 0 || J >= m || visited[I][J]) continue;
            if (canPaint(I, J) != -1)
            {
                q.push({ I, J });
                visited[I][J] = 1;
            }
        }
    }

    if (v.size() != (n - 1) * (m - 1)) cout << "-1\n";
    else
    {
        cout << v.size() << "\n";
        for (int i = v.size() - 1; i >= 0; i--)
            cout << v[i].first.first << " " << v[i].first.second << " " << v[i].second << "\n";
    }
}
```
















