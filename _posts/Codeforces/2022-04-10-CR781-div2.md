---
title: "[CF# 10] Codeforces Round #781 (Div. 2, except F)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Codeforces
use_math: true
comments: true

---

`Tags` 

## Result & Review

최근 백준에서 새로운 알고리즘들을 공부하고 있어서 한 달 정도 대회에 참여하지 못했었는데, 그래서 그런지 너무 안풀렸다.

코드잼 1라운드를 통과하기 위해 당분간은 코드포스와 코드잼 기출들을 풀면서 문제 푸는 능력을 끌어올려야 할 것 같다.

<br/>

## A. GCD vs LCM

[A번 문제 링크](https://codeforces.com/contest/1665/problem/A)

**[PROBLEM]**

양의 정수 $n$이 주어질 때, 다음을 만족하는 네 양의 정수 $a, b, c, d$를 구하여라.

- $a + b + c + d = n$
- $\gcd(a, b) = \operatorname{lcm}(c, d)$

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 10^4$)가 주어진다.

각 테스트케이스는 하나의 정수 $n$($4 \leq n \leq 10^9$)으로 이루어진다.

**[OUTPUT]**

각 테스트케이스에 대해 조건을 만족하는 네 양의 정수 $a, b, c, d$를 출력한다.

---

### [SOLUTION] Math

$n$이 홀수이면 $a = n - 5, b = 2, c = 2, d = 1$은 조건을 만족한다.

단, $n = 5$이면 $a = 0$이므로 따로 예외 처리를 해준다.

$n$이 짝수이면 $a = n - 3, b = 1, c = 1, d = 1$이 조건을 만족한다.

```cpp
#include <iostream>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        if (n == 5) cout << "2 1 1 1\n";
        else if (n % 2) cout << n - 5 << " 2 2 1\n";
        else cout << n - 3 << " 1 1 1\n";
    }
}
```

<br/>

## B. Array Cloning Technique

[B번 문제 링크](https://codeforces.com/contest/1665/problem/B)

**[PROBLEM]**

$n$개의 정수로 이루어진 배열 $a$가 주어진다.

다음 두 가지 연산을 수행할 수 있다.

1. 배열 하나를 복제한다.
2. 두 배열에서 원소를 하나씩 선택한 후, 교환한다.

모든 원소가 동일한 배열을 만들기 위해 필요한 연산의 최소 횟수를 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 10^4$)가 주어진다.

각 테스트케이스의 첫 번째 줄에는 정수 $n$($1 \leq n \leq 10^5$)이 주어진다.

두 번째 줄에는 $n$개의 정수 $a_1, a_2, \dots, a_n$($-10^9 \leq a_i \leq 10^9$)가 주어진다.

**[OUTPUT]**

각 테스트케이스에 대해 모든 원소가 동일한 배열을 만들기 위해 필요한 연산의 최소 횟수를 출력한다.

---

### [SOLUTION] Greedy

주어진 배열 $a$에서 가장 많이 나타나는 수를 $x$, 그 횟수를 $m$이라고 하자.

모든 원소가 $x$인 배열을 만들기 위해서는 두 수를 교환하는 연산이 $n - m$번 필요하다.

배열을 복제해서 최소 $n$개의 $x$를 만들어내기 위해 복제를 $k$번 한다고 하면, $k$는 다음을 만족한다.

\begin{aligned}
m \cdot 2^k \geq n
\end{aligned}

따라서 $k = \lfloor \log \frac{n}{m} \rfloor$이고, 우리가 구하고자 하는 답은 $n - m + k$이다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        vector<int> a(n);
        for (int i = 0; i < n; i++) cin >> a[i];
        
        sort(a.begin(), a.end());
        int m = 0, cnt = 1;
        for (int i = 1; i < n; i++)
        {
            if (a[i - 1] == a[i]) cnt++;
            else m = max(m, cnt), cnt = 1;
        }
        m = max(m, cnt);
        
        int k = 0, M = m;
        while (M < n) M *= 2, k++;
        
        cout << n - m + k << "\n";
    }
}
```

<br/>

## C. Tree Infection

[C번 문제 링크](https://codeforces.com/contest/1665/problem/C)

**[PROBLEM]**

$n$개의 노드로 이루어진 트리가 주어진다.

각 노드들을 $1$부터 $n$까지의 번호가 매겨져 있고, 루트 노드는 항상 $1$이다.

초기에는 모든 노드가 감염되지 않은 상태인데, 매초마다 다음 두 가지 연산을 순서대로 수행한다.(Spreading -> Injection)

- **Spreading**: 각 노드 $v$에 대해, $v$의 자식 노드 중 감염된 노드가 있다면 $v$의 다른 자식 노드 하나를 감염시킨다.
- **Injection**: 감염되지 않은 노드 하나를 선택해서 감염시킨다.

모든 노드가 전부 감염될 때까지 최소 몇 초가 걸리는지 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 10^4$)가 주어진다.

각 테스트케이스의 첫 번째 줄에는 정수 $n$($2 \leq n \leq 2 \cdot 10^5$)이 주어진다.

두 번째 줄에는 $n-1$개의 정수 $p_1, p_2, \dots, p_n$($1 \leq p_i \leq n$)가 주어진다.

$p_i$는 $i$번째 노드의 부모 노드를 의미한다.

**[OUTPUT]**

각 테스트케이스에 대해 모든 노드가 감염되는 최소 시간을 출력한다.

---

### [SOLUTION] Greedy

같은 부모 노드를 가진 노드들끼리만 감염이 가능하기 때문에 각 노드가 몇 개의 자식 노드를 가지고 있는지만 알면 된다.

같은 부모 노드를 가진 노드들의 집합을 $S_1, S_2, \dots, S_m$이라고 하자.

각 집합에 적어도 하나의 감염된 노드가 있어야 매초마다 새로운 감염이 일어난다는 점을 고려하면, 반드시 각 집합에 적어도 한 번씩 Injection을 수행해야한다.

그러므로 먼저 크기가 큰 집합부터 차례대로 노드를 감염시켜준다.

이제 각 집합의 모든 원소들이 감염될 때까지 매초마다 추가로 하나의 노드를 감염시킬 수 있다.

최소 시간을 구해야하므로 현재 가장 감염되지 않은 노드가 많은 집합을 선택해주면 된다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        vector<int> c(n + 1); // c[i]: 노드 i의 자식 노드 수
        for (int i = 2; i <= n; i++)
        {
            int p; cin >> p;
            c[p]++;
        }
        c[0] = 1;
        
        // 1. 각 집합에서 하나씩 감염
        sort(c.begin(), c.end(), [](int i, int j){ return i > j; });
        while (!c[n]) n--;
        int t1 = n + 1;
        for (int i = 0; i <= n; i++) c[i] -= t1 - i; // 크기가 큰 집합부터 Injection 수행
        
        // 2. 남은 시간 동안 추가로 하나씩 감염
        sort(c.begin(), c.end(), [](int i, int j){ return i > j; });
        while (c[n] <= 0) n--;
        int idx = 0, t2 = 0;
        while (c[idx] > t2 || c[idx + 1] > t2) // 감염되지 않은 원소가 가장 많은 집합에 Injection 수행
        {
            if (c[idx] < c[idx + 1]) idx++;
            else idx = 0;
            c[idx]--;
            t2++;
        }
        
        cout << t1 + t2 << "\n";
    }
}
```

> 각 집합에서 최대 하나의 감염이 일어나다는 조건을 잘못보고 감염된 노드 하나 당 하나의 감염이 일어날 수 있다고 생각했다..ㅜㅜ

<br/>

## D. GCD Guess

[D번 문제 링크](https://codeforces.com/contest/1665/problem/D)

**[INTERACTIVE PROBLEM]**

최대 $30$개의 쿼리를 통해 양의 정수 $x$($1 \leq x \leq 10^9$)를 추측하는 문제이다.

- Query: "? a b"($1 \leq a, b \leq 2 \cdot 10^9$, $a \neq b$)
- Answer: $\gcd(x + a, x + b)$

$x$를 구했다면 "! x"를 출력한다.

---

### [SOLUTION 1] Modular Arithmetic

음이 아닌 정수 $k$에 대해 $r_k = x\,\bmod\,2^k$라고 하자.

$r_k$에 대해 쿼리 $(a_k, b_k)$를 $(2^k - r_k, 2^k - r_k + 2^{k + 1})$라고 하자.

$x + 2^k - r_k \equiv 0 \pmod{2^k}$임을 이용하면, 쿼리 $(a_k, b_k)$에 대한 답 $g_k$로부터 다음을 얻을 수 있다.

- $g_k = 2^{k + 1}$이면, $r_{k + 1} = r_k + 2^k$이다.
- $g_k < 2^{k + 1}$이면, $r_{k + 1} = r_k$이다.

$r_0 = 0$이므로, 쿼리 $(a_0, b_0)$부터 쿼리 $(a_{29}, b_{29})$까지를 통해 $r_{30}$을 얻을 수 있다.

$r_{30}$은 $x$를 $2^{30} (> 10^9)$으로 나눈 나머지인데, $x \leq 10^9$이므로 $r_{30}= x$이다.

```cpp
#include <iostream>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int t; cin >> t;
    while (t--)
    {
        int r = 0;
        for (int k = 0; k < 30; k++)
        {
            cout << "? " << (1 << k) - r << " " << (1 << k) - r + (1 << (k + 1)) << "\n" << flush;
            int gcd; cin >> gcd;
            if (gcd == (1 << (k + 1))) r += (1 << k);
        }
        cout << "! " << r << "\n";
    }
}
```

> 왜 하필 쿼리의 개수를 **30개**로 제한시켰는지에 대해 생각해보면 떠올릴 수 있었을 것 같다.

---

### [SOLUTION 2] Chinese Remainder Theorem (CRT)

> $4, 5, 7, 9, 11, 13, 17, 19, 23$

위 수들은 서로 서로소이고, 최소공배수 $L$이 $10^9$보다 크다.

그러므로 $x$를 $L$로 나눈 나머지가 $x$와 같음을 알 수 있다.

총 23개의 쿼리를 통해 $x$를 $L$로 나눈 나머지를 구할 수 있으며, $k$($1 \leq k \leq 23$)번째 쿼리는 $(k, L + k)$이다.

$k$번째 쿼리의 결과를 $g_k$, 위 9개의 수 중 하나를 $n$이라고 하자.

만약 $g_k$가 $n$으로 나누어떨어지면 $x \equiv -k \pmod{n}$이라고 할 수 있다.

$k$가 $1$부터 $23$까지 변하기 때문에 $g_1, g_2, \dots ,g_{23}$ 중 위 9개의 수들로 나누어 떨어지는 수가 적어도 하나씩은 존재한다.

따라서 23개의 쿼리를 통해 $x$를 9개의 수 각각으로 나눈 나머지를 구할 수 있다.

이제 **중국인의 나머지 정리(Chinese Remainder Theorem)**을 이용하여 $x$를 $L$로 나눈 나머지를 구할 수 있다.









