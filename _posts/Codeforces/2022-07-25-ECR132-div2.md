---
title: "[CF #20] Educational Codeforces Round #132 (div 2)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Coding Contest
use_math: true
comments: true

---

`Tags` 

## Result & Review

아무리 에듀코포라고 해도 유독 초반 문제들이 쉬운 느낌이었다.

특히 D번은 너무 대놓고 세그먼트 트리를 이용하면 풀리는 것이 보이는 문제였다.

대신 C번이 조금 까다로운 편이었다.

D번까지 한 시간 정도만에 풀었는데, 뒤에 있는 두 문제는 어떻게 풀어야할지 감이 잘 잡히지 않았다.

<br/>

## A. Tree Doors

[A번 문제 링크](https://codeforces.com/contest/1709/problem/A)

번호가 각각 1, 2, 3 인 세 개의 문과 열쇠가 있고, 각 문을 열기 위해서는 동일한 번호를 가진 열쇠가 필요하다.

열쇠 중 두 개는 서로 다른 문 뒤에 숨겨져 있다.

이때 남은 하나의 열쇠를 이용해서 모든 문을 열 수 있는지 구하여라.

---

### [SOLUTION] Implementation

처음 열쇠로 연 문 뒤에 열쇠가 있고, 그 열쇠로 연 문 뒤에 열쇠가 있으면 모든 문을 열 수 있다.

```cpp
#include <iostream>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--) {
        int x; cin >> x;
        vector<int> n(4);
        for (int i = 1; i < 4; i++) cin >> n[i];
        cout << ((n[x] != 0 && n[n[x]] != 0) ? "YES" : "NO") << "\n";
    }
}
```

<br/>

## B. Also Try Minecraft

[B번 문제 링크](https://codeforces.com/contest/1709/problem/B)

테라리아라는 게임의 월드맵은 길이가 $n$인 배열로 나타낼 수 있다.

월드의 $i$번째 열의 높이는 $a_i$이며, 현재 위치한 열에서 인접한 열로만 이동할 수 있다.

그런데 현재 위치한 열의 높이가 이동하려는 열의 높이보다 클 경우, 그 차이만큼 낙하 데미지를 받게 된다.

$s$번째 열에서 $t$번째 열로 이동하는 퀘스트가 $m$개 주어질 때, 각각의 퀘스트를 수행하는데 받는 낙하데미지를 구하여라.

---

### [SOLUTION] Implementation

낙하데미지는 항상 양수이므로, 부분합을 구해두면 각 쿼리를 상수 시간에 처리할 수 있다.

이때 출발 지점이 도착 지점보다 오른쪽에 있을 수 있으므로 오른쪽에서 왼쪽으로 이동할 때의 낙하데미지의 부분합도 구해주어야 한다.

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;

ll a[100001], b[100001], c[100001];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int n, m; cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 2; i <= n; i++)
        b[i] = b[i - 1] + (a[i - 1] > a[i] ? a[i - 1] - a[i] : 0);
    for (int i = n - 1; i >= 1; i--)
        c[i] = c[i + 1] + (a[i] < a[i + 1] ? a[i + 1] - a[i] : 0);
    while (m--) {
        int s, t; cin >> s >> t;
        if (s < t) cout << b[t] - b[s] << "\n";
        else cout << c[t] - c[s] << "\n";
    }
}
```

<br/>

## C. Recover an RBS

[C번 문제 링크](https://codeforces.com/contest/1709/problem/C)

Bracket sequence는 '('와 ')'로만 이루어진 문자열을 말한다.

Regular bracket sequence(RBS)는 괄호들이 올바르게 짝지어지는 bracket sequence이다.

RBS의 몇몇 괄호들이 물음표로 바뀌었다고 한다.

이때 물음표들을 괄호로 바꾸어서 문자열을 RBS로 만드는 방법이 유일한지 구하여라.

---

### [MY SOLUTION] Implementation

처음 생각은 문자열을 순회하면서 '('와 ')'의 개수를 세다가 물음표를 만난다면 각 괄호의 개수를 비교하는 것이었다.

만약 두 괄호의 개수가 같다면 반드시 '('가 와야하기 때문에 방법이 유일해지지만, '('의 개수가 더 많다면 두 괄호 모두 올 수 있으므로 방법이 유일하지 않다고 생각했다.

위 생각의 첫 번째 허점은 남은 물음표의 개수가 전체 문자열에서 두 괄호의 개수의 차이와 같으면 방법이 유일하다는 것이었다.

하지만 이를 고려한 코드를 짜도 WA를 받았는데, 여러 예시들을 입력해보다가 또다른 허점을 발견할 수 있었다.

두 번째 허점은 문자열의 특정 구간에서 물음표를 모두 '('로 바꾸어야할 수도 있다는 것이었다.

만약 어떤 구간에서 '('의 개수와 물음표의 개수의 합이 ')'의 개수보다 $1$만큼 더 크다면 반드시 해당 구간의 물음표들은 모두 '('로 고정된다.

그래서 문자열을 탐색하면서 위와 같은 구간이 있다면 처리해준 후, 기존 풀이를 적용하였더니 AC를 받았다.

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--) {
        string s; cin >> s;
        vector<int> idx, x(s.size(), 0);
        int l = 0, r = 0, q = 0;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') l++, x[i] = 1;
            else if (s[i] == ')') r++, x[i] = 2;
            else {
                q++;
                idx.push_back(i);
            }

            if (q > 0 && l + q == r + 1) {
                for (int j : idx) x[j] = 1;
                l += q;
                q = 0;
                idx.clear();
            }
        }
        if (q > 0 && l + q == r + 1) {
            for (int j : idx) x[j] = 1;
            l += q;
            q = 0;
        }

        bool flg = 1;
        int L = 0, R = 0;
        for (int i = 0; i < s.size(); i++) {
            if (q == abs(L - R)) break;
            if (x[i] == 1) L++;
            else if (x[i] == 2) Q++;
            else if (L > R) {
                flg = 0;
                break;
            }
            else L++, l++, q--;
        }
        cout << (flg ? "YES" : "NO") << "\n";
    }
}
```

---

### [BETTER SOLUTION] 

각 괄호의 개수와 물음표의 개수를 이용하면 물음표 중 각 괄호가 몇 개인지 구할 수 있다.

RBS가 반드시 존재한다고 했으므로 앞쪽 물음표들을 '('로, 나머지 물음표들을 ')'로 바꾸면 RBS 하나를 얻을 수 있다.

그렇다면 이 외에 다른 RBS가 존재하면 "NO", 존재하지 않는다면 "YES"를 출력하면 된다.

가장 쉽게 얻을 수 있는 RBS 후보는 물음표에서 바뀐 괄호들 중 마지막 '('와 첫 번째 ')"의 위치를 바꾸는 것이다.

결국 RBS이기 위해서는 항상 '('의 개수가 ')'의 개수보다 크거나 같아야하는데, 이에 최대한 적게 영향을 주는 방법이기 때문이다.

어떤 식으로 괄호의 순서를 바꾸어도 위 방법보다 적게 영향을 주는 방법은 없다.

따라서 앞서 말한 두 괄호를 교환한 문자열이 RBS이면 "NO", 아니라면 "YES"를 출력하면 된다.

```cpp
#include <iostream>
#include <vector>
using namespace std;

bool check(string& s) {
    int dif = 0;
    for (char c : s) {
        if (c == '(') dif++;
        else if (c == ')') dif--;
        if (dif < 0) return 0;
    }
    return dif == 0;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int t; cin >> t;
    while (t--) {
        string s; cin >> s;
        vector<int> pos;
        int l = s.size() / 2, r = s.size() / 2;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '?') pos.push_back(i);
            else if (s[i] == '(') l--;
            else r--;
        }
        for (int i : pos) {
            if (i < l) s[i] = '(';
            else s[i] = ')';
        }
        
        bool flg = 1;
        if (l && r) {
            swap(s[pos[l - 1]], s[pos[l]]);
            if (check(s)) flg = 0;
        }
        cout << (flg ? "YES" : "NO") << "\n";
    }
}
```

<br/>







