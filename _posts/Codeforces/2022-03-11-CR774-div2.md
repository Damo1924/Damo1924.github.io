---
title: "[CF#7] Codeforces Round #774 (Div. 2, except F)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Codeforces
use_math: true
comments: true

---

`Tags` 

## Result & Review

정말 역대급으로 많이 틀린 대회였다.

B번에서 3번, C번에서 2번, D번에서 2번 WA를 받았고, D번은 결국 풀지 못했다.

패널티를 하도 많이 받아서 엄청 등수가 떨어질 줄 알았는데, 생각보다 선방했다.

앞 문제들이 평소보다 까다롭긴 한 것 같다.

<img src="https://user-images.githubusercontent.com/88201512/157785745-caeb084f-d62f-4360-9ca8-b75b3cade6e5.jpg">

레이팅은 6점이 떨어져서 1593이다 ㅜㅜ

<br/>

## A. Squarer Counting

[A번 문제 링크](https://codeforces.com/contest/1646/problem/A)

**[PROBLEM]**

길이가 $n+1$인 수열 $a_1, a_2, \dots, a_{n+1}$에 대해 전체 수열의 합을 $s$라고 하자.

모든 $i$($1 \leq i \leq n + 1$)에 대해 $0 \leq a_i < n$ 또는 $a_i = n^2$이 성립한다.

$n$과 $s$의 값이 주어질 때, 수열에 $n^2$이 몇 개나 있는지 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 2 \cdot 10^4$)가 주어진다.

각 테스트케이스에 대해 두 정수 $n, s$($1 \leq n < 10^6$, $0 \leq s \leq 10^{18}$)가 주어진다.

**[OUTPUT]**

각 테스트케이스에 대해 수열에 있는 $n^2$의 개수를 출력한다.

---

### [SOLUTION] Math

$n^2$이 아닌 원소 $n + 1$개의 합의 최댓값은 $(n + 1)(n - 1) = n^2 - 1$이다.

이 값은 $n^2$보다 항상 작기 때문에 수열에 있는 $n^2$의 개수는 $\lfloor \frac{s}{n^2} \rfloor$이다.

```cpp
#include <iostream>
using namespace std;
typedef long long ll;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        ll n, s; cin >> n >> s;
        cout << s / (n * n) << "\n";
    }
}
```

<br/>

## B. Quality vs Quantity

[B번 문제 링크](https://codeforces.com/contest/1646/problem/B)

**[PROBLEM]**

음이 아닌 정수로 이루어진 길이가 $n$인 수열 $a_1, a_2, \dots, a_n$이 주어진다.

처음에는 모든 원소가 'unpainted' 상태이고, 각 원소를 'Red' 또는 'Blue'로 칠하거나 그대로 내버려둘 수 있다.

색깔 $c$에 대해 $Count(c)$는 $c$로 칠해진 원소의 개수, $Sum(c)$는 $c$로 칠해진 원소의 합을 의미한다.

주어진 수열 $a$에 대해 다음을 만족하도록 원소들을 칠할 수 있는지 판단하여라.

\begin{aligned}
Sum(Red) > Sum(Blue), Count(Red) < Count(Blue)
\end{aligned}

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 2 \cdot 1000$)가 주어진다.

각 테스트케이스는 다음과 같이 이루어진다.

첫 번째 줄에는 정수 $n$($3 \leq n \leq 2 \cdot 10^5$)가 주어진다.

두 번째 줄에는 $n$개의 정수 $a_1, \dots, a_n$($0 \leq a_i \leq 10^9$)가 주어진다.

**[OUTPUT]**

각 테스트케이스에 대해 조건을 만족하도록 원소들을 칠할 수 있으면 "YES"를, 없으면 "NO"를 출력한다.

---

### [SOLUTION] Constructive algorithm

$Count(Red) < Count(Blue)$을 만족하면서 $Sum(Red) > Sum(Blue)$이도록 칠하는 방법을 탐색해보자.

$Count(Blue)$를 $k$라고 하면, $Sum(Red)$를 최대한 크게 만들기 위해 $Count(Red) = k - 1$라고 해도 괜찮다.

따라서 전체 수열을 정렬한 후에 작은 것부터 $k$개를 더한 결과와 큰 것부터 $k-1$개를 더한 결과를 비교해서 후자가 더 큰 경우가 존재하는지 탐색해보면 된다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
typedef long long ll;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        vector<int> a(n);
        for (int i = 0; i < n; i++) cin >> a[i];
        sort(a.begin(), a.end());
        
        bool flg = 1;
        ll s1 = a[0], s2 = 0;
        for (int i = 1; i < n; i++)
        {
            s1 += a[i];
            s2 += a[n - i];
            if (s1 < s2) flg = 0;
        }
        if (flg) cout << "NO\n";
        else cout << "YES\n";
    }
}
```

<br/>

## C. Factorials ans Powers of Two

[C번 문제 링크](https://codeforces.com/contest/1646/problem/C)

**[PROBLEM]**

2의 거듭제곱이나 팩토리얼로 표현되는 수를 'powerful'이라고 한다.

양의 정수 $n$이 주어질 때, $n$을 $k$개의 서로 다른 'powerful' 수들의 합으로 표현이 가능한지 판단하고, 만약 표현이 가능하다면 $k$의 최솟값을 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $t$($1 \leq t \leq 100$)가 주어진다.

각 테스트케이스는 하나의 정수 $n$($1 \leq n \leq 10^{12}$)으로 이루어져 있다.

**[OUTPUT]**

각 테스트케이스에 대해 $n$을 서로 다른 'powerful' 수로 나타낼 수 없으면 -1을 출력하고, 나타낼 수 있다면 $k$의 최솟값을 출력한다.

---

### [SOLUTION] Brute force

2의 거듭제곱을 이용하면 모든 수를 표현할 수 있으므로 일단 'powerful' 수들의 합으로 표현이 불가능한 $n$은 없다.

$1! = 2^0$, $2! = 2^1$이므로 제외하고 $15! > 10^12$이므로 $3!$부터 $14!$을 사용하는 경우만 추가로 고려해주면 된다.

전체 경우의 수는 $2^12$이므로 DFS로 모든 경우를 탐색해도 충분히 시간 내에 해결할 수 있다.

```cpp
#include <iostream>
using namespace std;
typedef long long ll;

ll fac[15]; // fac[i] = i!

int ans;

int cnt(ll n) // n을 이진법으로 나타냈을 때 1의 개수를 반환
{
    int c = 0;
    while (n)
    {
        if (n & 1) c++;
        n >>= 1;
    }
    return c;
}

void dfs(ll n, int f, int c)
{
    ans = min(ans, cnt(n) + c);
    for (int i = f; i > 2; i--)
    {
        if (n < fac[i]) continue;
        dfs(n - fac[i], i - 1, c + 1);
    }
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    fac[0] = 1;
    for (int i = 1; i < 15; i++) fac[i] = fac[i - 1] * i;

    int t; cin >> t;
    while (t--)
    {
        ll n; cin >> n;

        ans = cnt(n);
        dfs(n, 14, 0);
        cout << ans << "\n";
    }
}
```

<br/>

## D. Weight the Tree

[D번 문제 링크](https://codeforces.com/contest/1646/problem/D)

**[PROBLEM]**

$1$부터 $n$까지 번호가 붙여진 $n$개의 정짐으로 이루어진 트리가 주어진다.

각 $i = 1, 2, \dots, n$에 대해 $w_i$를 $i$번째 정점의 무게라 하자.

이때 어떤 정점의 무게가 해당 정점과 인접한 정점들의 무게를 모두 더한 것과 같으면 'good'라고 부른다.

초기에는 모든 정점의 무게가 정해져 있지 않다.

트리에 있는 'good' 정점의 개수가 최대가 되도록 적절한 양의 정수를 각 정점의 무게로 할당하여라.

만약 여러 가지 방법이 존재한다면, 그 중 모든 정점의 무게의 합이 최소가 되는 것을 찾아라.

**[INPUT]**

첫 번째 줄에는 정수 $n$($2 \leq n \leq 2 \cdot 10^5$)가 주어진다.

다음 $n-1$줄에 걸쳐 간선의 정보가 주어진다.

각 줄에는 두 정수 $u, v$($1 \leq u, v \leq n$)가 주어진다.

**[OUTPUT]**

첫 번째 줄에 'good' 정점의 최대 개수와 전체 정점의 무게의 합을 출력한다.

두 번째 줄에 각 정점의 무게 $w_1, w_2, \dots, w_n$($1 \leq w_i \leq 10^9$)을 출력한다.

---

### [SOLUTION] 












