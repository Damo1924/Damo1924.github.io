---
title: "[CF #22] Codeforces Round #813 (div 2)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Coding Contest
use_math: true
comments: true

---

`Tags` 

## Result & Review

첫 세 문제를 20분 정도에 풀었는데, 나머지 시간을 모두 써도 D번과 E번을 풀지 못했다.

그나마 세 문제를 빠르게 풀어서 레이팅 방어에는 성공했지만, D번을 풀지 못해 아쉽다.

그리디한 방법으로 해결해보려고 했는데, 6번이나 틀린 것을 보아 방법 자체가 잘못된 듯 하다.

<br/>

## A. Wonderful Permutation

[A번 문제 링크](https://codeforces.com/contest/1712/problem/A)

길이가 $n$($1 \leq n \leq 100$)인 순열 $p_1, p_2, \dots, p_n$이 주어지며, 순열에 아래 연산을 수행할 수 있다.

- 두 정수 $i, j$($1 \leq i < j \leq n$)을 선택하여 $p_i$와 $p_j$를 교환한다.

어떤 정수 $k$($1 \leq k \leq n$)에 대하여 $p_1 + p_2 + \dots + p_k$ 가 최소가 되도록 만드는데 필요한 최소 연산 횟수를 구하여라.

---

### [SOLUTION] Greedy

$p_1 + p_2 + \dots + p_k$의 최솟값은 $1 + 2 + \dots + k$이므로, 우리의 목표는 $p_1, \dots, p_k$에 $1, \dots, k$가 모두 존재하도록 만드는 것이다.

즉, $p_1, \dots, p_k$ 중에서 $k$보다 큰 값을 가지는 것의 개수가 답이 된다.

```cpp
#include <iostream>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--) {
        int n, k, a, ans = 0; cin >> n >> k;
        for (int i = 0; i < n; i++) {
            cin >> a;
            if (i < k && a > k) ans++;
        }
        cout << ans << "\n";
    }
}
```

<br/>

## B. Woeful Permutation

[B번 문제 링크](https://codeforces.com/contest/1712/problem/B)

아래 조건을 만족하는 길이가 $n$($1 \leq n \leq 10^5$)인 순열 $p_1, p_2, \dots, p_n$을 구하여라.

- $lcm(1, p_1) + lcm(2, p_2) + \dots + lcm(n, p_n)$ 이 최대

이때 $lcm(x, y)$는 $x, y$의 최대공배수이며, 조건을 만족하는 순열이 여러 개라면 아무거나 출력한다.

---

### [SOLUTION] Greedy

어떤 자연수 $x$에 대하여 $\gcd(x, x+1) = 1$ 이므로 $lcm(x, x+1) = x \cdot (x + 1)$ 이다.

따라서 $p_n = n - 1$, $p_{n-1} = n$ 과 같이 이웃한 두 수를 짝지어서 순열을 결정해주면 주어진 식의 최댓값을 얻을 수 있음을 알 수 있다.

```cpp
#include <iostream>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--) {
        int n; cin >> n;
        if (n % 2) {
            cout << "1 ";
            for (int i = 2; i < n; i += 2) cout << i + 1 << " " << i << " ";
        }
        else {
            for (int i = 1; i < n; i += 2) cout << i + 1 << " " << i << " ";
        }
        cout << "\n";
    }
}
```

<br/>

## C. Sort Zero

[C번 문제 링크](https://codeforces.com/contest/1712/problem/C)

양의 정수로 이루어진 길이가 $n$($1 \leq n \leq 10^5$)인 수열 $a_1, a_2, \dots, a_n$($1 \leq a_i \leq n$) 이 주어지고, 아래와 같은 연산을 수행할 수 있다.

- 임의의 정수 $x$를 선택하여 $a_i = x$ 를 만족하는 모든 $i$에 대해 $a_i = 0$ 으로 바꾼다.

이때 전체 수열을 단조 증가하게 만들기 위한 최소 연산 횟수를 구하여라.

---

### [SOLUTION] Greedy

만약 $a_i = 0$ 으로 바꾸었다면, 모든 $j < i$ 에 대하여 $a_j = 0$ 이어야한다.

$a_{k+1}, \dots, a_n$ 이 단조 증가하는 가장 작은 $k$를 찾은 후, $a_1, \dots, a_k$ 을 $0$으로 만들면 전체 수열이 단조 증가하게 된다.

하지만 $a_1, \dots, a_k$에 있는 정수를 $0$으로 만들면서 $a_{k+1}, \dots, a_n$에 있는 원소도 같이 $0$이 될 수 있음을 고려해야한다.

즉 $a_i$($1 \leq i \leq k$)를 $0$으로 만들되, $k$값을 아래와 같이 갱신해가며 바꾸면 된다.

- $a_j = a_i$ 를 만족하는 가장 큰 정수 $j$ 에 대하여 $k$를 $\max(k, j)$ 로 갱신한다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int a[100000], last[100001];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--) {
        int n; cin >> n;
        for (int i = 1; i <= n; i++) last[i] = -1;
        for (int i = 0; i < n; i++) {
            cin >> a[i];
            last[a[i]] = i;
        }
        
        int k = n - 2;
        while (k >= 0 && a[k] <= a[k + 1]) k--;
        
        int ans = 0;
        for (int i = 0; i <= k; i++) if (last[a[i]] != -1) {
            ans++;
            k = max(k, last[a[i]]); // k 갱신
            last[a[i]] = -1;
        }
        cout << ans << "\n";
    }
}
```

<br/>

## D. Empty Graph

[D번 문제 링크](https://codeforces.com/contest/1712/problem/D)

양의 정수로 이루어진 길이가 $n$($2 \leq n \leq 10^5$)인 수열 $a_1, a_2, \dots, a_n$과 어떤 정수 $k$($1 \leq k \leq n$)이 주어진다.

주어진 수열에 아래 연산을 최대 $k$번 수행할 수 있다..

- 인덱스 $i$($1 \leq i \leq n$)와 정수 $x$($1 \leq x \leq 10^9$)을 선택하여 $a_i$를 $x$로 바꾼다.

이제 완성된 수열로 $1$부터 $n$까지의 번호가 매겨진 $n$개의 정점을 가지는 complete undirected weighted graph를 만든다.

이때 정점 $l, r$을 연결하는 간선 $(l, r)$의 무게는 $\min(a_l, a_{l+1}, \dots, a_r)$ 이다.

어떤 두 정점 $u, v$에 대하여 $d(u, v)$를 두 정점 사이의 최단 경로라고 정의할 때, 위 그래프에서 $d(u, v)$의 최댓값을 구하여라.

---

### [SOLUTION] Greedy

접근 방법 자체는 튜토리얼과 완전 동일했는데, 극단적으로 최적해를 찾으려다보니 예외 케이스가 발생한 것 같다.

먼저, 수열의 최솟값을 $m = \min(a_1, a_2, \dots, a_n)$ 이라 하자.

임의의 두 정수 $l, r$($l < r$)에 대하여 $d(l, r) = \min(2m, \min(a_l, \dots, a_r))$ 이다.

수열의 최솟값에 해당하는 인덱스를 $i$라고 하면 $m = a_i$ 인데, $d(l, i) = d(r, i) = m$ 이다.

그래프의 그 어떤 간선도 가중치가 $m$보다 작을 수 없으므로, 정점 하나 이상을 거치는 $l, r$ 사이의 경로들 중 최단 경로의 길이는 $2m$이다.

즉, $d(u, v)$의 최댓값은 다음과 같이 구할 수 있다.

\begin{aligned}
\max_{1 \leq u < v \leq n} d(u, v) = \min \left(2m, \max_{1 \leq u < v \leq n} (\min(a_u, \dots, a_v)) \right)
\end{aligned}

그런데

\begin{aligned}
\max_{1 \leq u < v \leq n} (\min(a_u, \dots, a_v)) = \max_{1 \leq i < n} \left( \min(a_i, a_{i+1}) \right)
\end{aligned}

가 성립하므로, 구하고자 하는 값은 최종적으로 아래와 같다.

\begin{aligned}
\min \left(2m, \max_{1 \leq i < n} ( \min(a_i, a_{i+1}) ) \right)
\end{aligned}

이제 $k$개의 연산을 수행할 인덱스를 정해야한다.

먼저, 가장 작은 $k-1$개의 원소들을 모두 $10^9$으로 만들어준다.

이제 마지막 연산을 남은 $a_i$들에 수행해보면서 답을 구하면 된다.

수열을 정렬해두면 각 $i$에 대하여 최솟값 $m$을 $O(1)$에 구할 수 있고,

$\max_{1 \leq i < n} \left( \min(a_i, a_{i+1}) \right)$ 는 세그먼트 트리를 이용해서 $O(\log n)$에 구할 수 있다.

따라서 전체 시간복잡도는 $O(n \log n)$이다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
typedef long long ll;
const int inf = 1e9;

int a[100000];
pair<int, int> b[100000];

struct Segtree {
    int n;
    vector<int> node;
    Segtree() {}
    Segtree(int _n) : n(_n) { node.resize(2 * n); }
    void build() {
        for (int i = 0; i < n; i++) node[n + i] = min(a[i], a[i + 1]);
        for (int i = n - 1; i; i--) node[i] = max(node[2 * i], node[2 * i + 1]);
    }
    void upd(int i, int val) {
        a[i] = val;
        if (i > 0) {
            node[n + i - 1] = min(a[i - 1], a[i]);
            for (int j = (n + i - 1) / 2; j > 0; j /= 2)
                node[j] = max(node[2 * j], node[2 * j + 1]);
        }
        if (i < n) {
            node[n + i] = min(a[i], a[i + 1]);
            for (int j = (n + i) / 2; j > 0; j /= 2)
                node[j] = max(node[2 * j], node[2 * j + 1]);
        }
    }
};

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int t; cin >> t;
    while (t--) {
        int n, k; cin >> n >> k;
        for (int i = 0; i < n; i++) {
            cin >> a[i];
            b[i] = { a[i], i };
        }
        
        if (k == n) cout << "1000000000\n";
        else {
            sort(b, b + n);
            for (int i = 0; i + 1 < k; i++) a[b[i].second] = inf; // 가장 작은 k-1개 원소에 연산 수행
            
            Segtree tree(n - 1); // min(a[i], a[i + 1]) 들의 최댓값을 저장하는 세그먼트 트리 구현
            tree.build();
            int ans = 0;
            for (int i = 0; i < n; i++) if (a[i] != inf) { // 연산을 수행하지 않은 a[i]에 대하여 연산 수행하면서 답 구하기
                int tmp = a[i];
                tree.upd(i, inf);
                
                int mn = (i == b[k - 1].second ? a[b[k].second] : a[b[k - 1].second]);
                ans = max(ans, min(2 * mn, tree.node[1]));
                
                tree.upd(i, tmp);
            }
            cout << ans << "\n";
        }
    }
}
```

<br/>

## E. LCM Sum

- [E1번 문제 링크](https://codeforces.com/contest/1712/problem/E1)
- [E2번 문제 링크](https://codeforces.com/contest/1712/problem/E2)

두 양의 정수 $l, r$($1 \leq l < r \leq 2 \cdot 10^5$, $l + 2 \leq r$)이 주어질 때, $lcm(i, j, k) \geq i + j + k$ 를 만족하는 서로 다른 세 정수 $(i, j, k)$($l \leq i < j < k \leq r$)의 개수를 구하여라.

이때 $lcm(i, j, k)$는 세 정수 $i, j, k$의 최소공배수를 의미한다.

테스트케이스의 개수를 $t$라고 할 때,

- E1번: $1 \leq t \leq 5$
- E2번: $1 \leq t \leq 10^5$

이다.

---

### [E1 SOLUTION] 







