---
title: "[CF #18] Codeforces Round #793 (div 2)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Coding Contest
use_math: true
comments: true

---

`Tags` Constructive algorithm

## Result & Review

모든 문제가 구성적 알고리즘으로 이루어진 라운드였는데, 나름 재미있었다.

C번까지는 나름 빠르게 풀었는데, D번에서 막혀서 높은 등수를 달성하지는 못했다.

<br/>

## A. Palindromic Indices

[A번 문제 링크](https://codeforces.com/contest/1682/problem/A)

길이가 $n$($2 \leq n \leq 10^5$)인 펠린드롬 문자열 $s$가 주어진다.

$i$($1 \leq i \leq n$)번째 문자를 제거해도 펠린드롬이 되는 $i$의 개수를 구하여라.

---

### [SOLUTION] Greedy

인접한 동일한 문자들끼리 묶었을 때, 가운데에 있는 문자의 개수가 구하고자 하는 값이다.

```cpp
#include <iostream>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        string s; cin >> s;

        int i = n / 2, cnt = 0;
        while (i + 1 < n && s[i] == s[i + 1]) i++, cnt++;
        cnt *= 2;
        cnt += (n % 2 ? 1 : 2);
        cout << cnt << "\n";
    }
}
```

<br/>

## B. AND Sorting

[B번 문제 링크](https://codeforces.com/contest/1682/problem/B)

$0$부터 $n-1$까지의 정수들의 순열 $p$가 주어지는데, $p$는 오름차순으로 정렬되어 있지 않다.

어떤 음이 아닌 정수 $X$에 대하여 아래 연산을 통해 정렬이 가능한 순열을 $X$-sortable 라고 부른다.

- $p_i & p_j = X$ 을 만족하는 두 정수 $i, j$($1 \leq i < j \leq n$) 에 대하여 $p_i$와 $p_j$를 교환한다.

이때 $&$는 bitwise AND 연산자를 의미한다.

주어진 $p$가 $X$-sortable인 $X$의 최댓값을 구하여라.

---

### [SOLUTION] Constructive algorithm

순열 $p$가 $X$-sortable이기 위해서는 $p_i \neq i$ 인 모든 $i$에 대하여 $i & X = X$ 가 성립해야한다.

위 조건을 만족하는 $i_1, i_2, \dots, i_k$에 대하여 $(i_1 & i_2 & \dots & i_k) & X = X$ 가 성립해야하고, 이를 만족하는 $X$의 최댓값은 $i_1 & i_2 & \dots & i_k$ 이다.

```cpp
#include <iostream>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        int n, x = (1 << 20) - 1; cin >> n;
        for (int i = 0; i < n; i++)
        {
            int p; cin >> p;
            if (i != p) x &= i;
        }
        cout << x << "\n";
    }
}
```

<br/>



