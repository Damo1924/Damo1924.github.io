---
title: "[CF #18] Codeforces Round #793 (div 2)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Coding Contest
use_math: true
comments: true

---

`Tags` Constructive algorithm

## Result & Review

모든 문제가 구성적 알고리즘으로 이루어진 라운드였는데, 나름 재미있었다.

C번까지는 나름 빠르게 풀었는데, D번에서 막혀서 높은 등수를 달성하지는 못했다.

<br/>

## A. Palindromic Indices

[A번 문제 링크](https://codeforces.com/contest/1682/problem/A)

길이가 $n$($2 \leq n \leq 10^5$)인 펠린드롬 문자열 $s$가 주어진다.

$i$($1 \leq i \leq n$)번째 문자를 제거해도 펠린드롬이 되는 $i$의 개수를 구하여라.

---

### [SOLUTION] Greedy

인접한 동일한 문자들끼리 묶었을 때, 가운데에 있는 문자의 개수가 구하고자 하는 값이다.

```cpp
#include <iostream>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        string s; cin >> s;

        int i = n / 2, cnt = 0;
        while (i + 1 < n && s[i] == s[i + 1]) i++, cnt++;
        cnt *= 2;
        cnt += (n % 2 ? 1 : 2);
        cout << cnt << "\n";
    }
}
```

<br/>

## B. AND Sorting

[B번 문제 링크](https://codeforces.com/contest/1682/problem/B)

$0$부터 $n-1$까지의 정수들의 순열 $p$가 주어지는데, $p$는 오름차순으로 정렬되어 있지 않다.

어떤 음이 아닌 정수 $X$에 대하여 아래 연산을 통해 정렬이 가능한 순열을 $X$-sortable 라고 부른다.

- $p_i \And p_j = X$ 을 만족하는 두 정수 $i, j$($1 \leq i < j \leq n$) 에 대하여 $p_i$와 $p_j$를 교환한다.

이때 $\And$는 bitwise AND 연산자를 의미한다.

주어진 $p$가 $X$-sortable인 $X$의 최댓값을 구하여라.

---

### [SOLUTION] Constructive algorithm

순열 $p$가 $X$-sortable이기 위해서는 $p_i \neq i$ 인 모든 $i$에 대하여 $i \And X = X$ 가 성립해야한다.

위 조건을 만족하는 $i_1, i_2, \dots, i_k$에 대하여 $(i_1 \And i_2 \And \dots \And i_k) \And X = X$ 가 성립해야하고, 이를 만족하는 $X$의 최댓값은 $i_1 \And i_2 \And \dots \And i_k$ 이다.

```cpp
#include <iostream>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        int n, x = (1 << 20) - 1; cin >> n;
        for (int i = 0; i < n; i++)
        {
            int p; cin >> p;
            if (i != p) x &= i;
        }
        cout << x << "\n";
    }
}
```

<br/>

## C. LIS or Reverse LIS

[C번 문제 링크](https://codeforces.com/contest/1682/problem/C)

길이가 $n$($1 \leq n \leq 2 \cdot 10^5$)인 수열 $a$가 주어진다.

수열 $a$의 LIS(longest increasing subsequence)의 길이를 $LIS(a)$ 라고 하자.

수열 $a'$은 $a$를 뒤집은 수열일 때, 수열 $a$의 아름다움을 $min(LIS(a), LIS(a'))$ 이라고 정의한다.

주어진 수열을 재배열해서 얻을 수 있는 수열의 아름다움의 최댓값을 구하여라.

---

### [SOLUTION] Constructive algorithm

어떤 수열 $a$의 LIS와 $a'$의 LIS가 공통으로 가질 수 있는 원소는 최대 하나뿐이다.

그러므로 아름다움을 최대로 하기 위해서는 여러 번 나타나는 수를 각 LIS에 넣어주고, 한 번씩만 등장하는 수들을 적절히 각 LIS에 넣어주어야한다.

따라서 수열에 있는 서로 다른 수의 개수를 $m$, 한 번씩만 나타나는 수의 개수를 $k$라고 하면, 답은 $(m - k) + \left\lfloor \frac{k + 1}{2} \right\rfloor$ 이다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
typedef pair<int, int> ii;

int a[200000];

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        for (int i = 0; i < n; i++) cin >> a[i];
        sort(a, a + n);
        
        vector<ii> v = { { a[0], 0 } };
        for (int i = 1; i < n; i++)
        {
            if (v.back().first == a[i]) v.back().second = 1;
            else v.push_back({ a[i], 0 });
        }

        int m = v.size(), k = 0;
        for (int i = 0; i < m; i++) if (!v[i].second) k++;
        cout << m - k + (k + 1) / 2 << "\n";
    }
}
```

<br/>

## D. Circular Spanning Tree

[D번 문제 링크](https://codeforces.com/contest/1682/problem/D)

$1$부터 $n$까지의 번호를 가진 $n$($2 \leq n \leq 2 \cdot 10^5$)개의 노드가 원을 따라 시계방향으로 배치되어 있다.

'0' 또는 '1'로 이루어진 길이가 $n$인 문자열 $s$가 주어질 때, 아래 조건을 만족하는 트리를 구하여라.

- 각 노드 $i$($1 \leq i \leq n$)에 대하여 $s_i = 0$이면 노드의 차수가 짝수이고 $s_i = 1$이면 노드의 차수가 홀수이다.
- 각 간선을 선분으로 표현했을 때, 트리의 어떤 두 간선도 원 내부에서 교차하지 않는다. (원 위에서는 만날 수 있다.) 

---

### [SOLUTION] Constructive algorithm














