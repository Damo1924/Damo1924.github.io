---
title: "[CF #16] Codeforces Round #788 (Div. 2)"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Coding Contest
use_math: true
comments: true

---

`Tags` 

## Result & Review

충격의 그레이 퍼포를 받고 블루로 다시 복귀한지 얼마 안됬는데 다시 민트로 떨어졌다.

시간이 조금 지난 지금에야 다시 멘탈을 잡고 공부하고 있지만, 진짜 대회가 끝나고 때려치고 싶었다 ㅠ

공부할 문제가 많다는 마음가짐으로 해야겠다.

<br/>

## A. Tokitsukaze and All Zero Sequence

[A번 문제 링크](https://codeforces.com/contest/1678/problem/A)

길이가 $n$인 수열 $a$에 대하여 다음 연산을 수행할 수 있다.

- 두 정수 $i, j$($1 \leq i, j \leq n$, $i \neq j$)를 선택한 후,
- $a_i = a_j$ 이면 둘 중 하나를 $0$으로 만들고,
- $a_i \neq a_j$ 이면 둘 다 $\min(a_i, a_j)$ 로 만든다.

수열의 모든 수를 $0$으로 만들기 위한 최소 연산 횟수를 구하여라.

---

### [SOLUTION] Greedy

주어진 수열 $a$에 $0$인 수가 하나라도 있으면, $0$이 아닌 수를 한 번의 연산으로 $0$으로 만들 수 있다.

반대로 $0$이 하나도 없으면, 같은 수가 있는 경우와 모든 수가 서로 다른 경우로 나누어서 답을 구해준다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        vector<int> a(n);
        for (int i = 0; i < n; i++) cin >> a[i];
        sort(a.begin(), a.end());
        
        int cnt = 0;
        for (int i = 0; i < n; i++) if (!a[i]) cnt++;
        if (cnt)
        {
            cout << n - cnt << "\n";
            continue;
        }
        
        bool flg = 0;
        for (int i = 1; i < n; i++) if (a[i - 1] == a[i]) flg = 1;
        cout << n + (flg ? 0 : 1) << "\n";
    }
}
```

<br/>

## B2. Tokitsukaze and Good 01-String

[B2번 문제 링크](https://codeforces.com/contest/1678/problem/B2)

0과 1로만 이루어진 길이가 $n$인 문자열 $s$가 주어진다. ($n$은 짝수)

$s$를 0으로만 이루어진 부분문자열과 1로만 이루어진 부분문자열로 나누려고 하는데, 부분문자열들의 개수가 최소가 되도록 나눈다.

이때 모든 부분문자열의 길이가 짝수이면 $s$를 good라고 한다.

$s$에 대하여 $s_i$($1 \leq i \leq n$)를 0 또는 1로 바꾸는 연산을 할 수 있을 때,

주어진 문자열을 good로 만들기 위한 최소 연산 횟수를 구하여라.

또, 최소한의 연산을 통해 얻을 수 있는 부분문자열들의 개수 중 최솟값도 구하여라.

---

### [SOLUTION 1] Greedy

주어진 문자열을 앞에서부터 길이가 2인 부분문자열로 나누었을 때 "10" 또는 "01" 마다 1번의 연산이 필요하다.

부분문자열의 개수를 최소로 만들기 위해서는 "01" 또는 "10"을 **근처에 있는 "11"이나 "00"**로 바꾸어야한다.

예를 들어, "0010"은 "0000"으로 만들어야하고, "1101"은 "1111"로 만들어야 부분문자열의 개수가 최소가 된다.

따라서 전체 문자열을 길이가 2인 부분문자열로 나누었을 때 "01"과 "10"을 제외한 것들에 대하여, "00"과 "11"이 몇 번이나 번갈아서 나타나는지 구하면 된다.

단, "11"이나 "00"이 등장하지 않는 경우에는 최소 부분문자열의 개수는 항상 1이다.

```cpp
#include <iostream>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int t; cin >> t;
    while (t--)
    {
        int n; cin >> n;
        string s; cin >> s;
        
        int c = -1, x = 0, y = 0;
        for (int i = 0; i < n; i += 2)
        {
            if (s[i] != s[i + 1]) x++;
            else
            {
                if (c != s[i]) y++;
                c = s[i];
            }
        }
        cout << x << " " << max(y, 1) << "\n";
    }
}
```

> 나는 연속한 같은 문자열들끼리 묶고 시작했는데, 2시간 동안 다르게 풀어볼 생각을 안해본 것이 너무 바보같았다.
> 
> 애초에 시작부터 잘못된 방법으로 풀고 있지 않는지 확인하는 습관을 길러야할 것 같다.

---

### [SOLUTION 2] DP

> 만약 위의 그리디 풀이가 떠오르지 않았다면, DP로도 풀 수 있는 문제였다.
> 
> 단순히 A, B, C를 무조건 그리디로 풀려는 습관도 버려야할듯..

마찬가지로 전체 문자열을 길이가 2인 부분문자열들로 나누는데, "01"이나 "10"을 "00"과 "11" 중 어느 것으로 바꾸어야 하는지 확실하지 않으므로 DP를 이용하자.















