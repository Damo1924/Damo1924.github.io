---
title: "Vectors in C++"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Cpp
---

# 1. What is a Vector?
> Vectors are same as dynamic arrays with the **ability to resize itself automatically when an element is inserted or deleted**, with their storage being handled automatically by the container.

## 1-1. 벡터 선언하기
 벡터는 크기가 변할 수 있는 배열이다. 선언할 때 크기가 고정되는 배열과는 다르게 벡터는 원소를 추가하거나 삭제함에 따라 크기가 달라진다.
C++에서 벡터를 사용하기 위해서는 표준 라이브러리에서 제공하는 `std::vector`를 사용하면 되며, 이는 `<vector>` 헤더파일에 정의되어 있다.
```cpp
#include <vector>
int main()
{
    std::vector<int> vec = {1, 3, 5, 6};
}
```
벡터는 `std::vector<datatype> vector_name`와 같이 선언할 수 있으며, `datatype`에는 벡터에 저장하려는 원소들의 자료형을 넣어주면 된다.

## 1-2. 벡터의 원소에 접근하기
원소에 접근하기 위해서는 배열처럼 `[ ]`을 이용하면 된다.
```cpp
cout << vec[2] << endl;
```
```
5
```
벡터는 배열을 이용해서 원소들을 저장하기 때문에 **각 원소에 대해 연속적인 저장 공간을 할당**한다.
```cpp
cout << &vec[0] << endl;
cout << &vec[1] << endl;
cout << &vec[2] << endl;
cout << &vec[3] << endl;
```
```
0xb400007de7405010
0xb400007de7405014
0xb400007de7405018
0xb400007de740501c
```
위 사실을 이용하면 배열에서 한 것처럼 **포인터 연산으로 각 원소에 접근이 가능**하다는 것을 알 수 있다.
```cpp
cout << "vec[2] = " << *(&vec[0] + 2) << endl;
```
```
vec[2] = 5
```
<br/>
**#** 그렇다면 벡터는 배열을 이용해서 원소들을 저장함에도 원소를 추가하고 제거하는 것이 가능한 이유는 무엇일까?<br/>
`:` 벡터에 원소를 추가할 때마다 새로운 배열에 모든 원소를 옮기는 것(reallocate)은 시간적인 측면에서 매우 expensive한 방법이다. 그래서 vector container들은 원소의 추가로 인해 더 많은 저장공간이 필요할 것을 고려해서 벡터의 실제 크기보다 더 큰 용량(capacity)를 가진다. 그러다 할당된 용량 이상으로 원소가 추가되면 그 경우에만 새로운 배열로 reallocate하는 방식이다.

## 1-3. 벡터의 장단점
벡터는 다음과 같은 장단점을 가지고 있으므로, 상황에 맞게 알맞은 자료구조를 사용하면 된다.
- **벡터의 장점**<br/>
    1) 효율적으로 크기를 자유롭게 바꿀 수 있다. (dynamically sized)<br/>
    2) 벡터는 Deque, List 등과 같은 다른 dynamic sequence containers에 비해 원소에 접근하기가 매우 수월하며 효율적이다.<br/>
    3) 끝에서 원소를 추가하고 제거하는 작업이 다른 자료구조에 비해 상대적으로 더 효율적이다.<br/>
- **벡터의 단점**<br/>
    1) 같은 크기(원소 수가 동일한) 배열에 비해 더 많은 메모리를 사용한다.<br/>
    2) 중간에 원소를 추가하거나 제거하는 작업은 다른 자료구조에 비해 비효율적이다.<br/>


<br/>
# 2. Member functions of Vectors
## 2-1. Iterators: begin(), end()
**1) begin**: 벡터의 첫 번째 원소를 가리키는 반복자(iterator)를 반환
**2) end**: 벡터의 마지막 원소의 다음 원소(past-the-end element)를 가리키는 반복자(iterator)를 반환

past-the-end element는 마지막 원소 다음에 오는 **가상의 원소**로, 실제로 존재하지 않는 원소이기 때문에 역참조(dereference, \*)는 불가능하다. 표준 라이브러리의 함수들에서 사용되는 범위(range)가 closing iterator가 가리키는 원소를 포함하지 않기 때문에 `vec.begin()`과 `vec.end()`를 이용해서 문자열 전체를 포함하는 range를 만들 수 있다.
```cpp
vector<int> vec = {1, 3, 5, 6};
for(vector<int>::iterator it = vec.begin(); it != vec.end(); it++) cout << *it << " ";
```
```
1 3 5 6
```
: for문의 범위를 iterator를 이용해서 만들어서 벡터의 원소들을 공백으로 구분하여 출력해보았다. 반복자 `it`가 벡터의 가장 첫 번째 원소부터 마지막 원소까지 가리키게 된다.

## 2-2. Element Access: front(), back(), data()
**1) front()**: 벡터의 첫 번째 원소를 반환
**2) back()**: 벡터의 마지막 원소를 반환
**3) data()**: 벡터의 첫 번째 원소를 가리키는 포인터를 반환
```cpp
vector<int> vec = {1, 3, 5, 6};
cout << "First element = " << vec.front() << endl;
cout << "Last element = " << vec.back() << endl;

int *ptr = vec.data(); // pointing to the first element
*ptr = 100;
ptr++; // pointing to the second element
ptr[1] = 1000; // ptr[1] becomes the third element of vec
for(vector<int>::iterator it = vec.begin(); it != vec.end(); it++) cout << *it << " ";
```
```
First element = 1
Last element = 6
100 3 1000 6
```
: 위와 같이 벡터는 포인터 연산을 통해 원소에 접근하고 값을 수정하는 것이 가능하다.

## 2-3. Capacity: size(), length(), clear(), empty()








<br/>
# Reference
[1] [cplusplus, 'vector'](https://www.cplusplus.com/reference/vector/vector/)<br/>
[2] [Geeksforgeeks, 'vector in c++'](https://www.geeksforgeeks.org/vector-in-cpp-stl/)<br/>
