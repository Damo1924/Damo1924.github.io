---
title: "Vectors in C++"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Cpp
---

# 1. What is a Vector?
> Vectors are same as dynamic arrays with the **ability to resize itself automatically when an element is inserted or deleted**, with their storage being handled automatically by the container.

 벡터는 크기가 변할 수 있는 배열이다. 선언할 때 크기가 고정되는 배열과는 다르게 벡터는 원소를 추가하거나 삭제함에 따라 크기가 달라진다.
C++에서 벡터를 사용하기 위해서는 표준 라이브러리에서 제공하는 `std::vector`를 사용하면 되며, 이는 <vector> 헤더파일에 정의되어 있다.
```cpp
include <vector>
int main()
{
    std::vector<int> vec = {1, 3, 5, 6};
}
```
벡터는 `std::vector<datatype> vector_name`와 같이 선언할 수 있으며, `datatype`에는 벡터에 저장하려는 원소들의 자료형을 넣어주면 된다.

원소에 접근하기 위해서는 배열처럼 `[ ]`을 이용하면 된다.
```cpp
cout << vec[2] << endl;
```
```
5
```
벡터는 배열을 이용해서 원소들을 저장하기 때문에 각 원소에 대해 연속적인 저장 공간을 할당한다.
```cpp
cout << &vec[0] << endl;
cout << &vec[1] << endl;
cout << &vec[2] << endl;
cout << &vec[3] << endl;
```
```
0xb400007de7405010
0xb400007de7405014
0xb400007de7405018
0xb400007de740501c
```
위 사실을 이용하면 배열에서 한 것처럼 **포인터 연산으로 각 원소에 접근이 가능**하다는 것을 알 수 있다.
```cpp
cout << "vec[2] = " << *(&vec[0] + 2) << endl;
```
```
vec[2] = 5
```
<br/>
그렇다면 벡터는 배열을 이용해서 원소들을 저장함에도 원소를 추가하고 제거하는 것이 가능한 이유는 무엇일까?
> 벡터에 원소를 추가할 때마다 새로운 배열에 모든 원소를 옮기는 것(reallocate)은 시간적인 측면에서 매우 expensive한 방법이다. 그래서 vector container들은 원소의 추가로 인해 더 많은 저장공간이 필요할 것을 고려해서 벡터의 실제 크기보다 더 큰 용량(capacity)를 가진다. 그러다 할당된 용량 이상으로 원소가 추가되면 그 경우에만 새로운 배열로 reallocate하는 방식이다.
 
- **벡터의 장점**<br/>
    1) 효율적으로 크기를 자유롭게 바꿀 수 있다. (dynamically sized)<br/>
    2) 벡터는 Deque, List 등과 같은 다른 dynamic sequence containers에 비해 원소에 접근하기가 매우 수월하며 효율적이다.<br/>
    3) 끝에서 원소를 추가하고 제거하는 작업이 다른 자료구조에 비해 상대적으로 더 효율적이다.<br/>
- **벡터의 단점**<br/>
    1) 같은 크기(원소 수가 동일한) 배열에 비해 더 많은 메모리를 사용한다.<br/>
    2) 중간에 원소를 추가하거나 제거하는 작업은 다른 자료구조에 비해 비효율적이다.<br/>






# Reference
[1] [cplusplus, 'vector'](https://www.cplusplus.com/reference/vector/vector/)
[2] [Geeksforgeeks, 'vector in c++'](https://www.geeksforgeeks.org/vector-in-cpp-stl/)
