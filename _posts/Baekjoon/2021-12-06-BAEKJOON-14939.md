---

title: "[백준] 14939. 불 끄기"

toc: true

toc_label: "On this page"

toc_icon: "chevron-right"

categories:

  - PS

use_math: true

comments: true

---

## [백준] 14939. 불 끄기

[백준 14939. 불 끄기 문제 링크](https://www.acmicpc.net/problem/14939)

**[PROBLEM]**

전구 100개가 10 x 10 모양으로 늘어서 있다.

전구에 달린 스위치를 누르면 해당 전구와 위, 아래, 왼쪽, 오른쪽에 있는 전구의 상태도 바뀐다.

전구 100개의 상태가 주어지면 모든 전구를 끄기 위해 최소한으로 눌러야 하는 스위치의 개수를 출력하라.

**[INPUT]**

10줄에 걸쳐 10글자씩 입력이 주어진다.

#은 꺼진 전구, O는 켜진 전구이다.

**[OUTPUT]**

모든 전구를 끄기 위해 최소한으로 눌러야 하는 스위치의 개수를 출력한다.

만약 모든 전구를 끄는 것이 불가능하다면 -1을 출력한다.

<br/>

---

### [Solution] DFS

같은 스위치를 두 번 누르면 이전과 동일한 상태로 돌아가기 때문에 각 스위치를 최대 한 번만 누를 수 있다.

따라서 전체 경우의 수는 $2^100$인데, 이를 주어진 시간 내에 전부 탐색하는 것은 불가능하다.

그런데 눌러야 하는 스위치의 개수의 최솟값을 구하거나, 불을 전부 끄는 것이 불가능하다는 것을 알기 위해서는 가능한 경우를 모두 탐색하는 수밖에 없다.

살펴보아야 하는 경우의 수를 줄이기 위해 다음과 같은 생각을 해보았다.

첫 줄의 스위치들 각각에 대해 누를지 말지를 고정해두자.

첫 줄의 스위치들이 가질 수 있는 상태는 $2^10$ 가지이다.

이 상태에서 첫 줄에 있는 전구들을 보면, 오직 바로 아래에 있는 전구의 스위치에 의해서만 결정된다는 사실을 알 수 있다.

그러므로 두 번째 줄에 있는 스위치들은 첫 번째 줄에 있는 전구의 상태에 따라 자동으로 결정된다.

이를 반복하면 **k번째 줄에 있는 스위치들은 (k-1)번째 줄에 있는 전구의 상태에 따라 자동으로 결정**되므로 첫 줄을 제외한 모든 스위치가 자동으로 결정됨을 알 수 있다.

모든 스위치의 상태를 결정한 후에는 마지막 줄의 전구가 전부 꺼져있는지 확인하고 스위치를 누르는 횟수의 최솟값을 갱신한다.

이렇게 되면 첫 줄의 스위치들의 상태 $2^10$ 가지만 탐색하면 되므로 충분히 시간 내에 해결이 가능하다.

만약 모든 경우에 대해 마지막 줄의 전구들 중 하나라도 켜져있다면 불은 전부 끄는 것이 불가능하다는 의미이므로 -1을 출력한다.

전체 코드는 다음과 같다.

```cpp
#include <iostream>
using namespace std;

char L[12][12]; // 전구의 상태 저장

int ans = 10000; // 스위치를 누르는 횟수의 최솟값을 저장

int dx[] = {0, 1, -1, 0, 0}, dy[] = {0, 0, 0, 1, -1};

void switchPush (int x, int y) // L[x][y] 전구의 스위치를 눌렀을 때
{
    for (int i = 0; i < 5; i++)
    {
        if (L[x + dx[i]][y + dy[i]] == '#') L[x + dx[i]][y + dy[i]] = 'O';
        else L[x + dx[i]][y + dy[i]] = '#';
    }
}

void solve (int x, int y, int cnt)
{
    if (y == 11) solve(x + 1, 1, cnt);
    
    else if (x == 1) // 첫 번째 줄
    {
        solve(x, y + 1, cnt); // 스위치를 누르지 않는 경우
        
        switchPush(x, y);
        solve(x, y + 1, cnt + 1); // 스위치를 누르는 경우
        switchPush(x, y);
    }
    
    else if (x <= 10) // 나머지 스위치들은 자동 결정
    {
        if (L[x - 1][y] == '#') solve(x, y + 1, cnt);
        else
        {
            switchPush(x, y);
            solve(x, y + 1, cnt + 1);
            switchPush(x, y);
        }
    }
    
    else // 마지막 줄의 전구가 모두 꺼져있는지 확인
    {
        bool flg = 0;
        for (int i = 1; i <= 10; i++)
        {
            if (L[10][i] == 'O')
            {
                flg = 1;
                break;
            }
        }
        if (!flg && ans > cnt) ans = cnt; 
    }
}

int main()
{
    for (int i = 1; i <= 10; i++)
        for (int j = 1; j <= 10; j++)
            cin >> L[i][j];
    
    solve(1, 1, 0);
    if (ans == 10000) cout << -1;
    else cout << ans;
}
```



