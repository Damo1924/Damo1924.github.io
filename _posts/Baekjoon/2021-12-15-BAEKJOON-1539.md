---

title: "[백준] 1539. 이진 검색 트리"

toc: true

toc_label: "On this page"

toc_icon: "chevron-right"

categories:

  - PS

use_math: true

comments: true

---

`Tags` 이진 검색 트리, BST

## [백준] 1539. 이진 검색 트리

[백준 1539. 이진 검색 트리 문제 링크](https://www.acmicpc.net/problem/1539)

**[PROBLEM]**

N개의 숫자가 주어진다.

이 숫자들을 입력된 순서대로 이진 검색 트리에 삽입할 때, 모든 노드의 높이의 합을 구하여라.

단, 노드의 높이는 (루트에서 노드까지의 거리) + 1 이다.

**[INPUT]**

첫째 줄에 N이 주어진다. ($1 \leq N \leq 250000$)

다음 N개 줄에 걸쳐 이진 검색 트리에 삽입할 숫자가 주어진다.

**[OUTPUT]**

최종 이진 검색 트리에 있는 노드들의 높이의 합을 출력한다.

단, 높이의 합이 $2^{63}$ 이하인 경우만 입력으로 주어진다.

---

### [Solution] BST

이진 검색 트리에 대한 이해도가 높아야 해결할 수 있는 문제이다.

주어질 수 있는 N의 범위가 크기 때문에 이진 트리를 배열로 구현할려면 매우 긴 배열이 필요할 뿐만 아니라, 트리의 높이가 높아지면 그만큼 삽입할 때 시간이 오래 걸린다.

그러므로 로그 시간에 주어진 숫자를 트리에 삽입하고 높이를 구할 수 있는 방법을 생각해야 한다.

나는 예전에 풀어본 [백준 2250. 트리의 높이와 너비](https://www.acmicpc.net/problem/2250)에서 나오는 그림에서 아이디어를 얻을 수 있었다.

다음은 위 문제에서 나오는 이진트리를 격자 모양의 틀 속에 그리는 방법이다.

<img src="https://user-images.githubusercontent.com/88201512/146142765-55a1e460-330f-46af-ba90-2cbbd4554620.jpg" width="70%" height="70%">

**규칙**
> 1. 이진트리에서 같은 레벨에 있는 노드는 같은 행에 위치한다.
> 2. 한 열에는 한 노드만 존재한다.
> 3. 임의의 노드의 왼쪽 서브트리에 있는 노드들은 해당 노드보다 왼쪽 열에 위치하고, 오른쪽 서브트리에 있는 노드들은 해당 노드보다 오른쪽 열에 위치한다.

이 규칙을 정확히 알 필요는 없고, 그림에 나온 것처럼 이진 트리를 떠올리면 충분하다.

이진 검색 트리를 그림과 같이 그리고 왼쪽 끝 열부터 오른쪽 방향으로 숫자들을 읽어나가면 **오름차순 정렬**된 순서라는 것을 알 수 있다.

즉, **새로운 원소를 이진 검색 트리에 삽입하면 그 위치는 다음 두 숫자 사이가 되는 것이다.**

- 삽입하는 숫자보다 작은 수들 중 가장 큰 수 = A
- 삽입하는 숫자보다 큰 수들 중 가장 작은 수 = B

이진 검색 트리의 원소들을 `set`에 저장하면, B는 `lower_bound()`, A는 `prev(lower_bound()`를 통해 얻을 수 있다.

그런데 우리는 삽입한 노드의 높이를 구해야한다.

높이를 구하기 위해서는 삽입한 숫자가 앞에서 구한 A, B 중 어느 노드의 자식 노드인지 알면 된다.

결론부터 말하자면, **두 숫자 중 더 높이가 큰 숫자의 자식 노드**이다.

이진 검색 트리는 중위순회를 하면 오름차순으로 정렬된 값들을 얻을 수 있다.

중위순회는 어떤 노드에 대해 "왼쪽 서브트리, 해당 노드, 오른쪽 서브트리"의 순서로 트리를 순회하는 것을 말하는데, 잘 생각해보면 A와 B는 어떤 노드를 선택해도 다른 서브트리에 있을 수 없다.

만약 어떤 노드 K에 대해 A가 왼쪽 서브트리, B가 오른쪽 서브트리에 있게 된다면, K는 A보다 크고 B보다 작기 때문에 A와 B 중 하나가 정의에 모순된다.

이는 B에 대해 중위순회를 할 때 A가 왼쪽 서브트리에 있거나, A에 대해 중위순회를 할 때 B가 오른쪽 서브트리에 있다는 의미로 해석할 수 있다.

즉, A와 B는 **삽입된 원소부터 루트 노드까지의 경로 위에 있는 노드들**이라는 뜻이다.

이로부터 삽입된 원소의 높이는 max(A의 높이, B의 높이) + 1 로 구할 수 있음을 알 수 있다.

전체 코드는 다음과 같다.

```cpp
#include <iostream>
#include <set>
#include <iterator>
using namespace std;

set<pair<int, int>> BST; // {숫자, 높이}를 저장하는 set

long long heightSum = 1; // 높이의 합

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    int N;
    cin >> N;
    
    // 첫 번째 원소를 루트에 삽입
    int P;
    cin >> P;
    BST.insert({P, 1}); // 루트의 높이는 1
    
    for (int i = 1; i < N; i++)
    {
        cin >> P;
        auto it = BST.lower_bound({P + 1, 0});
        
        int h; // 삽입하려는 원소의 부모 노드의 높이
        if (it == BST.end()) h = prev(it)->second;
        else if (it == BST.begin()) h = it->second;
        else h = max(it->second, prev(it)->second);
        
        BST.insert({P, h + 1}); // 부모 노드의 높이 + 1
        heightSum += h + 1;
    }
    cout << heightSum;
}
```











