---

title: "[BOJ] 10070. 벽"

toc: true

toc_label: "On this page"

toc_icon: "chevron-right"

categories:

  - PS

use_math: true

comments: true

---

`Tags` lazy propagation, segment tree

## [BOJ] 10070. 벽

[BOJ 10070. 벽 문제 링크](https://www.acmicpc.net/problem/10070)

**[PROBLEM]**

$0$부터 $n-1$까지 번호가 매겨진 $n$개의 열에 벽돌을 쌓아 벽을 만들려고 한다.

각 열의 높이는 해당 열에 쌓여있는 벽돌의 개수이다.

처음에는 어떤 열에도 벽돌이 없고, 아래의 두 가지 작업으로 이루어진 총 $k$단계에 거쳐 벽을 세우게 된다.

- $1$ $l$ $r$ $h$ : 모든 $l \leq i \leq j$ 에 대하여 $i$열의 높이가 $h$보다 작다면 벽돌을 추가하여 높이를 $h$로 만든다.
- $2$ $l$ $r$ $h$ : 모든 $l \leq i \leq j$ 에 대하여 $i$열의 높이가 $h$보다 크다면 벽돌을 제거하여 높이를 $h$로 만든다.

이때 모든 단계를 수행한 후의 각 열의 높이를 구하여라.

**[INPUT]**

첫 번째 줄에는 두 정수 $n, k$($1 \leq n \leq 2000000$, $1 \leq k \leq 500000)이 주어진다.

두 번째 줄부터 $k$개의 줄에 걸쳐 각 단계에 수행해야하는 작업이 주어진다.

**[OUTPUT]**

모든 단계를 수행한 후의 각 열의 높이를 한 줄에 하나씩 출력한다.

---

### [SOLUTION] Segment tree with Lazy propagation

각 노드에 해당하는 열들의 **최소 높이와 최대 높이**를 저장하는 세그먼트 트리를 생각하자.

노드 $i$의 최소 높이를 $lb\[i\]$(lower bound), 최대 높이를 $ub\[i\]$(upper bound)라고 할 때,

업데이트를 수행하는 구간에 포함되는 노드들에 대하여 다음 연산을 수행해주자.

- 최소 높이를 $h$로 만듦(1번 쿼리): $lb\[i\] = max(lb\[i\], h)$, $ub\[i\] = max(ub\[i\], h)$
- 최대 높이를 $h$로 만듦(2번 쿼리): $lb\[i\] = min(lb\[i\], h)$, $ub\[i\] = min(ub\[i\], h)$

벽을 쌓는 방법을 생각해보았을 때 위와 같이 쿼리들을 처리해주는 것은 타당해보인다.

이제 모든 $i$에 대하여 $i$열의 높이를 구하면 답을 얻을 수 있다.

이는 **$i$열을 포함하는 노드들을 탐색하면서 높이를 구하면 될 것** 같이 보인다.

즉, **구간 업데이트와 특정 원소의 값을 구하는 쿼리를 처리할 수 있는 세그먼트 트리**를 구현함으로써 해결할 수 있을 것 같다.

그러나 좀 더 생각해보면, 위 방법의 치명적인 오류를 발견할 수 있다.

주어진 방법대로 벽을 쌓을 때는 **쿼리들의 순서가 매우 중요**하다.

그런데 위 방법은 **쿼리들의 순서를 무시**하게 된다.

단순히 어떤 구간에 특정 값을 더하고 빼는 쿼리들이 주어지는 문제라면 위와 같이 해결할 수 있겠으나, 이 문제에는 사용할 수 없다.

즉, **어떤 구간 쿼리를 처리하기 전에 해당 구간과 일부가 겹치는 노드들에 대하여 노드들에 저장된 정보를 자식 노드로 전파하는 과정이 필요**하다.

좀 더 직관적인 이해를 위해 그림을 그려보았다.

<center><img src="" width="60%" height="60%"></center>
















