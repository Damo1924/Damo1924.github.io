---
title: "[백준] 6549. 히스토그램에서 가장 큰 직사각형"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - PS
use_math: true
comments: true

---

## [백준] 6549. 히스토그램에서 가장 큰 직사각형

[백준 6549. 히스토그램에서 가장 큰 직사각형 문제 링크](https://www.acmicpc.net/problem/6549)

**[PROBLEM]**

각 직사각형(막대)의 너비가 1인 히스토그램이 있다.

이 히스토그램 내에 있는 직사각형 중 가장 넓이가 큰 직사각형의 넓이를 구해서 출력한다.

**[INPUT]**

입력은 여러 개의 테스트케이스로 이루어져 있다.

각 테스트케이스는 한 줄로 이루어져 있고, 첫 번째로 히스토그램을 구성하는 직사각형의 수 n이 주어진다.

이어서 각 직사각형(막대)의 높이를 의미하는 n개의 숫자들이 주어진다. ($1 \leq n \leq 10^5$)

각 직사각형의 높이는 0 이상 1,000,000,000 이하의 정수이며, 모든 직사각형의 너비는 1이다.

입력의 마지막 줄에는 0이 하나 주어진다.

**[OUTPUT]**

각 테스트케이스에 대해서 히스토그램에서 가장 넓이가 큰 직사각형의 넓이를 출력한다.


<br/>

---

### [SOLUTION 1] Divide & Conquer

첫 번째 해결 방법은 분할 정복을 이용하는 방법이다.

주어진 히스토그램을 나누어서 각각의 영역에서 가장 큰 직사각형의 넓이를 구하고, 이들 중 가장 큰 것의 넓이를 택하면 된다.

그런데 이러면 나누어진 영역들에 걸쳐 있는 직사각형들의 넓이를 고려하지 못하게 되는데, 분할 기준을 다음과 같이 선택함으로써 이 문제를 해결할 수 있다.

> **주어진 영역 내에 가장 높이가 낮은 직사각형을 기준**으로 왼쪽 영역과 오른쪽 영역으로 나눈다.

위와 같이 영역을 나누고 다음 세 값 중 가장 큰 값을 반환하는 함수를 구현함으로써 최대 넓이를 구할 수 있다.

> 왼쪽 영역의 최대 넓이, 오른쪽 영역의 최대 넓이, 기준으로 삼은 직사각형의 높이 x 히스토그램의 너비

다만, 매번 최소 높이를 찾기 위해 선형 탐색을 사용하면 $O(n^2)$의 시간복잡도를 가지게 되어 시간 내에 해결할 수 없다.

그러므로 정렬되지 않은 값들 중 최솟값을 빠르게 찾아낼 수 있는 방법을 사용해야하는데, 여기서는 **Segment Tree**를 사용한다.

(Segment Tree에 대한 내용은 [이 포스트]()에서 다루고 있다.)

Segment Tree에는 각 해당 영역의 최소 높이를 가진 직사각형의 인덱스를 저장하도록 한다.

```cpp
int segTree[1000000]; // segTree: 세그먼트 트리의 노드를 저장, 인덱스는 1부터 시작

void init(int start, int end, int idx) // 세그먼트 트리 구현하기: [start, end) 범위에 해당하는 히스토그램에서 가장 높이가 작은 직사각형의 인덱스를 저장
{
    if (start >= end) return;
    if (start + 1 == end)
    {
        segTree[idx] = start;
        return;
    }

    int mid = (start + end) / 2;
    init(start, mid, 2 * idx); // 왼쪽 자식 노드의 인덱스 = 2 * idx
    init(mid, end, 2 * idx + 1); // 오른쪽 자식 노드의 인덱스 = 2 * idx + 1

    // 두 자식 노드 중 더 작은 높이를 가진 값을 선택
    if (h[segTree[2 * idx]] < h[segTree[2 * idx + 1]]) segTree[idx] = segTree[2 * idx];
    else segTree[idx] = segTree[2 * idx + 1];
}
```

Segment Tree를 이용해서 원하는 영역의 최소 높이 인덱스를 반환하는 함수를 구현하였다.

```cpp
int minHeight(int start, int end, int idx, int left, int right) // [left, right) 범위에서 가장 작은 높이를 가진 직사각형의 인덱스를 반환
{
    if (start >= right || end <= left) return -1;
    if (start >= left && end <= right) return segTree[idx];

    int mid = (start + end) / 2;
    int a = minHeight(start, mid, 2 * idx, left, right); // 왼쪽 영역의 최소 높이 인덱스
    int b = minHeight(mid, end, 2 * idx + 1, left, right); // 오른쪽 영역의 최소 높이 인덱스
    if (a == -1) return b; // 어느 하나가 -1이면 다른 하나를 반환
    if (b == -1) return a;
    if (h[a] < h[b]) return a; // 둘 다 -1이 아니라면 더 높이가 작은 쪽을 반환
    else return b; 
}
```

이때 `idx`, `start`, `end`는 각각 Segment Tree의 인덱스, 해당 인덱스가 나타내는 범위의 시작과 끝을 의미한다.

현재 Segment Tree가 나타내는 범위 `[start, end)`가 최소 높이를 구하고자 하는 범위 `[left, right)`에 포함되면 Segment Tree에 저장된 값을 반환하고, 아예 겹치지 않는다면 -1을 반환한다.

두 범위가 서로 조금씩 겹쳐 있다면 `[start, end)`를 반으로 나누어서 왼쪽과 오른쪽 영역의 최소 높이를 구한 다음 더 작은 것을 반환한다.

이제, 이를 이용해서 가장 큰 직사각형의 넓이를 구하는 함수를 다음과 같이 구현할 수 있다.

```cpp
ll maxArea(int start, int end, int n)
{
    if (start >= end) return 0;
    if (start + 1 == end) return h[start];

    int mid = minHeight(0, n, 1, start, end);
    return max((ll)h[mid] * (end - start), max(maxArea(start, mid, n), maxArea(mid + 1, end, n)));
}
```

전체 코드는 아래를 클릭하면 확인할 수 있다.

<details>
<summary>전체 코드</summary>
<div markdown="1">

```cpp
#include <iostream>
using namespace std;
typedef long long ll;

int h[100000];

int segTree[1000000];

void init(int start, int end, int idx)
{
    if (start >= end) return;
    if (start + 1 == end)
    {
        segTree[idx] = start;
        return;
    }

    int mid = (start + end) / 2;
    init(start, mid, 2 * idx);
    init(mid, end, 2 * idx + 1);

    if (h[segTree[2 * idx]] < h[segTree[2 * idx + 1]]) segTree[idx] = segTree[2 * idx];
    else segTree[idx] = segTree[2 * idx + 1];
}

int minHeight(int start, int end, int idx, int left, int right)
{
    if (start >= right || end <= left) return -1;
    if (start >= left && end <= right) return segTree[idx];

    int mid = (start + end) / 2;
    int a = minHeight(start, mid, 2 * idx, left, right);
    int b = minHeight(mid, end, 2 * idx + 1, left, right);
    if (a == -1) return b;
    if (b == -1) return a;
    if (h[a] < h[b]) return a;
    else return b; 
}

ll max(ll a, ll b) { return (a < b) ? b : a; }

ll maxArea(int start, int end, int n)
{
    if (start >= end) return 0;
    if (start + 1 == end) return h[start];

    int mid = minHeight(0, n, 1, start, end);
    return max((ll)h[mid] * (end - start), max(maxArea(start, mid, n), maxArea(mid + 1, end, n)));
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int n;
    while (1)
    {
        cin >> n;
        if (n == 0) break;

        for (int i = 0; i < n; i++) cin >> h[i];

        init(0, n, 1);

        cout << maxArea(0, n, n) << "\n";
    }
}
```

</div>
</details>

---

### [SOLUTION 2] Stack

