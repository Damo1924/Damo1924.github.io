---

title: "[백준] 1167. 트리의 지름"

toc: true

toc_label: "On this page"

toc_icon: "chevron-right"

categories:

  - PS

use_math: true

comments: true

---

## [백준] 1167. 트리의 지름

[백준 1167. 트리의 지름 문제 링크](https://www.acmicpc.net/problem/1167)

**[PROBLEM]**

트리의 지름이란 트리에서 임의의 두 점 사이의 거리 중 가장 긴 것을 말한다.

트리가 주어졌을 때, 트리의 지름을 구하여라.

**[INPUT]**

첫째 줄에는 트리의 정점의 개수 V가 주어진다. ($2 \leq V \leq 100000$)

둘째 줄부터 V개의 줄에 걸쳐 간선의 정보가 주어진다.

각 줄은 정점 번호와 해당 정점에 연결된 정점 번호와 해당 간선의 길이로 이루어져 있다.

**[OUTPUT]**

첫째 줄에 트리의 지름을 출력한다.

<br/>

---

### [Solution 1] DFS 한 번 사용

트리의 지름은 어떤 정점으로부터 가장 멀리 떨어진 두 정점까지의 거리를 합한 것이라고 할 수 있다.

한 정점으로부터 다른 정점까지의 거리를 구하는 것은 트리를 DFS로 탐색하면 된다.

다음은 전체 코드이다.

```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<pair<int, int>> tree[100001]; // 트리의 간선 정보를 저장

int visited[100001], ans = 0; // visited: 정점의 방문 여부 체크, ans: 트리의 지름 저장

int maxD (int node)
{
    int m1 = 0, m2 = 0; // 가장 먼 정점까지의 거리 m1, 두번째로 먼 정점까지의 거리 m2
    visited[node] = 1;
    for (int i = 0; i < tree[node].size(); i++)
    {
        pair<int, int> next = tree[node][i];
        if (visited[next.first]) continue; // 방문한 적 있으면 continue
        
        int D = maxD(next.first) + next.second;
        if (D > m1)
        {
            m2 = m1;
            m1 = D;
        }
        else if (D > m2)
        {
            m2 = D;
        }
    }
    
    if (ans < m1 + m2) ans = m1 + m2;
    return m1;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    int V; // 정점의 개수
    cin >> V;
    
    int n, m, d; // n: 정점 번호, m: n과 연결된 정점 번호, d: n과 m을 잇는 간선의 길이
    for (int i = 0; i < V; i++)
    {
        cin >> n >> m >> d;
        tree[n].push_back({m, d});
        
        cin >> m;
        while (m != -1)
        {
            cin >> d;
            tree[n].push_back({m, d});
            cin >> m;
        }
    }
    
    maxD(1);
    cout << ans;
}
```

재귀함수를 통해 트리를 탐색하는 DFS를 구현하였다.

이 풀이의 핵심 아이디어는 `m1`, `m2` 두 개의 서로 다른 경로의 길이를 저장하면서 답을 구한다는 것이다.

`m1`에는 현재 정점으로부터 가장 멀리 떨어진 정점까지의 거리를, `m2`에는 두 번째로 먼 정점까지의 거리를 저장한다.

재귀함수 내의 반복문을 살펴보자.

`next.first`는 현재 정점인 `node`에 연결된 정점이고, `next.second`는 간선의 길이를 의미한다.

이때 `D`는 (`next.first`로부터 가장 멀리 떨어진 정점까지의 거리) + (`node`와 `next.first`를 잇는 간선의 길이)가 된다.

현재 정점과 연결된 정점들을 탐색하면서 구한 `D`와 기존의 `m1`과 `m2`를 비교하여 적절히 값을 갱신하면 된다.

이렇게 `m1`과 `m2`의 값을 구했다면, 트리의 지름을 저장하는 변수 `ans`와 `m1 + m2`를 비교하여 값을 갱신한다.

함수의 반환값은 가장 먼 정점까지의 거리인 `m1`가 된다.

> 이렇게 임의의 정점에 대해 위 재귀함수를 실행(`maxD(1)`)시켜서 답을 얻을 수 있다는 사실이 직관적으로 다가오지 않을 수도 있다.
> 
> 왜냐하면 정점 1부터 트리를 따라 내려오면서 `m1`과 `m2`를 구하기 때문에 실제로 해당 정점에서 가장 먼 정점까지의 거리가 아니라 **지금까지 탐색하지 않은 정점들 중 가장 먼 정점까지의 거리**가 된다.
> 
> 이로 인해 "모든 경우의 수를 다 탐색해보지 않은 것이 아닌가?"라는 의문이 들 수도 있다.
> 
> 













