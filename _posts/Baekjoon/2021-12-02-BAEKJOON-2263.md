---

title: "[백준] 2263. 트리의 순회"

toc: true

toc_label: "On this page"

toc_icon: "chevron-right"

categories:

  - PS

use_math: true

comments: true

---

## [백준] 2263. 트리의 순회

[백준 2263. 트리의 순회 문제 링크](https://www.acmicpc.net/problem/2263)

**[PROBLEM]**

$n$개의 정점을 갖는 이진 트리의 정점에 1부터 $n$까지의 번호가 중복 없이 매겨져 있다.

주어진 이진 트리를 중위 순회한 결과와 후위 순회한 결과가 주어질 때, 전위 순회한 결과를 구하여라.

**[INPUT]**

첫째 줄에 $n$이 주어진다. ($1 \leq n \leq 100000$)

둘째 줄에는 중위 순회한 결과를 나타내는 $n$개의 자연수가 주어지고, 셋째 줄에는 후위 순회한 결과를 나타내는 $n$개의 자연수가 주어진다.

**[OUTPUT]**

이진 트리를 전위 순회한 결과를 출력한다.

<br/>

---

### [Solution] 분할 정복

전위 순회, 중위 순회, 후위 순회를 구분하는 것은 현재 노드, 왼쪽 서브트리, 오른쪽 서브트리를 어떤 순서로 탐색하는지이다.

이때 전위 순회와 후위 순회를 한 결과의 특징은 현재 노드가 맨 끝에 위치하고 있다는 점이다.

전위 순회로 어떤 노드를 루트로 하는 서브트리를 순회하면 해당 노드가 맨 앞에 등장하고, 후위 순회로 탐색하면 해당 노드가 맨 뒤에 등장하게 된다.

그러므로 우리는 문제에서 주어진 **후위 순회 결과를 통해 현재 탐색하고 있는 서브트리의 루트 노드를 알 수 있다**.

문제는 후위 순회의 결과가 `(왼쪽 서브트리 순회 결과, 오른쪽 서브트리 순회 결과, 루트 노드)`와 같은 형태로 있을 때, 왼쪽 서브트리가 어디까지인지 알 수 없다는 것이다.

왼쪽 서브트리의 결과의 맨 오른쪽 끝이 왼쪽 서브트리의 루트 노드이므로 이를 알아야 위와 같은 방법으로 전위 순회한 결과를 찾을 수 있다.

여기서 필요한 것이 바로 **왼쪽 서브트리에 있는 노드의 개수**임을 알 수 있다.

이를 구하기 위해서 문제에서 주어진 중위 순회의 결과를 이용한다.

중위 순회는 `(왼쪽 서브트리 순회 결과, 루트 노드, 오른쪽 서브트리 순회 결과)`와 같은 형태이므로 루트 노드의 위치를 안다면 각 서브트리에 있는 원소의 개수도 구할 수 있다.

후위 탐색으로부터 루트 노드의 번호를 알고 있으므로 해당 번호의 노드가 중위 순회 결과에서 몇 번째로 등장하는지를 알면 된다.

이를 재귀함수로 구현하면 원하는 결과를 얻을 수 있고, 전체 코드는 다음과 같다.

```cpp
#include <iostream>
using namespace std;

int in[100000]; // in[i] = i번 노드가 중위 순회 결과 몇 번째인지 저장

post[100000]; // post[i] = 후위 순회 결과의 i번째 노드 번호를 저장

void preOrder (int inL, int postL, int postR)
{
    if (postL > postR) return;
    
    // 현재 노드 탐색 = 후위 순회 결과의 맨 오른쪽 끝 노드
    int root = post[postR];
    cout << root << " ";
    
    int idx = in[root]; // 현재 노드가 중위 순회 결과에서 몇 번째인지를 의미
    preOrder(inL, postL, postL + (idx - inL) - 1); // 왼쪽 서브트리 탐색
    preOrder(idx + 1, postL + (idx - inL), postR - 1); // 오른쪽 서브트리 탐색
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    int n, tmp;
    cin >> n;
    for (int i = 0; i < n; i++) { cin >> tmp; in[tmp] = i; }
    for (int i = 0; i < n; i++) cin >> post[i];
    
    preOrder(0, 0, n-1);
}
```

이때 재귀함수의 각 매개변수는 다음과 같다.

> `inL` = 중위순회의 결과 중 `in[inL]`부터 탐색 중임을 의미한다.
> 
> `postL`, `postR` = 후위순회의 결과 중 `post[postL]`부터 `post[postR]`까지를 탐색 중임을 의미한다.

