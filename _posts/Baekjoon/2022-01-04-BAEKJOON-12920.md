---

title: "[백준] 12920. 평범한 배낭 2"

toc: true

toc_label: "On this page"

toc_icon: "chevron-right"

categories:

  - PS

use_math: true

comments: true

---

`Tags` Knapsack problem, DP

## [백준] 12920. 평범한 배낭 2

[백준 12920. 평범한 배낭 2 문제 링크](https://www.acmicpc.net/problem/12920)

**[PROBLEM]**

민호는 캠프에 가기 위해 가방을 싸려고 한다.

전체 물건의 종류는 N개이고, 각 물건의 무게 V, 물건을 가방에 넣었을 때 민호가 얻는 만족도 C, 그리고 물건의 개수 K가 주어진다.

민호가 들 수 있는 최대 무게가 M일 때, 민호가 얻을 수 있는 최대의 만족도를 구하여라.

**[INPUT]**

첫 번째 줄에 N, M이 주어진다. ($1 \leq N \leq 100$, $1 \leq M \leq 10000$)

두 번째 줄부터 N개의 줄에 걸쳐 각 물건의 정보가 세 자연수 V, C, K로 주어진다.

($1 \leq V \leq M$, $1 \leq C, K \leq 10000$, $1 \leq V \times K \leq 10000$)

**[OUTPUT]**

전체 무게가 M을 초과하지 않으면서 민호가 얻을 수 있는 최대의 만족도를 출력한다.

---

**[IDEA]**

처음에는 [평범한 배낭](https://www.acmicpc.net/problem/12865) 문제를 푼 방법을 확장시켜서 풀어보려 했다.

> `dp[i][w]` = i번째 물건까지 탐색한 상황에서 가방의 무게가 w 이하일 때 얻을 수 있는 최대 만족도

위와 같은 배열을 반복문을 통해서 채워나가면 구하고자 하는 값을 `dp[N][M]`이 된다.

아래는 내 첫 번째 코드였다.

```cpp
#include <iostream>
using namespace std;

int N, M;

int V[101], C[101], K[101];

int dp[101][10001];

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> N >> M;
    for (int i = 1; i <= N; i++) cin >> V[i] >> C[i] >> K[i];
    
    for (int i = 1; i <= N; i++)
    {
        // 물건을 하나 선택하는 경우
        for (int j = 1; j < V[i]; j++)
            dp[i][j] = dp[i - 1][j];
        for (int j = V[i]; j <= M; j++)
            dp[i][j] = max(dp[i - 1][j], C[i] + dp[i - 1][j - V[i]]);
        
        // 물건을 두 개 이상 고를 수 있는 경우 추가적인 갱신
        for (int k = 2; k <= K[i]; k++)
        {
            int v = V[i] * k;
            int c = C[i] * k;
            for (int j = M; j >= v; j--)
            {
                dp[i][j] = max(dp[i][j], c + dp[i - 1][j - v]);
            }
        }
    }
    
    cout << dp[N][M];
}
```

위 코드가 dp 배열의 값을 몇 번 갱신하는지 알아보도록 하자.

갱신 횟수를 $C$라고 하면, 다음과 같다.

\begin{aligned}
c = \sum_{i=1}^N \left( M + \sum_{k = 2}^K_i \left( M - V_ik \right) \right)
\end{aligned}

위 식을 조금 정리해보면,

\begin{aligned}
c = \sum_{i=1}^N \left( MK_i  - V_i \times \frac{(K_i - 1)(K_i + 2)}{2} \right)
\end{aligned}

를 얻을 수 있다.

$c$를 최대한 크게 만들기 위한 $V_i$와 $K_i$를 생각해보면, $K_i = 10000$인 경우라는 것을 알 수 있다.

$N = 100$, $M = 10000$, 모든 $i$에 대해서 $V_i = 1$, $K_i = 10000$이면, $c$는 대략 $5 \times 10^9$이다.

일반적으로 1초에 간단한 연산을 $10^9$번 정도 수행할 수 있다는 점을 고려해보면, 1초 내에 위 예시가 통과할 리가 없다는 것을 알 수 있다.



---

### [Solution] 












