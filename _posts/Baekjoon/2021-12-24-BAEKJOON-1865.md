---

title: "[백준] 1865. 웜홀"

toc: true

toc_label: "On this page"

toc_icon: "chevron-right"

categories:

  - PS

use_math: true

comments: true

---

`Tags` Negative Cycle, Bellman-Ford algorithm

## [백준] 1865. 웜홀

[백준 1865. 웜홀 문제 링크](https://www.acmicpc.net/problem/1865)

**[PROBLEM]**

월드나라에는 N개의 지점이 있고, N개의 지점 사이에는 M개의 도로와 W개의 웜홀이 있다.

도로는 양방향으로 모두 이동할 수 있지만, 웜홀은 정해진 방향으로만 이동이 가능하다.

웜홀 내에서는 시간이 거꾸로 간다는 특징이 있다.

어떤 한 지점에서 출발을 해서 다시 출발을 하였던 위치로 돌아왔을 때, 출발을 하였을 때보다 시간이 뒤로 가게 되는 경우가 있는지 구하여라.

**[INPUT]**

첫 줄에는 테스트케이스의 개수 TC가 주어진다. ($1 \leq TC \leq 5$)

두 번째 줄부터 각 테스트케이스가 주어진다.

각 테스트케이스의 첫 번째 줄에는 지점의 수 N, 도로의 개수 M, 웜홀의 개수 W가 주어진다.

($1 \leq N \leq 500$, $1 \leq M \leq 2500$, $1 \leq W \leq 200$)

다음 M개의 줄에 걸쳐 도로의 정보가 S, E, T 세 정수로 주어진다.

S, E는 연결된 지점의 번호, T는 도로를 통해 이동하는데 걸리는 시간이다.

다음 W개의 줄에는 웜홀의 정보가 S, E, T 세 정수로 주어진다.

S는 출발 지점, E는 도착 지점, T는 웜홀을 통해 이동했을 때 줄어드는 시간이다.

단, 두 지점을 연결하는 도로가 한 개보다 많은 수도 있다.

**[OUTPUT]**

각 테스트케이스에 대해 시간이 줄어들면서 출발 위치로 돌아오는 것이 가능하다면 YES, 불가능하면 NO를 출력한다.

---

**[Thinking]**

이 문제를 풀 때 자주 하는 실수는 음의 사이클을 찾는 문제인 것을 보고 **벨만-포드 알고리즘을 그대로 적용하는 것**이다.

벨만-포드 알고리즘은 **단일-출발 최단 경로 문제**를 해결하는 방법으로, 어떤 한 지점으로부터 다른 모든 지점들까지의 최단 거리를 찾는다.

그 과정은 다음과 같다.

1. 최단 경로를 저장하는 배열 `dist`를 모든 지점(1 ~ N)에 대해 매우 큰 값(`INF`)로 초기화한다.
2. 출발 지점 `s`에 대해서 `dist[s] = 0`로 둔다.
3. 모든 간선에 대해 `dist`를 더 작은 거리로 갱신하는 과정을 (N-1)번 반복한다. 단, `dist[i] = INF`인 지점 `i`에서 출발하는 경우는 무시한다.
4. 모든 간선에 대해 순회하며 `dist`가 갱신되는 경우가 있다면 음의 사이클이 존재한다는 의미이다.

하지만 이 문제의 경우 출발점이 어떤 지점 `s`로 고정된 것도 아니고, 모든 지점이 연결되어 있다는 조건도 없다.

즉, 주어진 그래프가 **여러 개의 연결 요소로 구성**될 수도 있다는 것이다.

그래서 일반적인 벨만-포드 알고리즘을 적용해서 풀면, 다음과 같은 반례를 들 수 있게 된다.

```
1
4 2 1
2 3 1
3 4 1
4 2 10
```

1번부터 4번까지의 지점이 있을 때, 2-3-4-2는 사이클마다 시간이 8씩 줄어드는 음의 사이클이다.

보통 출발 지점 `s`를 첫 번째 지점으로 두기 때문에 `dist[1] = 0`이라 하고 벨만-포드 알고리즘을 수행하면, 1번 지점과 연결된 지점은 없기 때문에 `dist` 배열이 갱신되는 경우가 없다.

모든 간선을 순회하며 최단 거리를 갱신하는 과정을 아무리 반복해도 값이 갱신되지 않으므로 음의 사이클이 없다는 결과를 반환하게 되는 것이다.

그렇다면 다음과 같은 결론을 얻을 수 있다.

> 그래프 내의 모든 연결 요소 각각에 대해 음의 사이클이 있는지 확인해야한다.




이때 그래프의 모든 간선을 탐색하면서 

### [Solution 1] Bellman-Ford Algorithm

