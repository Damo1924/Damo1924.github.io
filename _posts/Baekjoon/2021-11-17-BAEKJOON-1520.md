---
title: "[백준] 1520. 내리막 길"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - PS
use_math: true
comments: true

---

3주(10.21 ~ 11.11) 동안의 훈련소를 마치고 돌아온 후 첫 포스팅이다.

다시 마음잡고 열심히 공부하자...

## [백준] 1520. 내리막 길

[백준 1520. 내리막 길 문제 링크](https://www.acmicpc.net/problem/1520)

**[PROBLEM]**

M x N 크기의 지도의 각 칸에는 해당 칸의 높이가 적혀있다.

가장 왼쪽 위 지점에서 출발하여 가장 오른쪽 아래 지점까지 항상 내리막길로만 이동하는 경로의 개수를 구하여라.

**[INPUT]**

첫째 줄에는 지도의 세로 길이 M과 가로 길이 N이 주어진다. (M, N은 500 이하의 자연수)

다음 M개의 줄에 걸쳐 지도가 주어지는데, 각 지점의 높이는 10000 이하의 자연수이다.

**[OUTPUT]**

첫째 줄에 이동 가능한 경로의 개수 H를 출력한다. 단, 모든 입력에 대해서 H는 10억 이하의 음이 아닌 정수이다.


<br/>

### [Solution 1] 높이가 가장 큰 지점부터 차례대로 구하는 DP

보통 길찾기 문제는 DFS 또는 BFS를 이용해서 해결하는 풀이를 떠올리기 마련인데 지도의 최대 크기가 꽤 작아서 굳이 그래프 탐색을 사용하지 않아도 시간 내에 AC를 받을 수 있을 것 같았다.

방법은 매우 간단하다.

지도의 모든 좌표 (1, 1) ~ (M, N)을 배열에 넣고 각 좌표에 해당하는 높이를 기준으로 내림차순으로 정렬한다.

다음과 같은 dp 배열을 만들어준다.

> `dp[i][j]` = (1, 1)에서 (i, j)까지 내리막길로만 이동하는 경로의 개수

그 후, 앞서 정렬한 순서대로 dp 배열을 채워나가면 된다.

해당 좌표의 상하좌우에 있는 좌표들 중 높이가 더 높은 좌표들의 dp 값을 더해준 값이 해당 좌표의 dp 배열의 값이 된다.

이 풀이의 시간복잡도는 정렬하는데 $O(n \log n)$, 각 좌표의 dp 배열을 채우는데 $O(n)$이므로 총 $O(n \log n)$이다.

이때 $n$은 최대 500 x 500 = 250000이므로 무리없이 통과할 수 있다고 예상할 수 있다.

전체 코드는 다음과 같다.

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
typedef pair<int, int> p;

int M, N, map[502][502], dp[502][502];

p order[250000];

int di[] = {0, 0, 1, -1}, dj[] = {1, -1, 0, 0};

bool compare(p A, p B)
{
    return map[A.first][A.second] > map[B.first][B.second];
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    cin >> M >> N;
    
    int idx = 0;
    for (int i = 1; i <= M; i++)
    {
        for (int j = 1; j <= N; j++)
        {
            cin >> map[i][j];
            order[idx++] = make_pair(i, j);
        }
    }
    
    sort(order, order + M * N, compare);
    
    int s;
    for (int k = 0; k < M * N; k++)
    {
        if (order[k].first == 1 && order[k].second == 1)
        {
            s = k + 1;
            break;
        }
    }
    
    dp[1][1] = 1;
    for (int k = s; k < M * N; k++)
    {
        int i = order[k].first, j = order[k].second;
        for (int l = 0; l < 4; l++)
        {
            if (map[i][j] == map[i + di[l]][j + dj[l]]) continue;
            dp[i][j] += dp[i + di[l]][j + dj[l]];
        }
    }
    
    cout << dp[M][N];
}
```
