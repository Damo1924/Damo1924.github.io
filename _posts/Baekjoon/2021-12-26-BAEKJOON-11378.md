---

title: "[백준] 열혈강호 4 ~ 6"

toc: true

toc_label: "On this page"

toc_icon: "chevron-right"

categories:

  - PS

use_math: true

comments: true

---

`Tags` Bipartite matching

[열혈강호 1 ~ 3](https://damo1924.github.io/ps/BAEKJOON-11375/)에 이어서 **열혈강호 4 ~ 6** 문제들을 풀어보았다.

이 문제들은 기본적으로 다음과 같은 틀을 가지고 있다.

> 강호네 회사에는 직원이 N명, 해야할 일이 M개가 있다.
> 
> 직원은 1번부터 N번까지, 해야할 일은 1번부터 M번까지 번호가 매겨져 있다.

## [백준] 11378. 열혈강호 4

[백준 11378. 열혈강호 4 문제 링크](https://www.acmicpc.net/problem/11378)

**[PROBLEM]**

**지난달에 벌점을 X점 받은 직원은 최대 (X + 1)개의 일을 할 수 있다.**

그런데 각 직원은 자신이 벌점을 얼마나 받은지 모르기 때문에 강호는 전체 벌점의 합 K를 적절히 분배하여 최대한 일을 많이 할 수 있게 하려고 한다.

전체 벌점의 합 K가 주어졌을 때, M개의 일 중에서 최대 몇 개를 할 수 있는지 구하여라.

**[INPUT]**

첫째 줄에 직원의 수 N과 일의 개수 M, 그리고 지날달에 직원들이 받은 벌점의 합 K가 주어진다. ($1 \leq N, M \leq 1000$, $1 \leq K \leq N$)

둘째 줄부터 N개의 줄의 i번째 줄에는 i번 직원이 할 수 있는 일의 개수와 할 수 있는 일의 번호가 주어진다.

**[OUTPUT]**

첫째 줄에 강호네 회사에서 할 수 있는 일의 개수를 출력한다.

---

### [Solution] Bipartite Matching

벌점의 총합이 K이고, 총 직원의 숫자가 N명이므로 할 수 있는 일의 개수의 최댓값은 (K + N)이다.

벌점을 받지 않은 직원도 최대 한 개의 일을 할 수 있기 때문에 먼저 모든 직원들에 대해 매칭을 시도한다.

그 다음, 벌점의 총 합 K만큼의 일을 더 시킬 수 있으므로 1번 직원부터 최대한 매칭을 시도한다.

그러다 만약 더 추가로 시킨 일이 K가 넘어가게 되면 중단하면 된다.

전체 코드는 다음과 같다.

```cpp
#include <iostream>
#include <vector>
using namespace std;

int N, M, K;

vector<int> graph[1001];

int match[1001];

bool visited[1001];

bool DFS(int cur)
{
    for (int i = 0; i < graph[cur].size(); i++)
    {
        int next = graph[cur][i];

        if (visited[next]) continue;
        visited[next] = 1;

        if (match[next] == 0 || DFS(match[next]))
        {
            match[next] = cur;
            return true;
        }
    }
    return false;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> N >> M >> K;

    int k, m;
    for (int i = 1; i <= N; i++)
    {
        cin >> k;
        while (k--)
        {
            cin >> m;
            graph[i].push_back(m);
        }
    }

    // 각 직원은 적어도 하나의 일은 할 수 있다.
    int res = 0;
    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= M; j++) visited[j] = 0;
        if (DFS(i)) res++;
    }

    // 남은 K개의 일을 매칭
    for (int i = 1; i <= N; i++)
    {
        while (K) // 각 직원에 최대한 많은 일을 매칭
        {
            for (int j = 1; j <= M; j++) visited[j] = 0;
            if (DFS(i))
            {
                res++;
                K--;
            }
            else break;
        }
    }
    cout << res;
}
```

그런데 위 풀이를 보면 다음과 같은 의문점이 생긴다.

> 왜 1번 직원부터 최대한 추가로 매칭한 것이 최대 매칭일까?
>
> 1번 직원에 매칭을 추가하지 않으면 그 뒤 직원들에 더 많은 일을 배정할 수 있는 경우가 있지 않을까?

만약 위 코드을 거쳐서 1번 직원에 추가로 배정한 할 일 x를 다른 직원에 배정해보자.

할 일 x를 다른 직원 i에 배정하면 두 가지 상황이 발생한다.

1. i가 x를 추가로 하는 경우
2. i가 기존에 배정된 일 y를 취소하고 x를 하는 경우

첫 번째 경우는 원래 구한 최대 매칭의 크기와 동일한데 더 이상 추가할 수 있는 매칭이 없으므로 최대 매칭을 늘릴 수 없다.

두 번째 경우는 계속 반복되다가 결국 1번 케이스로 끝나게 되므로 마찬가지로 최대 매칭의 크기는 그대로이다.

> **추가로 배정할 수 있는 K개의 일은 어떤 직원들에게 배정해도 같은 결과가 나오게 된다.**

단, 이 문제도 [지난 포스트](https://damo1924.github.io/ps/BAEKJOON-11375/#%ED%92%80%EC%9D%B4%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0)에서 다루었던 열혈강호 3 문제처럼 **각 직원이 적어도 하나의 일을 할 수 있다는 사실**을 간과해선 안된다.

단순히 (K + N)개의 일을 1번부터 배정하는 풀이는 최대 매칭의 크기를 구하지 못하는 반례가 존재한다.

<br/>

### [백준] 

