---

title: "[BOJ] 13334. 철로"

toc: true

toc_label: "On this page"

toc_icon: "chevron-right"

categories:

  - PS

use_math: true

comments: true

---

`Tags` Fenwick/Segment tree, Priority queue, Sweeping

## [BOJ] 13334. 철로

[BOJ 13334. 철로 문제 링크](https://www.acmicpc.net/problem/13334)

**[PROBLEM]**

집과 사무실 사이를 오가는 $n$명의 사람들이 있다.

각 사람의 집과 사무실은 수평선 위의 서로 다른 점에 위치하고 있으며, 임의의 두 사람의 집이나 사무실은 겹칠 수 있다.

사람들의 편의를 위해 철로를 건설하여 기차를 운행하려고 하는데, 예산으로 인해 최대 길이가 $d$로 제한된다.

이때 집과 사무실의 위치가 철로에 포함되는 사람의 수의 최댓값을 구하여라.

**[INPUT]**

첫 번째 줄에는 사람의 수 $n$($1 \leq n \leq 10^5$)가 주어진다.

다음 $n$개의 줄을 통해 각 사람의 집과 사무실의 위치가 두 정수 $h_i, o_i$ 로 주어진다.

이때 $h_i, o_i$는 절댓값이 $10^8$ 이하인 정수이다.

마지막 줄에는 철로의 최대 길이 $d$($1 \leq d \leq 2 \cdot 10^8$)가 주어진다.

**[OUTPUT]**

집과 사무실 위치가 모두 철로에 포함되는 사람의 수의 최댓값을 구하여라.

---

### [SOLUTION 1] Segment / Fenwick Tree

$h_i < o_i$ 로 위치를 저장한 후, 집의 위치에 따라 정렬하였다.

$h_i$에서 시작하는 철로를 건설하였을 때 집과 사무실이 모두 철로에 포함되는 사람의 수를 구할 수 있으면 된다.

이는 집의 위치 $h_j$가 $\[h_i, h_i + d)$에 포함되는 $j$에 대해 $o_j \leq h_i + d$ 를 만족하는 $j$의 개수이다.

나는 **집의 위치가 $\[h_i, h_i + d)$에 포함되는 사무실의 위치들을 펜윅 트리**에 저장하여 $h_i + d$ 보다 작거나 같은 위치의 개수를 구하였다.

단, 사무실의 위치가 절댓값이 $10^8$보다 작거나 같은 정수로 주어지기 때문에 **좌표 압축 기법**을 이용하였다.

각 $i$에 대하여 다음을 수행해준다.

- 펜윅 트리에 저장된 $o_j$ 중 $h_j < h_i$인 $o_j$를 제거
- 펜윅 트리에 저장되지 않은 $o_j$ 중 $h_j < h_i + d$ 인 $o_j$를 추가
- 펜윅 트리에 저장된 $o_j$ 중 $o_j \leq h_i + d$ 인 것의 개수를 구한다.

각 사무실의 위치가 세그먼트 트리에 한 번씩 삽입되고 삭제되고, 좌표 압축 기법을 이용하였으므로, 전체 시간복잡도는 $O(n \log^2 n)$ 이다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int _sum(vector<int>& tree, int x)
{
    int res = 0;
    while (x)
    {
        res += tree[x];
        x &= (x - 1);
    }
    return res;
}

void _upd(vector<int>& tree, int x, int diff)
{
    int n = tree.size();
    while (x < n)
    {
        tree[x] += diff;
        x += (x & (-x));
    }
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int n; cin >> n;
    vector<pair<int, int>> a(n);
    vector<int> v(n + 1, -1e9), b(n);
    for (int i = 0; i < n; i++)
    {
        int h, o; cin >> h >> o;
        if (h > o) swap(h, o);
        a[i] = { h, i };
        v[i] = b[i] = o;
    }
    int d; cin >> d;
    
    sort(a.begin(), a.end());
    
    sort(v.begin(), v.end()); // Coordinate compression
    v.erase(unique(v.begin(), v.end()), v.end());
    auto idx = [&](int val) { return upper_bound(v.begin(), v.end(), val) - v.begin() - 1; };
    
    vector<int> tree(v.size(), 0); // Fenwick tree
    int ans = 0;
    for (int i = 0, j = 0, k = 0; i < n; i++)
    {
        int s = a[i].first, e = s + d;
        while (a[j].first < s) _upd(tree, idx(b[a[j++].second]), -1);
        while (k < n && a[k].first < e) _upd(tree, idx(b[a[k++].second]), 1);
        
        int x = idx(e);
        if (x) ans = max(ans, _sum(tree, x));
    }
    cout << ans;
}
```

---

### [SOLUTION 2] Priority queue



