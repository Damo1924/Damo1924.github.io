---

title: "[백준] 열혈강호 1 ~ 3"

toc: true

toc_label: "On this page"

toc_icon: "chevron-right"

categories:

  - PS

use_math: true

comments: true

---

`Tags` Bipartite matching

백준에 있는 **열혈강호 1 ~ 3** 문제들을 풀어보았다.

이 문제들은 기본적으로 다음과 같은 틀을 가지고 있다.

> 강호네 회사에는 직원이 N명, 해야할 일이 M개가 있다.
> 
> 직원은 1번부터 N번까지, 해야할 일은 1번부터 M번까지 번호가 매겨져 있다.

## [백준] 11375. 열혈강호

[백준 11375. 열혈강호 문제 링크](https://www.acmicpc.net/problem/11375)

**[PROBLEM]**

**각 직원은 한 개의 일만 할 수 있고, 각각의 일을 담당하는 사람은 1명이어야 한다.**

각 직원이 할 수 있는 일의 목록이 주어질 때, M개의 일 중에서 최대 몇 개를 할 수 있는지 구하여라.

**[INPUT]**

첫째 줄에 직원의 수 N과 일의 개수 M이 주어진다. ($1 \leq N, M \leq 1000$)

둘째 줄부터 N개의 줄의 i번째 줄에는 i번 직원이 할 수 있는 일의 개수와 할 수 있는 일의 번호가 주어진다.

**[OUTPUT]**

첫째 줄에 강호네 회사에서 할 수 있는 일의 개수를 출력한다.

---

### [Solution] Bipartite Matching

각 직원이 하나의 일만 할 수 있고, 같은 일을 여러 사람이 할 수 없으므로 **이분 매칭** 문제임을 알 수 있다.

**DFS를 이용한 이분 매칭 알고리즘**은 $O(VE)$의 시간복잡도를 가지므로 N, M이 최대 1000까지 주어져도 시간 내에 통과할 수 있을 것이다.

이분 매칭 알고리즘에 대한 자세한 설명은 [이 포스트](https://damo1924.github.io/algorithm/BipartiteMatching/)에서 다루고 있다.

```cpp
#include <iostream>
#include <vector>
using namespace std;

int N, M;

vector<int> graph[1001]; // graph[i]: 직원 i가 할 수 있는 일의 번호들

int match[1001]; // match[i]: 일 i를 배정 받은 직원의 번호

bool visited[1001]; // visited[i]: 일 i를 탐색했으면 true, 아니면 false

bool DFS(int cur)
{
    for (int i = 0; i < graph[cur].size(); i++) // 직원 cur이 할 수 있는 일들
    {
        int next = graph[cur][i];
        
        if (visited[next]) continue; // 이미 next를 탐색했으면 continue
        visited[next] = 1;
        
        if (match[next] == 0 || DFS(match[next]))
        {
            match[next] = cur;
            return true;
        }
    }
    return false;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    cin >> N >> M;
    
    int k, m;
    for (int i = 1; i <= N; i++)
    {
        cin >> k;
        while (k--)
        {
            cin >> m;
            graph[i].push_back(m);
        }
    }
    
    int res = 0;
    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= M; j++) visited[j] = 0;
        if (DFS(i)) res++;
    }
    cout << res;
}
```

<br/>

## [백준] 11376. 열혈강호 2

[백준 11376. 열혈강호 2 문제 링크](https://www.acmicpc.net/problem/11376)

**[PROBLEM]**

나머지는 첫 번째 문제와 동일하고, 아래 조건만 달라진 문제이다.

**각 직원은 최대 두 개의 일을 할 수 있고, 각각의 일을 담당하는 사람은 1명이어야 한다.**

---

이번에는 직원 한 명이 두 개의 일도 할 수 있다.

크게 두 가지 방법으로 나눌 수 있을 것 같다.

1. 일을 직원에 매칭시키는 방법
2. 각 직원에 대해 두 번씩 매칭을 시도하는 방법

각 방법에 대해 간략히 설명하자면,

첫 번째 방법은 일을 직원에 매칭시키면서, **매칭시키려는 직원이 현재 맡고 있는 일의 개수에 따라 케이스를 나누는 것**이다.

일을 하나도 맡고 있지 않은 경우, 일을 하나 맡고 있는 경우, 그리고 일을 이미 두 개 맡고 있는 경우로 나누어서 적절한 코드를 작성해주면 된다.

두 번째 방법은 앞 문제를 풀었듯이 직원에 대해 일을 매칭시키는데, 각 직원이 두 개의 일을 할 수 있으므로 매칭을 한 번 더 시도하는 방법이다.

즉, 아래 반복문을 한 번 더 수행해주면 된다.

```cpp
for (int i = 1; i <= N; i++)
{
    for (int j = 1; j <= M; j++) visited[j] = 0;
    if (DFS(i)) res++;
}
```

아래는 첫 번째 방법을 선택하여 짠 코드이다.

---

### [Solution] Bipartite Matching

일을 직원에 매칭시킬 때 직원이 맡고 있는 일의 개수 K에 따라 경우를 나누자.

1. `K = 0`: 직원의 첫 번째 일로 배정한다.
2. `K = 1`: 직원의 두 번째 일로 배정한다.
3. `K = 2`: 다른 매칭을 바꾸어서 직원의 첫 번째 일로 배정하거나 직원의 두 번째 일로 배정한다.

각 직원이 맡고 있는 일을 저장해야하므로 다음과 같은 배열을 사용한다.

> `match[1001][2]`: 직원 i가 맡고 있는 일들

전체 코드는 다음과 같다.

```cpp
#include <iostream>
#include <vector>
using namespace std;

int N, M;

vector<int> graph[1001];

int match[1001][2];

int visited[1001];

bool DFS(int cur)
{
    for (int i = 0; i < graph[cur].size(); i++)
    {
        int next = graph[cur][i];
        
        if (visited[next] > 1) continue;
        visited[next]++;
        
        if (match[next][0] == 0) // 직원이 맡고 있는 일이 없는 경우
        {
            match[next][0] = cur;
            return true;
        }
        
        if (match[next][1] == 0) // 직원이 하나의 일을 맡고 있는 경우
        {
            match[next][1] = cur;
            return true;
        }
        
        if (DFS(match[next][0])) // 직원이 두 개의 일을 맡고 있는 경우
        {
            match[next][0] = cur;
            return true;
        }
        
        if (DFS(match[next][1]))
        {
            match[next][1] = cur;
            return true;
        }
    }
    return false;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    cin >> N >> M;
    
    int k, m;
    for (int i = 1; i <= N; i++)
    {
        cin >> k;
        while (k--)
        {
            cin >> m;
            graph[m].push_back(i);
        }
    }
    
    int res = 0;
    for (int i = 1; i <= M; i++)
    {
        for (int j = 1; j <= N; j++) visited[j] = 0;
        if (DFS(i)) res++;
    }
    cout << res;
}
```

<br/>

## [백준] 11377. 열혈강호 3

[백준 11377. 열혈강호 3 문제 링크](https://www.acmicpc.net/problem/11377)

**[PROBLEM]**

나머지는 첫 번째 문제와 동일하고, 아래 조건만 달라진 문제이다.

**N명 중에서 K명은 일을 최대 2개까지 할 수 있다.**

**[INPUT]**

첫째 줄에 직원의 수 N, 일의 개수 M, 일을 2개 할 수 있는 직원의 수 K가 주어진다.

($1 \leq N, M \leq 1000$, $1 \leq K \leq N$)

둘째 줄부터 N개의 줄의 i번째 줄에는 i번 직원이 할 수 있는 일의 개수와 할 수 있는 일의 번호가 주어진다.

---

N명 중 K명만 일을 2개까지 할 수 있다는 조건을 생각해보면, "열혈강호 2" 문제에서 소개한 두 번째 풀이를 이용하면 쉽게 해결할 수 있다는 것을 알 수 있다.

> **직원 한 명 당 하나의 일을 할 수 있다는 조건을 유지하면서 동일한 직원이 하나 더 있다고 가정한다.**















