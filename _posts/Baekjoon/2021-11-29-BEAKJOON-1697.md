---

title: "[백준] 숨바꼭질 1 ~ 4"

toc: true

toc_label: "On this page"

toc_icon: "chevron-right"

categories:

  - PS

use_math: true

comments: true

---

백준에 있는 숨바꼭질 문제 시리즈(1~4)를 전부 풀어보았다. (영어로는 Catch That Cow)

## [백준] 1697. 숨바꼭질

[백준 1655. 가운데를 말해요 문제 링크](https://www.acmicpc.net/problem/1697)

**[PROBLEM]**

수빈이는 동생과 숨바꼭질을 하고 있다.

수빈이는 현재 N에 있고, 동생은 K에 있다.

수빈이는 걷거나 순간이동을 할 수 있는데, 수빈이의 위치가 X일 때 1초 후에 X-1, X+1, 2X 위치로 이동할 수 있다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하여라.

**[INPUT]**

첫째 줄에 수빈이의 초기 위치 N과 동생의 위치 K가 주어진다. ($0 \leq N, K \leq 100000$)

**[OUTPUT]**

수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 출력한다.

<br/>

---

### [Solution 1] BFS

이 문제는 BFS를 통해 해결할 수 있다.

큐에서 뽑은 수빈이의 위치 X에 대해서, 1초 후에 X+1, X-1, 2X 위치로 움직일 수 있다.

위의 세 가지 새로운 위치를 큐에 삽입하고, 다시 큐에서 새로운 위치를 뽑는 과정을 반복함으로써 BFS로 수빈이가 이동할 수 있는 위치들을 구할 수 있다.

걷는 것과 순간이동 모두 1초가 소요되기 때문에 **이미 방문한 위치는 큐에 삽입할 필요가 없다.**

방문한 위치를 저장하기 위해 다음과 같은 배열을 정의하였다.

> `dp[i]` = 수빈이의 초기 위치 N으로부터 위치 i까지 이동하는데 걸리는 최소 시간 + 1

이때 `+1`을 해준 이유는 방문하지 않은 위치를 배열의 초기값인 0으로 하기 위해서이다. (물론 배열을 매우 큰 값이나 -1과 같은 값으로 초기화시켜도 된다.)

전체 코드는 다음과 같다.

```cpp
#include <iostream>
#include <queue>
using namespace std;
const int MAX = 100000;

int dp[MAX + 1];

int main()
{
    int N, K;
    cin >> N >> K;
    
    queue<int> q;
    q.push(N);
    dp[N] = 1;
    while (!q.empty())
    {
        int x = q.front();
        q.pop();
        
        int y[3] = {2 * x, x + 1, x - 1}; // 위치 x에서 1초 후에 이동할 수 있는 위치들
        for (int i = 0; i < 3; i++)
        {
            if (y[i] < 0 || y[i] > MAX) continue;
            if (dp[y[i]] == 0) // 아직 방문하지 않은 위치에 대해서만 큐에 삽입
            {
                dp[y[i]] = dp[x] + 1;
                q.push(y[i]);
            }
        }
        
        if (dp[K] != 0) break;
    }
    
    cout << dp[K] - 1 << "\n";
}
```

---

### [Solution 2] Greedy algorithm

앞선 BFS를 이용한 풀이가 정석이지만, 그리디한 방법으로 조금 더 빠르게 해결할 수 있는 방법도 존재한다.

그러기 위해 이번에는 동생의 위치로부터 수빈이의 위치를 역추적하는 방향으로 접근해보았다.

동생의 현재 위치를 X라고 했을 때, X가 홀수이면 순간이동이 불가능하므로 X+1 또는 X-1로 움직여야한다.

반대로 X가 짝수이면 순간이동이 가능하므로 X/2 로 이동하는 선택지도 생긴다.

이 방법의 핵심은 바로 **X가 짝수이면 순간이동을 한다**라는 것이다. (반드시 순간이동을 하는 것은 아니다.)

---

짝수 X에 대해 X = 2M 라고 해보자.

이 상황에서 동생이 택할 수 있는 선택지는 순간이동으로 M 위치에 가거나 걸어서 2M - 1 또는 2M + 1 로 가는 방법이 있다.

이때 2M - 1과 2M + 1은 홀수이기 때문에 반드시 다음 1초에는 걸어서 짝수 번호 위치인 2M - 2, 2M, 2M + 2 중 하나로 움직이게 된다.

2초에 걸쳐 도착한 2M - 2, 2M, 2M + 2에서 순간이동을 택하면 M - 1, M, M + 1에 도달할 수 있고, 세 위치까지 걸린 시간은 3초가 된다.

그러나 애초부터 순간이동을 선택했다면 M - 1, M + 1에는 2초만에 도착할 수 있었다.

이로부터 얻을 수 있는 결론은 다음과 같다.

> 동생의 현재 위치가 짝수일 때, 다음과 같은 선택지가 있다.
> 
> 1. 아예 순간이동을 하지 않고 쭉 걸어간다.
> 2. 그게 아니라면 지금 순간이동을 한다.

---

위의 증명으로부터 다음과 같은 재귀함수를 통해 수빈이가 동생을 찾는 최소 시간을 구할 수 있게 된다.

```cpp
#include <iostream>
using namespace std;

int min (int a, int b) { return (a < b) ? a : b; }

int find (int n, int k)
{
    if (n >= k) return n - k; // 수빈이의 위치에 해당하는 숫자가 더 크다면, 수빈이는 반드시 매번 -1 방향으로 걸어야한다.
    else if (k == 1) return 1; // 위 조건문에서 처리되지 않은 케이스인 N = 0, K = 1를 처리해준다.
    else if (k % 2) return 1 + min(find(n, k+1), find(n, k-1)); // 동생의 현재 위치 k가 홀수인 경우에는 +1 또는 -1 중 작은 것을 선택한다.
    else return min(k - n, 1 + find(n, k/2)); // 동생의 현재 위치 k가 짝수인 경우에는 아예 순간이동을 하지 않고 걷거나, 그게 아니라면 순간이동을 한다.
}

int main()
{
    int N, K;
    cin >> N >> K;
    cout << find(N, K);
}
```

C++는 너무 빨라서 두 방법 모두 0ms AC가 나오지만, Python으로 해본 결과, 유의미한 차이를 관찰할 수 있었다. (BFS - 288ms, Greedy - 56ms)

---

## [백준] 12851. 숨바꼭질 2

[백준 12851. 숨바꼭질 2 문제 링크](https://www.acmicpc.net/problem/12851)

**[PROBLEM]**

1697 숨바꼭질 문제에서 수빈이가 동생을 찾을 수 있는 최소 시간에 더해, 최소 시간으로 찾는 방법의 수를 구하는 문제이다.

**[INPUT]**

첫째 줄에 수빈이의 초기 위치 N과 동생의 위치 K가 주어진다. ($0 \leq N, K \leq 100000$)

**[OUTPUT]**

첫째 줄에 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 출력한다.

둘째 줄에는 가장 빠른 시간으로 수빈이가 동생을 찾는 방법의 수를 출력한다.

<br/>

---

### [Solution] BFS

수빈이가 최소 시간으로 동생을 찾는 방법의 수를 모두 구해야 하기 때문에 BFS를 사용해서 모든 경우의 수를 탐색해주어야 한다.

[1697. 숨바꼭질] 문제의 풀이에 더해 방법의 수를 구하기 위한 새로운 배열을 정의하였다.

> `cnt[i]` = 수빈이의 초기 위치 N으로부터 위치 i까지 최소 시간으로 이동하는 방법의 수

다음은 전체 코드이다.

```cpp
#include <iostream>
#include <queue>
using namespace std;
const int MAX = 100000;

int dp[MAX + 1], cnt[MAX + 1];

int main()
{
    int N, K;
    cin >> N >> K;
    
    queue<int> q;
    q.push(N);
    dp[N] = 1;
    cnt[N] = 1;
    while (!q.empty())
    {
        int x = q.front();
        q.pop();
        
        if (x == K) // 큐에서 K를 뽑는 순간 반복문을 종료하고 답을 출력해야한다.
        {
            cout << dp[K] - 1 << "\n" << cnt[K];
            break;
        }
        
        int y[3] = {2 * x, x + 1, x - 1}; // 수빈이가 이동할 수 있는 위치들
        for (int i = 0; i < 3; i++)
        {
            if (y[i] < 0 || y[i] > MAX) continue;
            if (dp[y[i]] == dp[x] + 1) cnt[y[i]] += cnt[x]; // 도달하는데 걸리는 시간이 최소 시간으로 동일하다면 경우의 수에 더해준다.
            else if (dp[y[i]] == 0) // 방문하지 않은 경우는 최소 시간을 갱신해주고, 경우의 수를 더하고, 큐에 새로운 위치를 삽입해준다.
            {
                dp[y[i]] = dp[x] + 1;
                cnt[y[i]] += cnt[x];
                q.push(y[i]);
            }
        }
    }
}
```

이 문제는 단순히 최소 시간만을 구하는 것이 아니기 때문에 `dp[K]`의 값이 0이 아니게 되는 순간에 반복문을 종료하는 것이 아니라 큐에서 동생의 위치 K를 뽑았을 때 반복문을 종료하게 된다.

또한 경우의 수를 저장하는 `cnt` 배열의 값을 갱신하는 경우는 `dp[y[i]]`의 값이 0 (= 방문한 적 없음) 이거나 `dp[x] + 1` (= 최소 시간에 도달하는 다른 방법) 인 경우이다.

---

## [백준] 13913. 숨바꼭질 4

[백준 13913. 숨바꼭질 4 문제 링크](https://www.acmicpc.net/problem/13913)

**[PROBLEM]**

1697 숨바꼭질 문제에서 수빈이가 동생을 찾을 수 있는 최소 시간에 더해, 수빈이가 어떻게 이동해야 하는지 그 경로까지 출력하는 문제이다.

**[INPUT]**

첫째 줄에 수빈이의 초기 위치 N과 동생의 위치 K가 주어진다. ($0 \leq N, K \leq 100000$)

**[OUTPUT]**

첫째 줄에 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 출력한다.

둘째 줄에는 수빈이가 어떻게 이동해야 하는지 공백으로 위치를 구분해 출력한다. (방법이 여러 가지라면 아무거나 하나만 출력한다.)

<br/>

---

### [Solution] BFS

아주 대표적인 [최단거리 역추적](https://www.acmicpc.net/step/41) 문제이다. (비슷한 문제를 더 풀고 싶다면 링크 참조)

최단 거리, 최소 시간 등에 해당하는 경로를 구하는 방법은 **현재 위치의 바로 이전 위치를 기록**해두는 것이다.

> `pre[i]` = N부터 i까지 최소 시간에 도달하는 어떤 경로에서 i 바로 이전에 오는 위치를 저장

이렇게 최소 시간과 함께 이전 위치를 갱신하면서 BFS로 탐색을 마친 다음, 목표 지점이었던 K부터 N까지 역으로 추척함으로써 원하는 경로를 얻을 수 있게 된다.

K 이전에 오는 위치는 `pre[K]`, 그 전에 오는 위치는 `pre[pre[K]]`가 되는 것이다.

전체 코드는 다음과 같다.

```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;
const int MAX = 100000;

int dp[MAX + 1], pre[MAX + 1];

int main()
{
    int N, K;
    cin >> N >> K;
    
    queue<int> q;
    q.push(N);
    dp[N] = 1;
    while (!q.empty())
    {
        int x = q.front();
        q.pop();
        
        int y[3] = {2 * x, x + 1, x - 1};
        for (int i = 0; i < 3; i++)
        {
            if (y[i] < 0 || y[i] > MAX) continue;
            if (dp[y[i]] == 0)
            {
                dp[y[i]] = dp[x] + 1;
                pre[y[i]] = x; // y[i]의 이전 위치인 x를 저장 (x -> y[i])
                q.push(y[i]);
            }
        }
        
        if (dp[K] != 0) break;
    }
    
    cout << dp[K] - 1 << "\n";
    
    vector<int> path = {K}; // 경로를 역순으로 저장할 벡터
    path.reserve(MAX);
    while (K != N) // K가 N이 될 때까지 K를 이전 위치로 갱신하며 벡터에 추가해준다.
    {
        K = pre[K];
        path.push_back(K);
    }
    for (int i = path.size() - 1; i >= 0; i--) cout << path[i] << " "; // 벡터를 마지막 원소부터 출력하면 경로를 얻게 된다.
}
```

---

## [백준] 13549. 숨바꼭질 3

[백준 13549. 숨바꼭질 3 문제 링크](https://www.acmicpc.net/problem/13549)

**[PROBLEM]**

수빈이는 걷는데 1초가 걸리지만, 순간이동을 하는 경우에는 0초가 소요된다.

이때 수빈이가 동생을 찾을 수 있는 가장 빠른 시간을 구하여라.

**[INPUT]**

첫째 줄에 수빈이의 초기 위치 N과 동생의 위치 K가 주어진다. ($0 \leq N, K \leq 100000$)

**[OUTPUT]**

첫째 줄에 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 출력한다.

<br/>

---

### [Solution] BFS
