---
title: "[CodeJam 2022] Round 2"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Coding Contest
use_math: true
comments: true

---

`Tags` Perfect matching, Hopcroft-Karp, DP

## Review & Review

시작하고 1시간 동안 1, 2번을 잡고 있었지만, 도무지 방법이 생각나지 않았다.

부분점수라도 긁어볼까 생각도 했지만 이미 반포기 상태였고, 제출조차 하지 않고 대회를 마무리했다.

지금 포스팅을 하는 시점에서 1000등 컷이 25점인 것을 감안하면, 어려웠던 건 맞는 것 같다.

기대를 하지 않는다고 말했지만, 나름 희망을 품었기에 더 빠르게 놓아버린 것 같아 아쉽다.

코드포스도 그렇고 점수와 성과에 연연하다보니 조급해지고 생각대로 잘 풀리지 않으면 빠르게 포기해버리는 것 같다.

이번 코드잼이 변환점이 될 수 있을지..는 잘 모르겠다.

무엇이라도 성과를 내야할 것 같다는 압박감이 있다.

조금 허망하다.

<br/>

## 1. Spiraling Into Control

[CodeJam 2022 Round 2 1. Spiraling Into Control 문제 링크](https://codingcompetitions.withgoogle.com/codejam/round/00000000008778ec/0000000000b15a74#problem)

**[PROBLEM]**

홀수 $N$에 대하여, $N \times N$ 크기의 집은 $1 \times 1$ 크기의 방들로 나누어져 있다.

총 $N^2$개의 방은 $1$부터 $N^2$까지 번호를 가지는데, 가장 왼쪽 위 방부터 시작해서 시계방향으로 돌면서 번호를 부여하였다.

$N$은 홀수이기 때문에 정가운데 있는 방은 항상 $N^2$의 번호를 가진다.

단테는 $1$번 방에서 출발하여 $N^2$번 방까지 이동해야한다.

단테는 현재 위치한 방보다 큰 번호를 가진 인접한 방으로 이동할 수 있는데, 이때 번호의 차이가 $1$보다 큰 경로를 지름길이라고 한다.

즉, 지름길이란 번호가 연속적이지 않은 인접한 방으로의 이동을 의미한다.

어떤 정수 $K$에 대하여, 단테가 정확히 $K$번 이동하여 $N^2$번 방에 도달할 수 있는 방법을 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $T$($1 \leq T \leq 100$)가 주어진다.

각 테스트케이스는 두 정수 $N, K$ ($3 \leq N \leq 9999$, $1 \leq K < N^2 - 1$)로 이루어져 있다.

**[OUTPUT]**

각 테스트케이스마다 $1$번 방에서 출발하여 정확히 $K$번 이동해서 $N^2$번 방에 도착하는 방법이 있다면 첫 번째 줄에 지름길의 개수 $S$를 출력하고,

다음 $S$개의 줄에 걸쳐 각 지름길이 연결하는 두 방의 번호를 공백으로 구분하여 출력한다.

만약 방법이 존재하지 않는다면 IMPOSSIBLE 을 출력한다.

---

### [SOLUTION] Math

주어진 $N, K$에 대하여 지름길로 $S$번 이동했을 때, $i$번째 지름길의 방 번호 차이를 $D_i$라고 하면 다음이 성립한다.

\begin{aligned}
(K - S) + \sum_{i=1}^S D_i = N^2 - 1
\end{aligned}

위 식에서 $-S$ 를 시그마 항 안으로 넣어 식을 정리해주면,

\begin{aligned}
\sum_{i=1}^S (D_i - 1) = N^2 - 1 - K
\end{aligned}

를 얻을 수 있다.

전체 방들은 $\frac{N+1}{2}$ 개의 고리로 나눌 수 있는데, 가장 안쪽 고리를 $1$번, 가장 바깥쪽 고리를 $\frac{N+1}{2}$번 고리라고 하자.

각 고리마다 지름길을 한 번씩만 선택할 수 있으며, $r$번 고리의 각 지름길의 방 번호 차이는

\begin{aligned}
8r - 1, 8r - 3, 8r - 5, 8r - 7
\end{aligned}

이다.

이는 고리의 윗쪽에서 지름길을 타면 현재 방의 번호에 $8r - 1$ 을 더한 방으로 이동한다는 것을 의미한다.

마찬가지로 고리의 오른쪽에서는 $8r-3$만큼 방 번호가 증가하고, 아래쪽에서는 $8r-5$, 왼쪽에서는 $8r-7$만큼 증가한다.

즉, 지름길을 선택하면 방 번호가 홀수만큼 증가하므로 $D_i$는 홀수이고, 앞서 구한 식으로부터 $K$가 홀수이면 경로가 존재하지 않는다는 것을 알 수 있다.

또, $1$번 방으로부터 $N^2$번 방까지의 최소 이동 횟수는 $N-1$번이므로 $K < N-1$ 인 경우에도 경로가 존재하지 않는다.

위 두 가지 경우를 제외한다면, 적절한 지름길을 통해 목적지까지 도달할 수 있다.

남은 이동 거리 $D$를 $D = N^2 - 1 - K$ 로 정의하면, $r = \frac{N+1}{2}$ 부터 아래 과정을 반복함으로써 지름길을 타는 위치를 구할 수 있다.

- $D \geq 8r - 2$ 이면 $r$번째 고리의 위쪽에서 지름길을 탄다.
- $D = 8r - 4$ 또는 $D = 8r - 6$ 또는 $D = 8r - 8$ 이면 각각 고리의 오른쪽, 아래쪽, 왼쪽에서 지름길을 탄다.
- 지름길을 탄 후 $D$에서 지름길을 탄 위치에 따라 $8r - 2$, $8r - 4$, $8r - 6$, $8r- 8$ 를 빼준다.
- 만약 $D = 0$ 이 되면 더 이상 지름길을 타지 않는다.

이후 $r$번 고리의 가장 왼쪽 위 방의 번호가 $N^2 - 4r(r+1)$ 임을 이용하여 지름길에 해당하는 두 방의 번호를 찾아주면 된다.

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int T; cin >> T;
    for (int t = 1; t <= T; t++)
    {
        int N, K; cin >> N >> K;
        if (K < N - 1 || K % 2)
        {
            cout << "Case #" << t << ": IMPOSSIBLE\n";
            continue;
        }
        
        vector<pair<int, int>> sc;
        int D = N * N - 1 - K;
        for (int r = N / 2; r; r--)
        {
            int x = N * N - 4 * r * (r + 1);
            int y = x + 8 * r;
            int d = 8 * r - 2;
            for (int i = 0; i <= 6; i += 2)
            {
                if (D >= d - i)
                {
                    sc.push_back({ x + i * r + 1, y + i * (r - 1) });
                    D -= d - i;
                    break;
                }
            }
            if (D == 0) break;
        }
        
        cout << "Case #" << t << ": " << sc.size() << "\n";
        for (auto [x, y] : sc) cout << x << " " << y << "\n";
    }
}
```

<br/>

## 2. Pixelated Circle

[CodeJam 2022 Round 2 2. Pixelated Circle 문제 링크](https://codingcompetitions.withgoogle.com/codejam/round/00000000008778ec/0000000000b158f7)

**[PROBLEM]**

반지름이 $R$인 원을 그리는 아래의 두 함수의 결과의 차이를 구하여라.

`set_pixel_to_black(x, y)` 는 $(x, y)$ 픽셀을 검정색으로 칠하는 함수이다.

첫 번째 함수는 아래와 같다.

```cpp
void draw_circle_perimeter(int R)
{
    for (int x = -R; x <= R; x++)
    {
        int y = round(sqrt(R * R - x * x));
        set_pixel_to_black(x, y);
        set_pixel_to_black(x, -y);
        set_pixel_to_black(y, x);
        set_pixel_to_black(-y, x);
    }
}

void draw_circle_wrong(int R)
{
    for (int r = 0; r <= R; r++)
        draw_circle_perimeter(r);
}
```

두 번째 함수는 아래와 같다.

```cpp
void draw_circle_filled(int R)
{
    for (int x = -R; x <= R; x++)
        for (int y = -R; y <= R; y++)
            if (round(sqrt(x * x + y * y)) <= R)
                set_pixel_to_black(x, y);
}
```

단, 검정색으로 칠한 칸을 다시 칠해도 그대로 검정색이다.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $T$($1 \leq T \leq 100$)가 주어진다.

각 테스트케이스는 정수 $R$ ($3 \leq R \leq 10^5$)로 이루어져 있다.

**[OUTPUT]**

각 테스트케이스마다 두 함수의 결과에서 서로 색깔이 다른 픽셀의 개수를 출력한다.

---

### [SOLUTION] Math

함수 `draw_circle_filled(R)`에서 칠해진 픽셀들의 집합을 $C_f$, 함수 `draw_circle_wrong(R)`에서 칠해진 픽셀들의 집합을 $C_w$라고 하자.

<center><img src="https://user-images.githubusercontent.com/88201512/168528422-3c3d1b3f-dc14-437f-9587-6c6856e2c8ca.jpg" width="70%" height="70%"></center>

위 증명에 의해 $C_w \subseteq C_f$ 이며, 따라서 두 함수의 결과에서 색깔이 다른 부분의 개수는 $\left\vert C_f \right\vert - \left\vert C_w \right\vert$ 로 구할 수 있다.

먼저 $\left\vert C_f \right\vert$ 을 구하자.

<center><img src="https://user-images.githubusercontent.com/88201512/168528464-01afaa83-2432-4e36-b153-ec2fafac9088.jpg" width="60%" height="60%"></center>

이제 $\left\vert C_w \right\vert$ 을 구하자.

<center><img src="https://user-images.githubusercontent.com/88201512/168528485-9a800ddf-510f-4c5a-9bba-65e585a3401e.jpg" width="60%" height="60%"></center>

따라서 각 $r$에 대하여 `draw_circle_perimeter(R)`가 칠하는 픽셀의 수를 구한 후, 모두 더해주면 된다.

<center><img src="https://user-images.githubusercontent.com/88201512/168530742-52339bdb-2495-4b0c-8741-3f919f74d49b.jpg" width="70%" height="70%"></center>

각 집합의 크기를 구하는 시간복잡도는 $O(R)$ 이다.

```cpp
#include <iostream>
#include <cmath>
using namespace std;
typedef long long ll;

int Q[100001];

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    for (ll r = 1; r <= 100000; r++)
    {
        ll x1 = floor(r / sqrt(2.0)), x2 = x1 + 1;
        ll y1 = round(sqrt(r * r - x1 * x1)), y2 = round(sqrt(r * r - x2 * x2));
        if (x1 < y2) x1 = y2, y1 = x2;
        
        Q[r] = 2 * x1 - ((x1 == y1) ? 1 : 0);
    }

    int T; cin >> T;
    for (int t = 1; t <= T; t++)
    {
        ll R; cin >> R;
        ll Cf = 0, Cw = 1;
        for (ll x = -R; x <= R; x++)
            Cf += floor(sqrt((R + 0.5) * (R + 0.5) - x * x)) * 2 + 1;
        for (int r = 1; r <= R; r++) Cw += 4 * Q[r] + 4;
        cout << "Case #" << t << ": " << Cf - Cw << "\n";
    }
}
```

<br/>

## 3. Saving the Jelly

[CodeJam 2022 Round 2 3. Saving the Jelly 문제 링크](https://codingcompetitions.withgoogle.com/codejam/round/00000000008778ec/0000000000b158f8#problem)

**[PROBLEM]**

축구장에 $1$부터 $N$까지의 번호가 매겨진 $N$명의 아이들이 있다.

축구장에는 $1$부터 $N+1$까지의 번호가 매겨진 $N+1$개의 사탕이 놓여져 있고, 아이들은 선생님이 부르는 순서에 따라서 자신으로부터 가장 가까운 곳에 있는 사탕을 가진다.

만약 가장 가까운 거리에 있는 사탕이 여러 개라면 선생님이 말하는 사탕을 가져가야한다.

아이들이 $1$번 사탕을 가져가지 못하게 하려면 어떤 순서로 아이들을 불러야하는지 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $T$($1 \leq T \leq 100$)가 주어진다.

각 테스트케이스의 첫 번째 줄에는 정수 $N$ ($3 \leq N \leq 1000$)이 주어진다.

다음 $N$개의 줄에 걸쳐 각 아이들의 위치가 두 정수 $X_i, Y_i$ ($-10^9 \leq X_i, Y_i \leq 10^9$)로 주어진다.

다음 $N+1$개의 줄에 걸쳐 각 사탕의 위치가 두 정수 $X_j, Y_j$ ($-10^9 \leq X_j, Y_j \leq 10^9$)로 주어진다.

**[OUTPUT]**

각 테스트케이스마다 아이들이 $1$번 사탕을 가져가지 못하도록 하는 방법이 있으면 POSSIBLE 을, 없으면 IMPOSSIBLE 을 출력한다.

방법이 존재하는 경우에는 $N$개의 줄에 걸쳐 두 정수 $A_i, B_i$ 를 출력한다.

$A_i$ 는 $i$번째로 호출되는 아이의 번호이고, $B_i$는 $A_i$번 아이가 가져갈 사탕의 번호이다.

$B_i$번 사탕은 남은 사탕 중 $A_i$번 아이에 가장 가까운 사탕이어야한다. (또는 그러한 사탕들 중 하나여야한다.)

---

### [SOLUTION] Bipartite Matching (Hopcroft-Karp algorithm)

$N$명의 아이들과 $1$번 사탕을 제외한 $N$개의 사탕들을 정점으로 하는 이분그래프를 생각하자.

$i$번 아이는 $1$번 사탕까지의 거리보다 작거나 같은 곳에 위치한 사탕들과 연결된다.

만약 위 이분그래프의 perfect matching이 존재하지 않는다면, 어떤 순서로 아이들을 호출해도 항상 $1$번 사탕을 가져가게 되는 아이가 있다는 것을 의미한다.

그렇다면 perfect matching이 존재하는 경우를 생각해보자.

처음에는 각 아이에 대하여 매칭된 사탕보다 가까운 사탕들을 미리 가져가도록 하면 된다고 생각했다.

그래서 적절한 그래프를 구현한 후 위상정렬을 하여 얻은 순서대로 아이들을 호출했지만, 무한루프가 발생하는 경우가 있다는 것을 확인할 수 있었다.

즉 사이클이 존재할 수 있다는 의미였고, 이는

**단순히 모든 아이들이 $1$번 사탕을 제외한 사탕과 매칭된다고 해서 아이들이 매칭된 사탕을 가져갈 수 있는 방법이 존재하는 것이 아님**

을 뜻했다.

하지만 신기하게도 임의의 perfect matching은 다음과 같은 방법을 통해 아이들이 매칭된 사탕을 가져갈 수 있는 perfect mathcing으로 변형될 수 있다.

1. 자신으로부터 가장 가까운 사탕과 매칭된 아이를 **모두** 호출한다.
2. 이제 남은 아이들은 모두 자신으로부터 가장 가까운 사탕과 매칭되어 있지 않고, 사이클을 찾을 수 있다.
3. 임의의 아이 $i$에 대하여 남은 사탕 중 가장 가까운 $j$를 구하고, 사이클을 찾을 때까지 $i$를 $j$에 매칭된 아이로 업데이트하며 이 과정을 반복한다.
4. 위 과정을 통해 매칭에 속하지 않는 간선과 매칭에 속하는 간선이 번갈아 등장하는 길이가 짝수인 사이클을 얻을 수 있고, 매칭에 속하지 않았던 간선들은 매칭에 추가하고 매칭에 속했던 간선들은 매칭에서 제거하는 작업을 통해 새로운 perfect matching을 만들 수 있다.
5. 해당 사이클 위에 존재하는 아이들은 모두 자신으로부터 가장 가까운 사탕과 매칭되었기 때문에 적어도 한 명의 아이는 매칭된 사탕을 가져갈 수 있게 된다.
6. 모든 아이를 호출할 때까지 1~5를 반복한다.

이분그래프의 최대 매칭은 [Hopcroft-Karp algorithm](https://damo1924.github.io/algorithm/HopcroftKarpAlgorithm/)을 통해 $O(N^2 \sqrt{N})$ 에 구할 수 있다.

임의의 아이에 대해 남은 사탕 중 아이로부터 가장 가까운 사탕을 매번 구한다면, perfect matching을 변형하는 과정은 $O(N^3)$ 이 소요된다.

가장 가까운 사탕을 매번 구하는 대신, 그래프를 구현할 때 거리에 따른 내림차순으로 사탕들을 정렬해주면 $O(N^2)$ 으로 처리할 수 있다.

호출된 아이들과 아이들이 가져간 사탕을 기억해두고 그래프에 저장된 가장 가까운 사탕이 이미 가져간 사탕이라면 그래프에서 해당 사탕을 제거해주면 된다.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
using namespace std;
typedef long long ll;
#define x first
#define y second

pair<ll, ll> student[1001], candy[1001];
vector<int> g[1001];
int lev[1001], a[1001], b[1001];

ll dist(int i, int j)
{
    ll res = (student[i].x - candy[j].x) * (student[i].x - candy[j].x);
    res += (student[i].y - candy[j].y) * (student[i].y - candy[j].y);
    return res;
}

void bfs(int n)
{
    queue<int> q;
    for (int i = 1; i <= n; i++)
    {
        if (!a[i])
        {
            lev[i] = 0;
            q.push(i);
        }
        else lev[i] = -1;
    }
    
    while (!q.empty())
    {
        int x = q.front();
        q.pop();
        for (int y : g[x])
        {
            if (b[y] && lev[b[y]] == -1)
            {
                lev[b[y]] = lev[x] + 1;
                q.push(b[y]);
            }
        }
    }
}

bool dfs(int x)
{
    for (int y : g[x])
    {
        if (!b[y] || (lev[b[y]] == lev[x] + 1 && dfs(b[y])))
        {
            a[x] = y, b[y] = x;
            return true;
        }
    }
    return false;
}

bool hopcroft_karp(int n)
{
    int mm = 0;
    while (true)
    {
        bfs(n);
        int match = 0;
        for (int i = 1; i <= n; i++) if (!a[i] && dfs(i)) match++;
        if (!match) break;
        mm += match;
    }
    return mm == n;
}

vector<int> order;
bool vis1[1001], vis2[1001];
void solve(int n)
{
    while (true)
    {
        bool flg = 0;
        for (int i = 1; i <= n; i++)
        {
            if (vis1[i]) continue;
            while (vis2[g[i].back()]) g[i].pop_back(); // 이미 가져간 사탕이면 제거
            if (a[i] == g[i].back()) // 가장 가까운 사탕과 매칭되었으면 호출
            {
                order.push_back(i);
                vis1[i] = vis2[a[i]] = 1;
                flg = 1;
            }
        }
        if (flg) continue; // 새로 호출한 아이들이 있으면 다시 탐색
        
        // 남은 아이들이 가장 가까운 사탕과 매칭이 안된 상태
        int i = 1;
        while (i <= n && vis1[i]) i++;
        if (i > n) break;
        
        vector<bool> chk(n + 1, 0);
        vector<int> path;
        while (!chk[i]) // 방문했던 정점에 다시 도달할 때까지 반복, i가 사이클의 시작점이 된다.
        {
            int j = g[i].back();
            chk[i] = 1;
            path.push_back(i);
            i = b[j];
        }
        while (true)
        {
            int k = path.back(), j = g[k].back();
            path.pop_back();
            a[k] = j, b[j] = k; // 사이클 위에 있는 아이들을 가장 가까운 사탕과 매칭
            if (k == i) break;
        }
    }
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int T; cin >> T;
    for (int t = 1; t <= T; t++)
    {
        int N; cin >> N;
        for (int i = 1; i <= N; i++)
        {
            g[i].clear();
            lev[i] = a[i] = b[i] = 0;
            vis1[i] = vis2[i] = 0;
        }
        order.clear();
        
        for (int i = 1; i <= N; i++) cin >> student[i].x >> student[i].y;
        for (int i = 0; i <= N; i++) cin >> candy[i].x >> candy[i].y;
        
        for (int i = 1; i <= N; i++)
        {
            ll d = dist(i, 0);
            for (int j = 1; j <= N; j++)
                if (dist(i, j) <= d) g[i].push_back(j);
            sort(g[i].begin(), g[i].end(), [&](int a, int b) { return dist(i, a) > dist(i, b); }); // 거리에 대한 내림차순으로 저장
        }
        
        if (hopcroft_karp(N))
        {
            cout << "Case #" << t << ": POSSIBLE\n";
            solve(N);
            for (int i : order) cout << i << " " << a[i] + 1 << "\n";
        }
        else cout << "Case #" << t << ": IMPOSSIBLE\n";
    }
}
```

<br/>

## 4. I, O Bot

[CodeJam 2022 Round 2 4. I, O Bot 문제 링크](https://codingcompetitions.withgoogle.com/codejam/round/00000000008778ec/0000000000b15167#problem)

**[PROBLEM]**

무한히 긴 수평선 위에 숫자 1 또는 0 모양의 공들이 놓여져있다.

각 공의 위치는 절댓값이 $10^9$ 이하인 정수로 표현할 수 있으며, 같은 위치에는 최대 하나의 공만 있을 수 있다.

이 공들을 $x = 0$ 에 위치한 창고로 옮기기 위해 1 모양의 공 하나와 0 모양의 공 하나를 담을 수 있는 공간을 가진 로봇을 사용하려고 한다.

처음에 로봇은 $x = 0$ 에서 출발하며 각 모양의 공을 담는 공간은 비어있다.

로봇은 괄호 안의 숫자만큼의 힘을 사용해서 다음과 같은 일들을 할 수 있다.

- 오른쪽이나 왼쪽으로 한 칸 움직인다. ($1$)
- 현재 위치에 공이 있고, 로봇에 담을 수 있다면 모양에 해당하는 공간에 담는다. ($0$)
- 현재 위치에 있는 공의 모양을 다른 모양으로 바꾼다. ($C$)
- $x = 0$ 에 있을 때 담고 있는 공을 창고에 넣는다. ($0$)

로봇이 공이 있는 위치를 지난다고 해서 반드시 그 공을 담아야하는 것은 아니다.

이때 모든 공을 창고로 옮기기 위해 필요한 최소한의 힘을 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $T$($1 \leq T \leq 100$)가 주어진다.

각 테스트케이스의 첫 번째 줄에는 두 정수 $N, C$ ($0 \leq C \leq 10^9$)이 주어진다.

다음 $N$개의 줄에 걸쳐 각 공들의 위치와 모양이 두 정수 $X_i, S_i$ ($-10^9 \leq X_i \leq 10^9$, $0 \leq S_i \leq 1$)로 주어진다.

- Test Set 1: $1 \leq N \leq 5000$
- Test Set 2: $1 \leq N \leq 10^5$

**[OUTPUT]**

각 테스트케이스마다 모든 공을 창고로 옮기기 위해 필요한 최소한의 힘을 출력한다.

---

### [IDEA]

공을 담고 있는 상태에서 $x = 0$ 을 지나간다면 반드시 창고에 공을 넣는 것이 효율적이다.

따라서 양의 정수 위치에 있는 공들과 음의 정수 위치에 있는 공들을 옮기는 일은 따로 분리해서 생각할 수 있다.

모든 공이 양의 정수 위치에 있는 경우를 생각하고, 공들의 위치 $X_i$가 오름차순으로 정렬되어 있다고 가정하자.

로봇의 경로는 $0$에서 출발하여 하나 또는 두 개의 공을 담고 $0$으로 돌아오는 사이클로 이루어져 있다.

하나의 공을 옮기는데 필요한 힘은 $2X_i$,

서로 다른 모양의 두 공을 옮기는데 필요한 힘은 $2 \max(X_i, X_j)$,

같은 모양의 두 공을 옮기는데 필요한 힘은 $2 \max(X_i, X_j) + C$ 이다.

즉, 이 문제는 비용이 최소가 되도록 두 공을 매칭하는 문제로 생각할 수 있다.

> **Observation 1.** 첫 $i$($i \geq 2$)개의 공들을 옮길 때, $S_i \neq S_{i-1}$ 이면 최대한 효율적으로 옮기기 위해서는 $(i-1, i)$ 번째 공을 매칭해야한다.

위 Observation 1로부터 가장 오른쪽 두 공이 서로 다른 모양일 경우를 처리할 수 있다.

---

### [TEST SET 1 SOLUTION] DP

> > **Observation 2.** 첫 $i$($i \geq 2$)개의 공들을 옮길 때, $S_i = S_{i-1}$ 이면 최대한 효율적으로 옮기기 위해서는 다음 세 경우 중 하나를 만족해야한다.
> > 
> > - $(i-1, i)$ 가 매칭
> > - $i$번째 공보다 왼쪽에 있으면서 다른 모양인 가장 가까운 공을 $j$라고 하면, $(j, i)$ 가 매칭
> > - 다른 모양의 공이 없고 $i$번째 공이 매칭되지 않은 상태

Observation 1, 2 를 이용하면 DP 해를 얻을 수 있다.

```cpp

```

---

### [TEST SET 2 SOLUTION] DP













