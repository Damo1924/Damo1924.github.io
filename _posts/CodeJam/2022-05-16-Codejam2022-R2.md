---
title: "[CodeJam 2022] Round 2"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Coding Contest
use_math: true
comments: true

---

`Tags` 

## Review & Review

시작하고 1시간 동안 1, 2번을 잡고 있었지만, 도무지 방법이 생각나지 않았다.

부분점수라도 긁어볼까 생각도 했지만 이미 반포기 상태였고, 제출조차 하지 않고 대회를 마무리했다.

지금 포스팅을 하는 시점에서 1000등 컷이 25점인 것을 감안하면, 어려웠던 건 맞는 것 같다.

기대를 하지 않는다고 말했지만, 나름 희망을 품었기에 더 빠르게 놓아버린 것 같아 아쉽다.

코드포스도 그렇고 점수와 성과에 연연하다보니 조급해지고 생각대로 잘 풀리지 않으면 빠르게 포기해버리는 것 같다.

이번 코드잼이 변환점이 될 수 있을지..는 잘 모르겠다.

무엇이라도 성과를 내야할 것 같다는 압박감이 있다.

조금 허망하다.

<br/>

## 1. Spiraling Into Control

[CodeJam 2022 Round 2 1. Spiraling Into Control 문제 링크](https://codingcompetitions.withgoogle.com/codejam/round/00000000008778ec/0000000000b15a74#problem)

**[PROBLEM]**

홀수 $N$에 대하여, $N \times N$ 크기의 집은 $1 \times 1$ 크기의 방들로 나누어져 있다.

총 $N^2$개의 방은 $1$부터 $N^2$까지 번호를 가지는데, 가장 왼쪽 위 방부터 시작해서 시계방향으로 돌면서 번호를 부여하였다.

$N$은 홀수이기 때문에 정가운데 있는 방은 항상 $N^2$의 번호를 가진다.

단테는 $1$번 방에서 출발하여 $N^2$번 방까지 이동해야한다.

단테는 현재 위치한 방보다 큰 번호를 가진 인접한 방으로 이동할 수 있는데, 이때 번호의 차이가 $1$보다 큰 경로를 지름길이라고 한다.

즉, 지름길이란 번호가 연속적이지 않은 인접한 방으로의 이동을 의미한다.

어떤 정수 $K$에 대하여, 단테가 정확히 $K$번 이동하여 $N^2$번 방에 도달할 수 있는 방법을 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $T$($1 \leq T \leq 100$)가 주어진다.

각 테스트케이스는 두 정수 $N, K$ ($3 \leq N \leq 9999$, $1 \leq K < N^2 - 1$)로 이루어져 있다.

**[OUTPUT]**

각 테스트케이스마다 $1$번 방에서 출발하여 정확히 $K$번 이동해서 $N^2$번 방에 도착하는 방법이 있다면 첫 번째 줄에 지름길의 개수 $S$를 출력하고,

다음 $S$개의 줄에 걸쳐 각 지름길이 연결하는 두 방의 번호를 공백으로 구분하여 출력한다.

만약 방법이 존재하지 않는다면 IMPOSSIBLE 을 출력한다.

---

### [SOLUTION] Math

주어진 $N, K$에 대하여 지름길로 $S$번 이동했을 때, $i$번째 지름길의 방 번호 차이를 $D_i$라고 하면 다음이 성립한다.

\begin{aligned}
(K - S) + \sum_{i=1}^S D_i = N^2 - 1
\end{aligned}

위 식에서 $-S$ 를 시그마 항 안으로 넣어 식을 정리해주면,

\begin{aligned}
\sum_{i=1}^S (D_i - 1) = N^2 - 1 - K
\end{aligned}

를 얻을 수 있다.

전체 방들은 $\frac{N+1}{2}$ 개의 고리로 나눌 수 있는데, 가장 안쪽 고리를 $1$번, 가장 바깥쪽 고리를 $\frac{N+1}{2}$번 고리라고 하자.

각 고리마다 지름길을 한 번씩만 선택할 수 있으며, $r$번 고리의 각 지름길의 방 번호 차이는

\begin{aligned}
8r - 1, 8r - 3, 8r - 5, 8r - 7
\end{aligned}

이다.

이는 고리의 윗쪽에서 지름길을 타면 현재 방의 번호에 $8r - 1$ 을 더한 방으로 이동한다는 것을 의미한다.

마찬가지로 고리의 오른쪽에서는 $8r-3$만큼 방 번호가 증가하고, 아래쪽에서는 $8r-5$, 왼쪽에서는 $8r-7$만큼 증가한다.

즉, 지름길을 선택하면 방 번호가 홀수만큼 증가하므로 $D_i$는 홀수이고, 앞서 구한 식으로부터 $K$가 홀수이면 경로가 존재하지 않는다는 것을 알 수 있다.

또, $1$번 방으로부터 $N^2$번 방까지의 최소 이동 횟수는 $N-1$번이므로 $K < N-1$ 인 경우에도 경로가 존재하지 않는다.

위 두 가지 경우를 제외한다면, 적절한 지름길을 통해 목적지까지 도달할 수 있다.

남은 이동 거리 $D$를 $D = N^2 - 1 - K$ 로 정의하면, $r = \frac{N+1}{2}$ 부터 아래 과정을 반복함으로써 지름길을 타는 위치를 구할 수 있다.

- $D \geq 8r - 2$ 이면 $r$번째 고리의 위쪽에서 지름길을 탄다.
- $D = 8r - 4$ 또는 $D = 8r - 6$ 또는 $D = 8r - 8$ 이면 각각 고리의 오른쪽, 아래쪽, 왼쪽에서 지름길을 탄다.
- 지름길을 탄 후 $D$에서 지름길을 탄 위치에 따라 $8r - 2$, $8r - 4$, $8r - 6$, $8r- 8$ 를 빼준다.
- 만약 $D = 0$ 이 되면 더 이상 지름길을 타지 않는다.

이후 $r$번 고리의 가장 왼쪽 위 방의 번호가 $N^2 - 4r(r+1)$ 임을 이용하여 지름길에 해당하는 두 방의 번호를 찾아주면 된다.

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int T; cin >> T;
    for (int t = 1; t <= T; t++)
    {
        int N, K; cin >> N >> K;
        if (K < N - 1 || K % 2)
        {
            cout << "Case #" << t << ": IMPOSSIBLE\n";
            continue;
        }
        
        vector<pair<int, int>> sc;
        int D = N * N - 1 - K;
        for (int r = N / 2; r; r--)
        {
            int x = N * N - 4 * r * (r + 1);
            int y = x + 8 * r;
            int d = 8 * r - 2;
            for (int i = 0; i <= 6; i += 2)
            {
                if (D >= d - i)
                {
                    sc.push_back({ x + i * r + 1, y + i * (r - 1) });
                    D -= d - i;
                    break;
                }
            }
            if (D == 0) break;
        }
        
        cout << "Case #" << t << ": " << sc.size() << "\n";
        for (auto [x, y] : sc) cout << x << " " << y << "\n";
    }
}
```

<br/>

## 2. Pixelated Circle

[CodeJam 2022 Round 2 2. Pixelated Circle 문제 링크](https://codingcompetitions.withgoogle.com/codejam/round/00000000008778ec/0000000000b158f7)

**[PROBLEM]**

반지름이 $R$인 원을 그리는 아래의 두 함수의 결과의 차이를 구하여라.

`set_pixel_to_black(x, y)` 는 $(x, y)$ 픽셀을 검정색으로 칠하는 함수이다.

첫 번째 함수는 아래와 같다.

```cpp
void draw_circle_perimeter(int R)
{
    for (int x = -R; x <= R; x++)
    {
        int y = round(sqrt(R * R - x * x));
        set_pixel_to_black(x, y);
        set_pixel_to_black(x, -y);
        set_pixel_to_black(y, x);
        set_pixel_to_black(-y, x);
    }
}

void draw_circle_wrong(int R)
{
    for (int r = 0; r <= R; r++)
        draw_circle_perimeter(r);
}
```

두 번째 함수는 아래와 같다.

```cpp
void draw_circle_filled(int R)
{
    for (int x = -R; x <= R; x++)
        for (int y = -R; y <= R; y++)
            if (round(sqrt(x * x + y * y)) <= R)
                set_pixel_to_black(x, y);
}
```

단, 검정색으로 칠한 칸을 다시 칠해도 그대로 검정색이다.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $T$($1 \leq T \leq 100$)가 주어진다.

각 테스트케이스는 정수 $R$ ($3 \leq R \leq 10^5$)로 이루어져 있다.

**[OUTPUT]**

각 테스트케이스마다 두 함수의 결과에서 서로 색깔이 다른 픽셀의 개수를 출력한다.

---

### [SOLUTION] Math

함수 `draw_circle_filled(R)`에서 칠해진 픽셀들의 집합을 $C_f$, 함수 `draw_circle_wrong(R)`에서 칠해진 픽셀들의 집합을 $C_w$라고 하자.

<center><img src="" width="70%" height="70%"></center>

위 증명에 의해 $C_w \subseteq C_f$ 이며, 따라서 두 함수의 결과에서 색깔이 다른 부분의 개수는 $\left\vert C_f \right\vert - \left\vert C_w \right\vert$ 로 구할 수 있다.

먼저 $\left\vert C_f \right\vert$ 을 구하자.

<center><img src="" width="70%" height="70%"></center>

이제 $\left\vert C_w \right\vert$ 을 구하자.

<center><img src="" width="70%" height="70%"></center>

각 집합의 크기를 구하는 시간복잡도는 $O(R)$ 이다.

```cpp

```

<br/>



