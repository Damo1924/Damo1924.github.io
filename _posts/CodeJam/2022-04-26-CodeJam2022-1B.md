---
title: "[CodeJam 2022] Round 1B"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - PS
use_math: true
comments: true

---

`Tags` Interactive

## Review & Result

지난 라운드 1A에서 한 문제밖에 풀지 못하는 수모를 겪은 후 일주일 정도 열심히 문제를 풀었었는데, 나름 성공적이었던 것 같다.

다만, 첫 번째 문제와 두 번째 문제가 정말 쉬운 문제들이었는데 빠르게 풀지 못한게 아쉬웠다.

조금 긴장하다보니 그런 것 같은데, 한 시간이 지난 상황에서 2번을 맞고 난 다음에 1번과 3-1번까지 빠르게 풀었다.

대회가 새벽 1시에 시작해서 3시 반에 끝나는 일정이었는데, 3시 정도에 3-1까지 풀고 순위표를 보니 나처럼 85점을 맞은 사람이 1500명이 넘어갔다.

마지막으로 본 등수가 1560등 정도였는데, 굳이 더 제출해서 페널티 타임을 늘리지 말아야겠다는 생각으로 20분 정도를 남기고 자러갔다.

그러고 다음날 등수를 확인했더니 1437등이 되어있었다!

<center><img src="https://user-images.githubusercontent.com/88201512/165195506-93a9f9c8-f3d4-4482-a08f-a66659401fda.jpg"></center>

<br/>

## 1. Pancake Deque

[CodeJam 2022 Round 1B 1. Pancake Deque 문제 링크](https://codingcompetitions.withgoogle.com/codejam/round/000000000087711b/0000000000acd59d)

**[PROBLEM]**

덱(deque)에 저장된 팬케이크를 서빙하려고 한다.

즉, 양 끝에 있는 팬케이크만 서빙할 수 있다.

팬케이크를 서빙받은 손님은 자신이 받은 팬케이크가 지금까지 서빙된 모든 팬케이크들만큼 맛있거나 더 맛있어야 비용을 지불한다.

$i$번째 팬케이크의 맛있는 정도를 $D_i$가 주어질 때, 돈을 내는 손님의 수의 최댓값을 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $T$($1 \leq T \leq 100$)가 주어진다.

각 테스트케이스의 첫 번째 줄에는 정수 $N$($2 \leq N \leq 10^5$)이 주어진다.

두 번째 줄에는 $N$개의 정수 $D_1, D_2, \dots, D_N$($1 \leq D_i \leq 10^6$)이 주어진다.

**[OUTPUT]**

각 테스트케이스마다 비용을 지불하는 손님의 수의 최댓값을 출력한다.

---

### [SOLUTION] Greedy

마지막 팬케이크를 서빙하는 상황을 제외하면 두 가지 선택지가 있으므로 모든 경우의 수는 $2^{N-1}$이다.

처음에 **"양 끝에 있는 팬케이크 중 작은 것부터 서빙하면 안될까?"**라고 생각했다가 무슨 이유에서인지 포기하고 다음 문제로 넘어갔다.

다음 문제를 풀고 나서 침착한 마음으로 다시 보니 위 방법이 정답이었고, 이는 간단한 two-pointer 알고리즘으로 해결할 수 있다.

```cpp
#include <iostream>
using namespace std;

int n, d[100000];

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int T; cin >> T;
    for (int t = 1; t <= T; t++)
    {
        cin >> n;
        for (int i = 0; i < n; i++) cin >> d[i];
        
        int s = 0, e = n - 1, mx = 0, ans = 0;
        while (s <= e)
        {
            if (d[s] < d[e])
            {
                if (mx <= d[s]) ans++;
                mx = max(mx, d[s++]);
            }
            else
            {
                if (mx <= d[e]) ans++;
                mx = max(mx, d[e--]);
            }
        }
        cout << "Case #" << t << ": " << ans << "\n";
    }
}
```

<br/>

## 2. Controlled Inflation

[CodeJam 2022 Round 1B 2. Controlled Inflation 문제 링크](https://codingcompetitions.withgoogle.com/codejam/round/000000000087711b/0000000000accfdb)

**[PROBLEM]**

바람을 넣을 수 있는 펌프가 주어진다.

이 펌프는 목표 압력을 설정하면 그만큼 공기를 주입해주는데, 압력은 $+1$, $-1$에 해당하는 두 버튼으로 조절할 수 있다.

총 $N$명의 사람이 각각 $P$개의 물건을 들고 펌프를 사용하기 위해 기다리고 있다.

사람들의 순서는 바꿀 수 없지만, 각 사람이 들고 있는 물건들은 순서를 바꿀 수 있다.

펌프의 초기 압력이 $0$일 때, 압력을 조절하는 버튼을 누르는 횟수의 최솟값을 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $T$($1 \leq T \leq 100$)가 주어진다.

각 테스트케이스의 첫 번째 줄에는 두 정수 $N, P$($2 \leq N \leq 1000$, $2 \leq P \leq 100$)이 주어진다.

두 번째 줄부터 $N$개의 줄마다 $P$개의 정수 $X_{i, 1}, X_{i, 2}, \dots, X_{i, P}$($1 \leq X_{i, j} \leq 10^9$)이 주어진다.

$X_{i, j}$는 $i$번째 사람의 $j$번째 물건의 목표 압력이다.

**[OUTPUT]**

각 테스트케이스마다 모든 물건에 바람을 넣는데 필요한 버튼 누르는 횟수의 최솟값을 출력한다.

---

### [SOLUTION] Math + DP

이 문제의 핵심은 **각 사람이 자신들의 물건을 목표 압력 순으로 정렬해서 펌프를 사용**하는 것을 알아내는 것이다.

위 사실을 이용하면 각 사람마다 목표 압력이 가장 작은 물건부터 바람을 넣을 것인지, 아니면 목표 압력이 가장 큰 물건부터 바람을 넣을 것인지 선택해주면 된다.

펌프의 초기 압력이 $0$이므로 첫 번째 사람은 반드시 목표 압력이 작은 것부터 바람을 넣어야한다.

따라서 전체 경우의 수는 $2^{N-1}$이고, 모든 경우를 탐색함으로써 첫 번째 테스트 셋을 통과할 수 있다.

두 번째 테스트 셋을 통과하기 위해서는 DP로 해결해야한다.

$i$번째 사람이 목표 압력이 가장 큰 물건을 마지막으로 바람을 넣었을 때의 최솟값을 $dp\[i\]\[0\]$,

목표 압력이 가장 작은 물건을 마지막으로 바람을 넣었을 때의 최솟값을 $dp\[i\]\[1\]$이라 하면 다음이 성립한다.

\begin{aligned}
dp\[i + 1\]\[0\] = mx\[i+1\] - mn\[i+1\] + \min(dp\[i\]\[0\] + \left\vert mn\[i+1\] - mx\[i\] \right\vert, dp\[i\]\[1\] + \left\vert mn\[i+1\] - mn\[i\] \right\vert
\end{aligned}

\begin{aligned}
dp\[i + 1\]\[1\] = mx\[i+1\] - mn\[i+1\] + \min(dp\[i\]\[0\] + \left\vert mx\[i+1\] - mx\[i\] \right\vert, dp\[i\]\[1\] + \left\vert mx\[i+1\] - mn\[i\] \right\vert
\end{aligned}

이때 $mx\[i\], mn\[i\]$는 각각 $i$번째 사람의 최대 압력과 최소 압력이다.

```cpp
#include <iostream>
using namespace std;
typedef long long ll;

int n, p, x[1000][2];
ll ans, dp[1000][2];

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int T; cin >> T;
    for (int t = 1; t <= T; t++)
    {
        ans = 0;
        cin >> n >> p;
        for (int i = 0; i < n; i++)
        {
            int mx = 0, mn = 1e9;
            for (int j = 0; j < p; j++)
            {
                int k; cin >> k;
                mx = max(mx, k);
                mn = min(mn, k);
            }
            x[i][0] = mx;
            x[i][1] = mn;
            ans += mx - mn;
        }
        
        ans += x[0][1];
        dp[1][0] = abs(x[1][0] - x[0][0]);
        dp[1][1] = abs(x[1][1] - x[0][0]);
        for (int i = 2; i < n; i++)
        {
            dp[i][0] = min(dp[i - 1][0] + abs(x[i - 1][1] - x[i][0]), dp[i - 1][1] + abs(x[i - 1][0] - x[i][0]));
            dp[i][1] = min(dp[i - 1][0] + abs(x[i - 1][1] - x[i][1]), dp[i - 1][1] + abs(x[i - 1][0] - x[i][1]));
        }
        cout << "Case #" << t << ": " << ans + min(dp[n - 1][0], dp[n - 1][1]) << "\n";
    }
}
```

<br/>

## 3. AseDatAb

[CodeJam 2022 Round 1B 3. AseDatAb 문제 링크](https://codingcompetitions.withgoogle.com/codejam/round/000000000087711b/0000000000acd29b)

**[PROBLEM]**

데이터베이스에 '0'과 '1'로 이루어진 8-bit 문자열이 저장되어있다.

문자열의 가장 왼쪽 bit를 $0$, 가장 오른쪽 bit를 $7$로 인덱싱한다.

새로운 문자열 $V$가 주어지면, 다음 작업을 수행한다.

1. $0$부터 $7$까지의 정수 중 하나를 선택한 것을 $r$이라 하면, $V$를 오른쪽을 $r$만큼 회전한 것을 $W$라 한다. 즉, $W$의 $((i + r) \bmod 8)$번째 bit가 $V$의 $i$번째 bit이다.
2. 현재 데이터베이스에 저장된 문자열 $X$를 $X$ XOR $W$로 대체한다.
3. 새롭게 저장된 문자열에 있는 $1$의 개수를 세어 반환한다.

초기 데이터베이스에 어떤 값이 저장되어 있고, 어떤 $r$을 선택하는가에 관계 없이 $300$번 이하의 위 작업을 수행하여 저장된 문자열의 모든 bit가 '0'이도록 만들 수 있다.

이를 수행하는 프로그램을 작성하여라.

**[INPUT & OUTPUT]**

첫 번째 줄에는 테스트케이스의 개수 $T$($1 \leq T \leq 100$)가 주어진다.

각 테스트케이스에 대해 임의의 8-bit binary string을 입력하면, 저장된 값을 업데이트한 후에 1의 개수를 출력한다.

작업을 $300$번 이내로 수행하여 데이터베이스에 저장된 문자열의 1의 개수가 0이 되도록 만들어야한다.

단, 초기 데이터베이스에 저장된 문자열에는 적어도 1개의 1이 존재한다.

Test Set 1: Initial value & each rotation value is uniformly random

Test Set 2: **adversarial**(적대적) judge, judge can change the initial value & rotation value

---

### [TEST SET 1 SOLUTION] Uniformly Random






