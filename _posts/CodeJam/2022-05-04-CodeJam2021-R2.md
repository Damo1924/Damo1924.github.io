---
title: "[CodeJam 2021] Round 2"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Coding Contest
use_math: true
comments: true

---

`Tags` DP

## Review

다음주 토요일에 올해 코드잼 라운드 2가 열리는데, 난이도가 어느 정도인지 확인해보기 위해 기출 문제들을 풀어보았다.

1000등 컷이 앞의 3문제를 페널티 없이 시간 내에 푸는 정도였는데, 조금 애매한 것 같다.

확실히 상위 4500명이라서 그런지 간단한 문제들은 대부분이 풀고, 어려운 두 문제에서 갈리는 듯하다.

첫 번째 문제는 그리디, 두 번째 문제는 DP를 이용해서 쉽게 풀 수 있는 형태였다.

세 번째 문제는 조금 까다롭긴 했는데, 풀지 못할 정도는 아니었다.

네 번째 문제는 쉽지 않은 것 같아서 Test set 1만 긁어보았다.

모의 테스트를 끝내고 해설을 보니까 공부한 적이 있는 헝가리안 알고리즘을 이용하는 문제였다.

<br/>

## 1. Minimum Sort (interactive problem)

[CodeJam 2022 Round 2 1. Minimum Sort 문제 링크](https://codingcompetitions.withgoogle.com/codejam/round/0000000000435915/00000000007dc51c)

**[PROBLEM]**

서로 다른 정수들로 이루어진 길이가 $N = 100$인 수열을 오름차순으로 정렬하는 문제이다.

정렬하기 위해 사용할 수 있는 쿼리는 아래 두 가지뿐이다.

- "M $i$ $j$" ($i < j$): 구간 $\[i, j\]$에 해당하는 부분수열의 원소 중 최솟값의 위치를 반환한다.
- "S $i$ $j$" ($i < j$): 인덱스가 $i$, $j$인 원소들끼리 교환한다.

단, 최솟값을 구하는 쿼리는 $\lceil 10^8 / (j - i + 1) \rceil$ 만큼의 비용이 든다.

이때 $6 \times 10^8$ 이하의 비용으로 주어진 수열을 오름차순으로 정렬하는 프로그램을 작성하여라.

**[INPUT & OUTPUT]**

첫 번째 줄에는 테스트케이스의 개수 $T$와 수열의 길이 $N$($1 \leq T \leq 100$, $N = 100$)이 주어진다.

각 테스트케이스에 대하여 쿼리를 이용해 한도를 초과하지 않으면서 수열을 정렬한다.

정렬을 마치면 "D" 를 출력한다.

Judge는 "S" 또는 "D" 로 시작하는 쿼리에 대해 문제가 없다면 1을 반환한다.

---

### [SOLUTION] Greedy

구간의 최솟값의 위치를 반환하는 쿼리는 **구간의 길이가 길수록 비용이 감소**한다.

따라서 최소한의 비용으로 정렬을 하는 방법은 $i$가 $1$부터 $N-1$까지 변할 때, **$i$번째 자리에 올 원소를 찾아 교환**하는 것이다.

이렇게 하면 길이가 $100$, $99$, ..., $2$ 인 구간에 대해 최솟값을 구하는데, 사용하는 총 비용은 다음과 같다.

\begin{aligned}
\sum_{i = 2}^{100} \left\lceil \frac{10^8}{i} \right\rceil < 4.2 \times 10^8
\end{aligned}

따라서 최대 비용을 초과하지 않고 정렬이 가능하다.

```cpp
#include <iostream>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t, n; cin >> t >> n;
    while (t--)
    {
        for (int l = 1; l < n; l++)
        {
            cout << "M " << l << " " << n << "\n" << flush;
            int mn; cin >> mn;
            if (l != mn)
            {
                cout << "S " << l << " " << mn << "\n" << flush;
                cin >> mn;
            }
        }
        cout << "D\n" << flush;
        int res; cin >> res;
    }
}
```

<br/>

## 2. Matrygons

[CodeJam 2022 Round 2 2. Matrygons 문제 링크](https://codingcompetitions.withgoogle.com/codejam/round/0000000000435915/00000000007dbf06)

**[PROBLEM]**

한 정다각형의 꼭짓점들을 연결해서 또다른 정다각형을 안쪽에 그릴 수 있다.

이를 반복해서 얻은 정다각형들을 $a_1, a_2, \dots, a_k$ 라고 할 때,

주어진 $N$에 대하여 $a_1 + a_2 + \dots + a_k = N$ 을 만족하는 정다각형들의 집합의 크기의 최솟값을 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $T$($1 \leq T \leq 100$)가 주어진다.

각 테스트케이스는 하나의 정수 $N$($3 \leq N \leq 10^6$)로 이루어진다.

**[OUTPUT]**

각 테스트케이스에 대하여 조건을 만족하는 정다각형들의 집합의 크기의 최솟값을 출력한다.

---

### [SOLUTION] DP

Bottom-up 방식으로 정$n$각형에서 시작해서 얻을 수 있는 모든 경우를 전부 탐색해주었다.

$3 \leq n \leq 10^6$ 인 각 $n$에 대하여, 정다각형들의 꼭짓점의 개수의 합이 $10^6$ 이하일 때까지 가능한 모든 정다각형들의 집합을 탐색한다.

```cpp
#include <iostream>
using namespace std;
typedef long long ll;

int N = 1e6, dp[1000001];

void dfs(ll n, ll sum, int cnt)
{
    dp[sum] = max(dp[sum], cnt);
    for (int i = 2; i; i++)
    {
        if (sum + i * n <= N) dfs(i * n, sum + i * n, cnt + 1);
        else break;
    }
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    for (int i = 3; i <= N; i++) dfs(i, i, 1);
    
    int T; cin >> T;
    for (int t = 1; t <= T; t++)
    {
        int n; cin >> n;
        cout << "Case #" << t << ": " << dp[n] << "\n";
    }
}
```

<br/>

## 3. Hidden Pancakes

[CodeJam 2022 Round 2 3. Hidden Pancakes 문제 링크](https://codingcompetitions.withgoogle.com/codejam/round/0000000000435915/00000000007dc20c)

**[PROBLEM]**

반지름이 $1$ cm 인 펜케이크부터 반지름이 $N$ cm 인 펜케이크까지 총 $N$개의 펜케이크를 만들려고 한다.

펜케이크를 만들고 나면 전에 만든 펜케이크 위에 쌓는데, 펜케이크를 올리면 해당 펜케이크보다 작은 펜케이크들은 보이지 않게 된다.

$i$개의 펜케이크를 쌓았을 때 보이는 펜케이크의 개수를 $V_i$라고 하자.

$V_1, V_2, \dots, V_N$ 이 주어질 때, 펜케이크를 만드는 $N!$ 가지의 순서들 중 조건을 만족하는 것의 개수를 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $T$($1 \leq T \leq 100$)가 주어진다.

각 테스트케이스의 첫 번째 줄에는 정수 $N$($2 \leq N \leq 10^5$)가 주어진다.

두 번째 줄에는 $N$개의 정수 $V_1, V_2, \dots, V_N$가 주어진다.

**[OUTPUT]**

각 테스트케이스에 대해 조건을 만족하는 펜케이크 제작 순서의 개수를 $10^9 + 7$로 나눈 나머지를 출력한다.

---

### [SOLUTION] Stack + DFS + Fermat's little theorem



```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <stack>
using namespace std;
typedef long long ll;
const int MOD = 1e9 + 7;

int v[100000];
vector<int> g[100000];

ll ans, f[100000], inv[100000];
ll pow(int x, int y)
{
    if (y == 1) return x;
    ll tmp = pow(x, y / 2);
    if (y % 2) return tmp * tmp % MOD * x % MOD;
    return tmp * tmp % MOD;
}

int solve(int u)
{
    int u_size = 0;
    for (int v : g[u])
    {
        int v_size = solve(v);
        ans = ans * inv[v_size + 1] % MOD;
        u_size += v_size + 1;
    }
    ans = ans * f[u_size] % MOD;
    return u_size;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    f[0] = 1, inv[0] = 1;
    for (int i = 1; i < 100000; i++) f[i] = f[i - 1] * i % MOD;
    for (int i = 1; i < 100000; i++) inv[i] = pow(f[i], MOD - 2);
    
    int T; cin >> T;
    for (int t = 1; t <= T; t++)
    {
        int n; cin >> n;
        for (int i = 0; i < n; i++)
        {
            g[i].clear();
            cin >> v[i];
        }
        
        ans = 1;
        stack<int> s;
        s.push(0);
        for (int i = 1; i < n; i++)
        {
            if (v[i - 1] + 1 == v[i])
            {
                g[i - 1].push_back(i);
                s.push(i);
                continue;
            }
            
            while (s.size() && v[s.top()] != v[i] - 1)
            {
                if (v[s.top()] < v[i] - 1) ans = 0;
                if (v[s.top()] == v[i]) g[i].push_back(s.top());
                s.pop();
            }
            if (!s.empty())
            {
                g[s.top()].pop_back();
                g[s.top()].push_back(i);
            }
            s.push(i);
        }
        
        while (s.size() > 1) s.pop();
        solve(s.top());   
        cout << "Case #" << t << ": " << ans << "\n";
    }
}
```

---

### [SOLUTION] 







