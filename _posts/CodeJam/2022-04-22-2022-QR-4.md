---
title: "[CodeJam 2022] Qualification Round. Chain Reactions"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - PS
use_math: true
comments: true

---

`Tags` DFS, Divide & Conquer, 분할정복

## [CodeJam 2022] Qualification Round. Chain Reactions

[CodeJam 2022 Qualification Round. Chain Reactions](https://codingcompetitions.withgoogle.com/codejam/round/0000000000876ff1/0000000000a45ef7)

**[PROBLEM]**

한 기계를 이루는 $N$개의 모듈들은 $1$부터 $N$까지의 번호가 매겨져 있다.

각 모듈은 더 작은 번호를 가진 다른 하나의 모듈을 가리킬 수 있는데, 가리키는 모듈이 없으면 빈 공간을 가리킨다.

다른 모듈들로부터 지목당하지 않은 모듈은 initiator라 불리며, 윌리는 initiator들을 직접 가동할 수 있다.

어떤 모듈이 가동되면, 해당 모듈이 가르키고 있는 모듈이 가동되는데, 이 과정은 빈 공간을 가리키는 모듈이나 이미 가동된 모듈을 만나면 중단된다.

위 과정을 Chain Reaction이라고 부른다.

각 모듈은 fun factor $F_i$를 가지고 있는데, 윌리는 하나의 chain reaction으로부터 해당 과정에서 가동된 모듈의 $F_i$ 중 가장 큰 값만큼의 fun을 얻는다.

윌리가 initiator들을 가동하는 순서를 달리했을 때, 얻은 수 있는 최대 fun을 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $T$가 주어지며, 각 테스트케이스는 세 줄의 입력으로 이루어진다.

테스트케이스의 첫 번째 줄에는 정수 $N$이 주어진다.

두 번째 줄에는 $N$개의 정수 $F_1, F_2, \dots, F_N$이 주어진다.

세 번째 줄에는 $N$개의 정수 $P_1, P_2, \dots, P_N$이 주어지는데, $P_i$는 모듈 $i$가 가르키는 모듈의 번호이다.

만약 $P_i = 0$이면 빈 공간을 가리킨다는 의미이다.

**[OUTPUT]**

각 테스트케이스마다 윌리가 얻을 수 있는 최대한의 fun을 출력한다.

---

### [SOLUTION] Divide & Conquer + DFS (Greedy)

각 모듈이 가리키는 모듈을 부모 모듈이라고 생각한다면, 전체 기계는 여러 개의 트리(tree)로 구성된 그래프로 해석할 수 있다.

그래프를 이루는 각 트리의 루트 노드는 빈 공간을 가리키는($P_i = 0$) 모듈들이 된다.

윌리가 얻을 수 있는 최대 fun은 각 트리에서 얻을 수 있는 최대 fun을 모두 합한 것인데,

각 트리에서 얻을 수 있는 최대 fun은 루트 노드의 자식들을 루트로 하는 부트리(subtree)들의 최대 fun을 통해 구할 수 있다.

따라서, 이는 분할정복을 통해 해결할 수 있음을 알 수 있다.

---

트리에서 처음으로 어떤 리프 노드를 가동한다면, 해당 리프 노드부터 트리의 루트 노드까지의 경로에 있는 노드가 모두 가동된다.

즉, 루트 노드를 포함하는 chain reaction은 리프 노드의 개수만큼 존재하는데,

최대 fun을 얻기 위해서는 **이 경로들 중 루트 노드를 제외했을 때의 fun이 가장 작은 경로**를 선택해야한다.

이 사실을 이용해서 

- $S_i$ : 노드 $i$를 루트로 하는 부트리에서, 리프 노드들부터 $i$의 자식 노드들까지의 chain reaction으로 얻을 수 있는 fun 중 최솟값
- $T_i$ : 노드 $i$를 루트로 하는 부트리에서 얻을 수 있는 최대 fun

노드 $i$의 자식 노드들을 $j$라고 할 때, $S_i$는 다음과 같이 구할 수 있다.

\begin{aligned}
S_i = \min_{j} \left( \max(F_j, S_j) \right)
\end{aligned}

$T_i$는 $S_i$를 이용해서 다음과 같이 구할 수 있다.

\begin{aligned}
T_i = \sum_{j} T_j + \max(F_i, S_i) - S_i
\end{aligned}

즉, 루트 노드를 가동하는 chain reaction 중 얻을 수 있는 fun이 가장 작은 것을 선택하는 작업을 반복해서 해주는 것이다.

이는 DFS를 통해 구현할 수 있고, 각 노드를 한 번씩 탐색하므로 시간복잡도는 $O(N)$이다.

```cpp
#include <iostream>
#include <vector>
using namespace std;
typedef long long ll;
typedef pair<int, int> ii;

int n, f[100001], p[100001], s[100001];
vector<int> g[100001];

ll solve(int x)
{
    if (g[x].size() == 0)
    {
        s[x] = 0;
        return f[x];
    }

    ll res = 0;
    s[x] = 2e9;
    for (int y : g[x])
    {
        res += solve(y);
        s[x] = min(s[x], max(f[y], s[y]));
    }
    if (f[x] > s[x]) res += f[x] - s[x];
    return res;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int t; cin >> t;
    for (int i = 1; i <= t; i++)
    {
        cin >> n;
        for (int j = 1; j <= n; j++) cin >> f[j];
        for (int j = 1; j <= n; j++)
        {
            int p; cin >> p;
            g[p].push_back(j);
        }

        ll ans = 0;
        for (int j : g[0]) ans += solve(j);

        cout << "Case #" << i << ": " << ans << "\n";
        for (int j = 0; j <= n; j++) g[j].clear();
    }
}
```












