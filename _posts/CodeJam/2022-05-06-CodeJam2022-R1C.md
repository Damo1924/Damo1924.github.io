---
title: "[CodeJam 2022] Round 1C"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Coding Contest
use_math: true
comments: true

---

`Tags` 

## Review

코드잼 1라운드는 어떤 라운드에서 통과를 하면 그 이후 라운드들에는 참여할 수 없기 때문에 따로 풀어보았다.

간신히 1500등 안에 들어 통과한 지난 라운드에서 난이도 조절을 실패해서 그런지 확실히 더 어려웠다.

어느새 라운드 2가 일주일밖에 남지 않았다. 열심히 하자!

<br/>

## 1. Letter Blocks

[CodeJam 2022 Round 1C 1. Letter Blocks 문제 링크](https://codingcompetitions.withgoogle.com/codejam/round/0000000000877b42/0000000000afe6a1#problem)

**[PROBLEM]**

한 쪽 면에 알파벳 대문자가 적혀있는 나무 블록들을 쌓아 여러 개의 탑을 만들었다.

이 탑들을 합쳐 하나의 "megatower"를 만들려고 하는데, 조건은 다음과 같다.

- 어떤 두 탑을 합칠 때에는 한 탑을 다른 탑 위에 그대로 쌓아야한다. (순서 변경 X)
- Megatower에 있는 각 알파벳들은 같은 알파벳들끼리 연속해야한다. 즉, 같은 알파벳들 사이에 다른 알파벳이 존재하면 안된다.

만들어둔 탑들이 주어질 때, 이들을 모두 합쳐서 하나의 megatower로 만들 수 있는지 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $T$($1 \leq T \leq 100$)가 주어진다.

각 테스트케이스의 첫 번째 줄에는 정수 $N$($2 \leq N \leq 100$)이 주어진다.

두 번째 줄에는 $N$개의 문자열 $S_1, S_2, \dots, S_N$($1 \leq \left\vert S_i \right\vert 10$)이 주어진다.

**[OUTPUT]**

각 테스트케이스마다 주어진 탑들을 모두 합쳐서 만든 megatower를 출력한다.

만약 megatower를 만들 수 없다면 IMPOSSIBLE을 출력한다.

---

### [SOLUTION] Implementation

Megatower를 만들 수 없게 되는 경우를 잘 처리해주는 것이 중요한 문제이다.

1번인 것을 감안하면 굉장히 애를 먹었다.

Megatower를 만들 수 있으려면 아래 조건을 모두 만족해야한다.

- 각 탑들이 megatower이다.
- 각 탑들의 중간에 위치하고 있는 알파벳들은 한 번만 나타나야한다. ('CAAT', 'TAX' 처럼 중간에 'A'가 여러 번 나타나면 안된다.)
- 어떤 알파벳으로 시작하는 탑과 끝나는 탑이 최대 한 개여야한다. (단, 'AAA'처럼 한 알파벳으로 이루어진 경우는 제외)
- 어떤 알파벳으로 시작하는 탑과 끝나는 탑이 모두 존재한다면, 두 탑은 반드시 연속해서 쌓아야한다.

코드를 좀 더 간단하게 짜고 싶었는데, 좋은 방법이 생각이 나지 않았다.

```cpp
#include <iostream>
#include <set>
#include <vector>
using namespace std;

string s[101];
int bot[26], top[26];

string megatower(int N)
{
    vector<string> v(26, "");
    vector<bool> chk(N + 1, 0), alp(26, 0);
    for (int i = 1; i <= N; i++)
    {
        char b = s[i][0], t = s[i].back();
        set<char> st;
        st.insert(b);
        for (int j = 1; j < s[i].size(); j++)
        {
            if (s[i][j - 1] == s[i][j]) continue;
            if (st.count(s[i][j])) return "IMPOSSIBLE";
            st.insert(s[i][j]);
            
            if (b != s[i][j] && t != s[i][j])
            {
                if (alp[s[i][j] - 'A']) return "IMPOSSIBLE";
                alp[s[i][j] - 'A'] = 1;
            }
        }
        
        if (st.size() == 1)
        {
            v[b - 'A'] += s[i];
            chk[i] = 1;
        }
        else
        {
            if (bot[b - 'A'] || top[t - 'A']) return "IMPOSSIBLE";
            bot[b - 'A'] = top[t - 'A'] = i;
        }
    }
    
    for (int i = 0; i < 26; i++) if (alp[i] && (bot[i] || top[i])) return "IMPOSSIBLE";
    
    string ans = "";
    for (int i = 1; i <= N; i++)
    {
        if (chk[i]) continue;
        chk[i] = 1;
        
        string tmp = s[i];
        
        while (true)
        {
            int b = tmp[0] - 'A';
            tmp = v[b] + tmp;
            v[b] = "";
            if (top[b])
            {
                if (chk[top[b]]) return "IMPOSSIBLE";
                tmp = s[top[b]] + tmp;
                chk[top[b]] = 1;
            }
            else break;
        }
        while (true)
        {
            int t = tmp.back() - 'A';
            tmp = tmp + v[t];
            v[t] = "";
            if (bot[t])
            {
                if (chk[bot[t]]) return "IMPOSSIBLE";
                tmp += s[bot[t]];
                chk[bot[t]] = 1;
            }
            else break;
        }
        ans += tmp;
    }
    for (int i = 0; i < 26; i++) ans += v[i];
    return ans;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    int T; cin >> T;
    for (int t = 1; t <= T; t++)
    {
        int N; cin >> N;
        for (int i = 1; i <= N; i++) cin >> s[i];
        for (int i = 0; i < 26; i++) bot[i] = 0, top[i] = 0;
        cout << "Case #" << t << ": " << megatower(N) << "\n";
    }
}
```

<br/>














