---
title: "[CodeJam 2022] Round 1A"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Coding Contest
use_math: true
comments: true

---

`Tags` Interactive

## Review & Result

한 달 정도 조금 어려운 알고리즘들을 공부하다가 참가해서 그런지 너무 못했다.

첫 번째 문제는 어렵지 않았지만, 남은 2시간 동안 나머지 두 문제를 아예 건드리지 못했다.

끝나고 나서 생각해보니 입력 범위가 작은 첫 테스트 셋이라도 점수를 얻었어야 했는데 아예 그럴 생각도 하지 않은게 아쉬웠다.

라운드 2에 진출하기 위해서는 1500등 안에 들어야하는데, 열심히 준비해서 다음 라운드에서 꼭 통과하고 싶다.

<br/>

## 1. Double or One Thing

[CodeJam 2022 Round 1A 1. Double or One Thing 문제 링크](https://codingcompetitions.withgoogle.com/codejam/round/0000000000877ba5/0000000000aa8e9c)

**[PROBLEM]**

알파벳 대문자로 이루어진 문자열이 주어진다.

이 문자열에서 원하는 만큼 문자를 선택한 후 다음과 같이 새로운 문자열을 만들 수 있다.(어떤 문자도 선택하지 않을 수도 있다.)

- 문자열의 왼쪽에서 오른쪽으로 이동하면서 아래 과정을 수행한다.
- 선택한 문자들은 두 번 추가하고 선택하지 않은 문자들은 한 번만 추가한다.

이렇게 만들 수 있는 문자열들 중 사전 순서로 가장 먼저 오는 것을 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $T$($1 \leq T \leq 100$)가 주어진다.

각 테스트케이스에 대하여 알파벳 대문자로 이루어진 문자열이 주어진다.

문자열의 길이는 $1$ 이상, $100$ 이하이다.

**[OUTPUT]**

각 테스트케이스마다 만들 수 있는 문자열들 중 사전 순서로 가장 먼저 오는 것을 출력한다.

---

### [SOLUTION] Greedy

$i$번째 문자를 선택했을 때 사전 순으로 더 먼저 오는 문자열이 되기 위해서는 $i$번째 알파벳이 $i + 1$번째 알파벳보다 사전순으로 더 앞서야한다.

따라서 주어진 문자열을 연속해서 같은 알파벳이 나타나는 구간들로 나누고 알파벳을 비교해주면 된다.

하지만 문자열의 마지막 구간은 반드시 선택하지 않는 것이 사전순으로 더 앞서기 때문에 마지막 부분은 선택하지 않는다.

```cpp
#include <iostream>
#include <string>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
    int T; cin >> T;
    for (int t = 1; t <= T; t++)
    {
        string s; cin >> s;
        vector<pair<char, int>> v = { { s[0], 1 } }; // { 알파벳, 개수 }
        for (int i = 1; i < s.size(); i++)
        {
            if (s[i - 1] == s[i]) v.back().second++;
            else v.push_back({ s[i], 1 });
        }
        
        string ans = "";
        for (int i = 0; i + 1 < v.size(); i++)
        {
            string tmp = "";
            tmp += v[i].first;
            if (v[i].first < v[i + 1].first) tmp += v[i].first; // 선택한 경우
            for (int j = 0; j < v[i].second; j++) ans += tmp;
        }
        for (int j = 0; j < v.back().second; j++) ans += v.back().first; // 마지막 구간은 선택하지 않는다.
        
        cout << "Case #" << t << ": " << ans << "\n";
    }
}
```

<br/>

## 2. Equal Sum

[CodeJam 2022 Round 1A 2. Equal Sum 문제 링크](https://codingcompetitions.withgoogle.com/codejam/round/0000000000877ba5/0000000000aa8fc1)

**[PROBLEM]**

서로 다른 정수들의 집합이 주어진다.

집합을 다음 조건을 만족하는 두 개의 부분집합으로 나누려고 한다.

- 집합의 모든 원소는 반드시 한 부분집합에 속한다.
- 두 부분집합은 공집합이 아니다.
- 각 부분집합의 원소들의 합이 같다.

이 문제를 다항 시간(polynomial time)에 해결할 수 있는 방법이 알려져 있지 않기 때문에, **절반의 정수를 직접 고를 수 있게** 해주었다.

$N$개의 서로 다른 정수를 선택하면, 선택한 정수들과 서로 다른 $N$개의 정수가 주어진다.

총 $2N$개의 서로 다른 정수를 위 조건을 만족하는 두 부분집합으로 나누는 방법을 구하여라.

**[INPUT & OUTPUT]**

첫 번째 줄에는 테스트케이스의 개수 $T$($1 \leq T \leq 100$)가 주어진다.

각 테스트케이스에 대하여 첫 번째 줄에 $N$개의 서로 다른 정수 $A_1, A_2, \dots, A_N$을 출력한다.

두 번째 줄에는 $1 \leq B_i \leq 10^9$, $B_i \neq A_j$를 만족하는 서로 다른 정수 $B_1, B_2, \dots, B_N$이 주어진다.

단, $A_1 + A_2 + \dots + A_N + B_1 + B_2 + \dots + B_N$이 짝수가 되도록 $B_i$가 주어진다.

마지막 줄에는 조건을 만족하는 두 부분집합 중 하나의 원소들을 출력한다.

---

### [SOLUTION] Constructive algorithm

$B_1, B_2, \dots, B_N$을 두 부분집합으로 나누는데, 각 부분집합의 원소들의 합 간의 차이가 작도록 나누자.

즉, $B_i$를 내림차순으로 정렬하여 원소들의 합이 작은 집합에 $B_i$를 삽입해준다.

모든 $i$에 대해 $B_i \leq 10^9$이므로 이렇게 만든 두 부분집합의 원소들의 합의 차이는 $10^9$보다 작다.

$2^30 > 10^9$ 이므로 $2$의 거듭제곱들의 수열 $2^{29}, 2^{28}, \dots, 2^1, 2^0$을 생각하자.

이 수열의 앞에서부터 원소들의 합이 작은 집합에 $2^k$를 삽입해주자.

$2^k$를 한 부분집합에 삽입하고 난 후, 두 부분집합의 원소들의 합의 차이는 최대 $2^k$이다.

따라서 $2^0 = 1$ 까지 한 부분집합에 삽입하고 나면 두 부분집합의 원소들의 합의 차이는 $0$ 또는 $1$이다.

$2N$개의 정수의 합이 짝수가 되도록 $B_i$들이 주어지기 때문에 차이가 $1$인 경우는 불가능하다.

**따라서 위 수열을 이루는 $2$의 거듭제곱 $30$개를 이용하면, $2^30$보다 작은 서로 다른 자연수들을 원소로 하는 임의의 집합에 대해 주어진 문제를 해결할 수 있다.**

즉, $2^0, 2^1, \dots, 2^29$를 제외한 나머지 $70$개의 수는 아무렇게나 정해도 상관없다.

```cpp

```



