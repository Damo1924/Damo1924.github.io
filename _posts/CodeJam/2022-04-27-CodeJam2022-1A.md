---
title: "[CodeJam 2022] Round 1A"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Coding Contest
use_math: true
comments: true

---

`Tags` Interactive

## Review & Result

한 달 정도 조금 어려운 알고리즘들을 공부하다가 참가해서 그런지 너무 못했다.

첫 번째 문제는 어렵지 않았지만, 남은 2시간 동안 나머지 두 문제를 아예 건드리지 못했다.

끝나고 나서 생각해보니 입력 범위가 작은 첫 테스트 셋이라도 점수를 얻었어야 했는데 아예 그럴 생각도 하지 않은게 아쉬웠다.

라운드 2에 진출하기 위해서는 1500등 안에 들어야하는데, 열심히 준비해서 다음 라운드에서 꼭 통과하고 싶다.

<br/>

## 1. Double or One Thing

[CodeJam 2022 Round 1A 1. Double or One Thing 문제 링크](https://codingcompetitions.withgoogle.com/codejam/round/0000000000877ba5/0000000000aa8e9c)

**[PROBLEM]**

알파벳 대문자로 이루어진 문자열이 주어진다.

이 문자열에서 원하는 만큼 문자를 선택한 후 다음과 같이 새로운 문자열을 만들 수 있다.(어떤 문자도 선택하지 않을 수도 있다.)

- 문자열의 왼쪽에서 오른쪽으로 이동하면서 아래 과정을 수행한다.
- 선택한 문자들은 두 번 추가하고 선택하지 않은 문자들은 한 번만 추가한다.

이렇게 만들 수 있는 문자열들 중 사전 순서로 가장 먼저 오는 것을 구하여라.

**[INPUT]**

첫 번째 줄에는 테스트케이스의 개수 $T$($1 \leq T \leq 100$)가 주어진다.

각 테스트케이스에 대하여 알파벳 대문자로 이루어진 문자열이 주어진다.

문자열의 길이는 $1$ 이상, $100$ 이하이다.

**[OUTPUT]**

각 테스트케이스마다 만들 수 있는 문자열들 중 사전 순서로 가장 먼저 오는 것을 출력한다.

---

### [SOLUTION] Greedy


```cpp
#include <iostream>
#include <string>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    
  int T; cin >> T;
	for (int t = 1; t <= T; t++)
	{
		string s; cin >> s;
		vector<pair<char, int>> v = { { s[0], 1 } };
		for (int i = 1; i < s.size(); i++)
		{
			if (s[i - 1] == s[i]) v.back().second++;
			else v.push_back({ s[i], 1 });
		}

		string ans = "";
		for (int i = 1; i < v.size(); i++)
		{
			string tmp = "";
			tmp += v[i - 1].first;
			if (v[i - 1].first < v[i].first) tmp += v[i - 1].first;
			for (int j = 0; j < v[i - 1].second; j++) ans += tmp;
		}
		for (int j = 0; j < v.back().second; j++) ans += v.back().first;

		cout << "Case #" << t << ": " << ans << "\n";
	}
}
```
