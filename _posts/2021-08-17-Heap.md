---
title: "Heap & Priority queue in C++"
toc: true
toc_label: "On this page"
toc_icon: "chevron-right"
categories:
  - Cpp
use_math: true

---

# 1. Heap
## 1-1. 힙(heap)이란?
힙(heap)은 완전 이진 트리의 일종으로, **부모 노드와 자식 노드 간에 항상 일정한 대소관계가 성립**하는 자료구조이다. 부모와 자식 노드의 대소관계에 따라서 **최대힙**과 **최소힙**으로 나눈다.
- **최대 힙(max heap)**: 부모 노드가 자식 노드보다 크거나 같은 완전 이진 트리
- **최소 힙(min heap)**: 부모 노드가 자식 노드보다 작거나 같은 완전 이진 트리

또 형제 노드 간에 대소 관계가 정해져 있지 않아 **부분 순서 트리(partial ordered tree)**라고 부르기도 한다.

힙은 일반적으로 배열에 저장되는데, 배열을 H라고 했을 때 원소 `H[i]`에 대해 다음이 성립한다. 일반적으로 힙을 배열에 저장할 때는 인덱스 1부터 저장한다. 즉, 루트의 인덱스가 1이다.
- 부모 노드: `H[i/2]`
- 왼쪽 자식 노드: `H[2*i]`
- 오른쪽 자식 노드: `H[2*i + 1]`

이진 탐색 트리와는 달리 힙 트리에서는 중복된 값을 허용한다. 힙을 이용하면 주어진 데이터들의 **최댓값이나 최솟값을 찾기 쉽다**는 장점이 있다. 최대 힙에서는 루트(root)에 최댓값이, 최소 힙에서는 루트에 최솟값이 오기 때문에 최댓값과 최솟값을 찾기 용이하다. 이를 이용하면 빠른 정렬 알고리즘 중 하나인 **힙 정렬(heap sort)**과 유용한 자료구조인 **우선순위 큐(priority queue)**를 구현할 수 있다.

## 1-2. 힙 구조에 원소 추가/삭제하기
힙 구조에서 원소를 추가하고 삭제하는 방법에 대해서 알아보자.

먼저 원소를 추가하기 위해서는 추가하려는 원소를 힙의 가장 끝(배열의 맨 끝)에 삽입한 후 그 원소를 부모 노드와 비교/교환하는 과정을 통해 힙으로 만들어야 한다. 삽입한 원소를 부모 노드와 비교해서 대소관계를 만족할 때까지 교환한다. 아래는 힙에 원소를 추가하는 함수를 구현한 코드이다.
```cpp
#include <iostream>
#include <vector>
using namespace std;

void swap (int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

void heappush (vector<int> *vec, int k) {
    vec->push_back(k); // 배열의 맨 끝에 원소 삽입
    int n = vec->size() - 1;
    
    // 부모-자식 노드 간 대소관계가 성립할 때까지 교환
    while ((*vec)[n] > (*vec)[n/2]) {
        swap(vec->data() + n, vec->data() + n/2);
        n = n/2;
        
        if (n == 1) break; // 루트에 도달하면 중단
    }
}

int main()
{
    vector<int> heap = {0, 10, 5, 7, 1}; // 인덱스 1부터 저장
    heappush(&vec, 9);
    for(int i = 1; i < heap.size(); i++) cout << heap[i] << " ";
}
```
```
10 9 7 1 5
```

힙에서 원소를 삭제하는 것은 루트에 있는 원소를 삭제함을 의미한다. 루트(배열의 맨 앞)를 삭제하고 배열의 맨 끝에 위치한 원소를 루트로 옮긴다. 그 다음 해당 원소를 자식 노드와 비교해서 대소 관계가 성립할 때까지 교환하는 과정을 반복해서 다시 힙 구조로 만들어준다. 아래는 힙에 원소를 삭제하는 함수를 구현한 코드이다.
```
#include <iostream>
#include <vector>
using namespace std;

void swap (int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

void heappop (vector<int> *vec) {
    int n = vec->size() - 1;
    
    // 루트와 맨 마지막 원소를 교환하고 루트였던 원소를 제거
    swap(vec->data(), vec->data() + n);
    vec->pop_back();
    
    // 부모-자식 노드 간 대소관계가 성립할 때까지 교환
    int i = 1, m;
    while ((*vec)[i] < (*vec)[2*i] || (*vec)[i] < (*vec)[2*i+1]) {
        if ((*vec)[2*i] < (*vec)[2*i+1]) m = 2*i+1;
        else m = 2*i;
        swap(vec->data() + i, vec->data() + m);
        i = m;
        
        if (2*i >= n) break;
        else if (2*i == n-1) {
            if ((*vec)[i] < (*vec)[2*i]) swap(vec->data() + i, vec->data() + 2*i);
            break;
        }
    }
}

int main()
{
    vector<int> heap = {0, 10, 9, 7, 1, 5};
    heappop(&heap);
    for(int i = 1; i < heap.size(); i++) cout << heap[i] << " ";
}
```
```
9 5 7 1
```

## 1-3. 리스트를 힙 구조로 변환하기
임의의 리스트를 힙 구조로 바꾸는 방법에 대해서 알아보자.

가장 먼저 떠오르는 방법은 기존 리스트에서 원소를 차례대로 빈 리스트에 `heappush()`하는 것이다. 그러나 이 방법은 $O(n \log n)$의 시간복잡도를 갖는다.

위 방법 대신 Bottom-up으로 접근하면 $O(n)$의 시간복잡도를 갖는 함수를 구현할 수 있다. 가장 아래에 있는 작은 트리부터 시작해서 점차 힙 구조로 만들어 나가는 방법이다. 아래는 임의의 배열을 힙 구조로 바꾸는 함수를 구현한 코드이다.
```cpp
#include <iostream>
#include <vector>
using namespace std;

void swap (int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

void heapify (vector<int> *vec) {
    int n = vec->size() - 1;
    for (int i = n/2; i > 0; i--) { // 가장 마지막 부모 노드(i=n/2)부터 루트(i=1)까지
        int j = i, m;
        while (2*j <= n) { // 해당 부모 노드를 자식 노드와 대소관계가 성립하도록 비교/교환
            if (2*j == n && (*vec)[j] < (*vec)[n]) {
                swap(vec->data() + j, vec->data() + n);
                break;
            }
            
            if ((*vec)[2*j] < (*vec)[2*j+1]) m = 2*j + 1;
            else m = 2*j;
            if ((*vec)[j] < (*vec)[m]) swap(vec->data() + j, vec->data() + m);
            j = m;
        }
    }
}

int main()
{
    vector<int> heap = {0, 1, 5, 9, 10, 7};
    heappop(&heap);
    for(int i = 1; i < heap.size(); i++) cout << heap[i] << " ";
}
```
```
10 7 9 5 1
```

## 1-4. 힙 정렬(heap sort)

